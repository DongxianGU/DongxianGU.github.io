<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Dongxian&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Dongxian&#39;s Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dongxian&#39;s Blog">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Dongxian's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dongxian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">2</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">9</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">25</span></a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/07/机器学习基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongxian Gu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/19640280?s=40&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dongxian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/07/机器学习基础/" class="post-title-link" itemprop="url">机器学习基础</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-07 20:59:18 / 修改时间：22:21:36" itemprop="dateCreated datePublished" datetime="2019-12-07T20:59:18+08:00">2019-12-07</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="机器学习基础-待完成"><a href="#机器学习基础-待完成" class="headerlink" title="机器学习基础(待完成)"></a>机器学习基础(待完成)</h1><blockquote>
<p>参考 花书 《深度学习》第五章 和 周志华《机器学习》</p>
</blockquote>
<h2 id="学习算法"><a href="#学习算法" class="headerlink" title="学习算法"></a>学习算法</h2><p>机器学习算法是一种能够从数据中学习的算法。</p>
<p>“学习”：对于某类任务T和性能度量P，一个计算机程序被认为可以从经验E中学习，通过经验E改进后，它在任务T上由性能度量P衡量的性能有所提升。</p>
<h3 id="任务T"><a href="#任务T" class="headerlink" title="任务T"></a>任务T</h3><p>机器学习任务定义为机器学习系统应该如何处理<strong>样本</strong>(example)。</p>
<p>样本：我们从某些希望机器学习系统处理的对象或事件中收集到的已经量化的<strong>特征</strong>（feature）的集合。通常样本表示成一个Vector $x\in \mathbb{R}^n$,其中的每个分量$x_i$是一个特征。</p>
<p>常见机器学习任务：</p>
<ul>
<li>分类：计算机程序需要指定某些输入属于k类中的哪一类。</li>
<li>输入缺失分类：当一些输入可能丢失时，学习算法必须学习一组函数，而不是单个分类函数。每个函数对应着分类具有不同缺失输入子集的$X$。这种情况在医疗诊断中经常出现。</li>
<li>回归：计算机程序需要对给定输入预测数值。输出函数$f:\mathbb{R}^n \rightarrow \mathbb{R}$</li>
<li>转录：机器学习系统观测一些相对非结构化表示的数据，并转录信息为离散的文本形式。如光学字符识别。</li>
<li>机器翻译：输入是一种语言的符号序列，计算机程序必须将其转化成另一种语言的符号序列。通常适用于自然语言。</li>
<li>结构化输出：结构化输出任务的输出是向量或者其他包含多个值的数据结构，并且构成输出的这些不同元素间具有重要关系。包括上述转录任务和翻译任务在内的很多其他任务。例如语法分析——映射自然语言句子到语法结构树，标记树的节点的词性。</li>
<li>异常检测：计算机程序在一组事件或对象中筛选，并标记不正常或非典型的个体。例如信用卡欺诈检测。</li>
<li>合成和采样：机器学习程序生成一些和训练数据近似的新样本常用与生成媒体，游戏的自然纹理。某些情况下希望采样或合成过程中可以根据输入生成一些特定类型的输出。如根据书写的句子，输出句子语音的音频波形。这是一类结构化输出任务，没有唯一正确的结构，希望结构更加自然和真实。</li>
<li>缺失值填补：给定一个新样本$x\in \mathbb{R}^n$，$X$中某些元素$x_i$缺失。算法填补这些缺失值。</li>
<li>去噪：干净样本$x\in \mathbb{R}^n$经过未知损坏过程得到的损失样本$\tilde{x} \in \mathbb{R}^n$。算法根据损失后的样本$\tilde{x}$预测干净的样本$x$，或者一般的预测条件概率分布$p(x|\tilde{x})$。</li>
<li>密度估计或概率质量函数估计：在密度估计问题中，学习算法学习函数$p_{model}:\mathbb{R}^n \rightarrow \mathbb{R}$，其中$p_{model}(x)$可以解释成样本采样空间的概率密度函数（$x$是连续的）或者概率质量函数（$x$是离散的）。</li>
</ul>
<h3 id="性能度量P"><a href="#性能度量P" class="headerlink" title="性能度量P"></a>性能度量P</h3><p>性能度量（performance measure）：衡量模型泛化能力的评估标准</p>
<p>回归任务最常用的性能度量是均方误差(mean squared error)</p>
<script type="math/tex; mode=display">
E(f;D)=\frac{1}{m}\sum_{i=1}^m(f(x_i)-y_i)^2</script><p>更一般的，对于数据分布$D$和概率密度函数$p（\cdot）$，均方误差可以描述为</p>
<script type="math/tex; mode=display">
E(f;D) = \int_{x\sim D}(f(x)-y)^2p(x)dx</script><h4 id="错误率和精度"><a href="#错误率和精度" class="headerlink" title="错误率和精度"></a>错误率和精度</h4><p>分类任务中最常用的两种性能度量。</p>
<ul>
<li>错误率：分类错误的样本数占样本总数的比例。<script type="math/tex; mode=display">
E(f;D)=\frac{1}{m}\sum_{i=1}^m\mathbb{I}(f(x_i)\neq y_i) \\
E(f;D)=\frac{1}{m}\int_{x\sim D}\mathbb{I}(f(x)\neq y)p(x)dx</script></li>
</ul>
<ul>
<li>精度：分类正确的样本数占样本总数的比例。<script type="math/tex; mode=display">
acc(f;D)=\frac{1}{m}\sum_{i=1}^m\mathbb{I}(f(x_i) = y_i)=1-E(f;D) \\
acc(f;D)=\frac{1}{m}\int_{x\sim D}\mathbb{I}(f(x) = y)p(x)dx=1-E(f;D)</script></li>
</ul>
<h4 id="查准率、查全率和-F1"><a href="#查准率、查全率和-F1" class="headerlink" title="查准率、查全率和$F1$"></a>查准率、查全率和$F1$</h4><p>对于二分类问题，可将样例根据其真实类别与机器学习预测类别的组合化为真正例(true positive)、假正例(false positive)、真反例(true negative)、假反例(false negative)四种情况，令$TP,FP,TN,FN$分别表示其对应的样例数，则有$TP+FP+TN+FN=$样例总数。分类结果可用”混淆矩阵“(confusion matrix)表示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">预测结果</th>
<th style="text-align:center">预测结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">真实情况</td>
<td style="text-align:center">正例</td>
<td style="text-align:center">反例</td>
</tr>
<tr>
<td style="text-align:center">正例</td>
<td style="text-align:center">$TP$(真正例)</td>
<td style="text-align:center">$FN$ (假反例)</td>
</tr>
<tr>
<td style="text-align:center">反例</td>
<td style="text-align:center">$FP$(假正例)</td>
<td style="text-align:center">$TN$(真反例)</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>查准率$P$<script type="math/tex; mode=display">
P = \frac{TP}{TP+FP}</script></li>
</ul>
<ul>
<li><p>查全率$R$</p>
<script type="math/tex; mode=display">
R = \frac{TP}{TP+FN}</script></li>
<li><p>$P-R$曲线：以查准率为纵轴、查全率为横轴作图。$P-R$图直观地显示出学习器在样本总体上的查全率、查准率。若一个学习器的$P-R$曲线被另一学习器的曲线完全”包住”，则后者的性能优于前者。</p>
</li>
<li><p>”平衡点“(Break-Event Point,BEP)：查准率=查全率 时的取值。BEP高的性能高。</p>
</li>
<li><p>$F1$度量</p>
<script type="math/tex; mode=display">
F1=\frac{2\times P \times R}{P+R}=\frac{2\times TP}{样例总数+TP-TN}</script><blockquote>
<p>$F1$是基于查准率和查全率的调和平均定义的$\frac{1}{F1}=\frac{1}{2}(\frac{1}{P}+\frac{1}{R})$</p>
</blockquote>
</li>
<li><p>更一般的$F_\beta$</p>
<script type="math/tex; mode=display">
F_\beta=\frac{(1+\beta^2 \times P \times R)}{(\beta^2\times P)+R}</script><blockquote>
<p> $F_\beta$是基于查准率和查全率的加权调和平均定义的$\frac{1}{F_\beta}=\frac{1}{1+\beta^2}(\frac{1}{P}+\frac{\beta^2}{R})$。与算术平均$\frac{P+R}{2}$和几何平均$\sqrt{P\times R}$相比，调和平均更重视较小值。</p>
</blockquote>
<p>​    $\beta \gt 1$查全率影响更大，$\beta \lt 1$查准率影响更大</p>
</li>
</ul>
<h4 id="ROC-和-AUC"><a href="#ROC-和-AUC" class="headerlink" title="$ROC$和$AUC$"></a>$ROC$和$AUC$</h4><h3 id="经验E"><a href="#经验E" class="headerlink" title="经验E"></a>经验E</h3><h2 id="容量、过拟合和欠拟合"><a href="#容量、过拟合和欠拟合" class="headerlink" title="容量、过拟合和欠拟合"></a>容量、过拟合和欠拟合</h2><h3 id="没有免费午餐定理"><a href="#没有免费午餐定理" class="headerlink" title="没有免费午餐定理"></a>没有免费午餐定理</h3><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><h2 id="超参集和验证集"><a href="#超参集和验证集" class="headerlink" title="超参集和验证集"></a>超参集和验证集</h2><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/01/vim基本操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongxian Gu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/19640280?s=40&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dongxian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/01/vim基本操作/" class="post-title-link" itemprop="url">vim基本操作</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-01 10:19:00 / 修改时间：10:21:16" itemprop="dateCreated datePublished" datetime="2019-12-01T10:19:00+08:00">2019-12-01</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/工具/" itemprop="url" rel="index"><span itemprop="name">工具</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="vim-基础操作"><a href="#vim-基础操作" class="headerlink" title="vim 基础操作"></a>vim 基础操作</h1><blockquote>
<p>来源于 <code>vimtutor</code></p>
</blockquote>
<h2 id="第一讲小结"><a href="#第一讲小结" class="headerlink" title="第一讲小结"></a>第一讲小结</h2><ol>
<li><p>光标在屏幕文本中的移动既可以用箭头键，也可以使用 <code>hjkl</code> 字母键。</p>
<ul>
<li>h (左移)</li>
<li>j (下行)</li>
<li>k (上行)</li>
<li>l (右移)</li>
</ul>
</li>
<li><p>欲进入 Vim 编辑器(从命令行提示符)，请输入：vim 文件名 &lt;回车&gt;</p>
</li>
<li><p>欲退出 Vim 编辑器，请输入 \<esc>   :q!   &lt;回车&gt; 放弃所有改动。<br>或者输入 \<esc>   :wq   &lt;回车&gt; 保存改动。</esc></esc></p>
</li>
<li><p>在正常模式下删除光标所在位置的字符，请按： x</p>
</li>
<li><p>欲插入或添加文本，请输入：</p>
<ul>
<li>i   输入欲插入文本   \<esc> 在光标前插入文本</esc></li>
<li>A   输入欲添加文本   \<esc>             在一行后添加文本</esc></li>
</ul>
</li>
</ol>
<p>特别提示：按下 \<esc> 键会带您回到正常模式或者撤消一个不想输入或部分完整<br>的命令。</esc></p>
<h2 id="第二讲小结"><a href="#第二讲小结" class="headerlink" title="第二讲小结"></a>第二讲小结</h2><ol>
<li>欲从当前光标删除至下一个单词，请输入：dw</li>
<li>欲从当前光标删除至当前行末尾，请输入：d$</li>
<li>欲删除整行，请输入：dd</li>
<li>欲重复一个动作，请在它前面加上一个数字：2w</li>
<li><p>在正常模式下修改命令的格式是：<br> <code>operator   [number]   motion</code><br>  其中：</p>
<ul>
<li>operator - 操作符，代表要做的事情，比如 d 代表删除</li>
<li>[number] - 可以附加的数字，代表动作重复的次数</li>
<li>motion   - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)， $ 代表行末等等。</li>
</ul>
</li>
<li><p>欲移动光标到行首，请按数字0键：0</p>
</li>
<li>欲撤消以前的操作，请输入：u (小写的u)<br>  欲撤消在一行中所做的改动，请输入：U (大写的U)<br>  欲撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R</li>
</ol>
<h2 id="第三讲小结"><a href="#第三讲小结" class="headerlink" title="第三讲小结"></a>第三讲小结</h2><ol>
<li><p>要重新置入已经删除的文本内容，请按小写字母 p 键。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置于当前光标所在行的下一行。</p>
</li>
<li><p>要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字符即可。</p>
</li>
<li><p>更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。</p>
<p> 比如输入 ce 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当前光标到行末的内容。</p>
</li>
<li><p>更改类命令的格式是：<code>c   [number]   motion</code></p>
</li>
</ol>
<h2 id="第四讲小结"><a href="#第四讲小结" class="headerlink" title="第四讲小结"></a>第四讲小结</h2><ol>
<li><p>CTRL-G 用于显示当前光标所在位置和文件状态信息。<br>  G 用于将光标跳转至文件最后一行。<br>  先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。<br>  gg 用于将光标跳转至文件第一行。</p>
</li>
<li><p>输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。<br>  输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。<br>  完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查<br>  找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。<br>  CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。</p>
</li>
<li><p>如果光标当前位置是括号(、)、[、]、{、}，按 % 会将光标移动到配对的括号上。</p>
</li>
<li><p>在一行内替换头一个字符串 old 为新的字符串 new，请输入  <code>:s/old/new</code><br> 在一行内替换所有的字符串 old 为新的字符串 new，请输入<code>:s/old/new/g</code><br> 在两行内替换所有的字符串 old 为新的字符串 new，请输入  <code>:#,#s/old/new/g</code><br> 在文件内替换所有的字符串 old 为新的字符串 new，请输入  <code>:%s/old/new/g</code><br> 进行全文替换时询问用户确认每个替换需添加 c 标志<code>:%s/old/new/gc</code></p>
</li>
</ol>
<h2 id="第五讲小结"><a href="#第五讲小结" class="headerlink" title="第五讲小结"></a>第五讲小结</h2><ol>
<li><p>:!command 用于执行一个外部命令 command。</p>
<p>  请看一些实际例子：<br> | (ms-dos)       | (unix)        |                                |<br> | ——————— | ——————- | ——————————————— |<br> | :!dir          | :!ls          | 用于显示当前目录的内容。       |<br> | :!del filename | :!rm filename | 用于删除名为 filename 的文件。 |</p>
</li>
<li><p><code>:w filename</code>  可将当前 vim 中正在编辑的文件保存到名为 filename 的文件中。</p>
</li>
<li><p><code>v motion :w filename</code> 可将当前编辑文件中可视模式下选中的内容保存到文件filename 中。</p>
</li>
<li><p><code>:r filename</code> 可提取磁盘文件 filename 并将其插入到当前文件的光标位置后面。</p>
</li>
<li><p><code>:r !dir</code> 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。</p>
</li>
</ol>
<h2 id="第六讲小结"><a href="#第六讲小结" class="headerlink" title="第六讲小结"></a>第六讲小结</h2><ol>
<li><p>输入小写的 o 可以在光标下方打开新的一行并进入插入模式。输入大写的 o 可以在光标上方打开新的一行。</p>
</li>
<li><p>输入小写的 a 可以在光标所在位置之后插入文本。输入大写的 a 可以在光标所在行的行末之后插入文本。</p>
</li>
<li><p>e 命令可以使光标移动到单词末尾。</p>
</li>
<li><p>操作符 y 复制文本，p 粘贴先前复制的文本。</p>
</li>
<li><p>输入大写的 r 将进入替换模式，直至按 \<esc> 键回到正常模式。</esc></p>
</li>
<li><p>输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下：<br> |                   |                        |<br> | ————————- | ——————————— |<br> | ‘ic’ ‘ignorecase’ | 查找时忽略字母大小写   |<br> | ‘is’ ‘incsearch’  | 查找短语时显示部分匹配 |<br> | ‘hls’ ‘hlsearch’  | 高亮显示所有的匹配短语 |</p>
<p> 选项名可以用完整版本，也可以用缩略版本。</p>
</li>
<li><p>在选项前加上 no 可以关闭选项：  <code>:set noic</code></p>
</li>
</ol>
<h2 id="第七讲小结"><a href="#第七讲小结" class="headerlink" title="第七讲小结"></a>第七讲小结</h2><ol>
<li><p>输入 <code>:help</code> 或者按 <code>&lt;f1&gt;</code> 键或 <code>&lt;help&gt;</code> 键可以打开帮助窗口。</p>
</li>
<li><p>输入入 <code>:help cmd</code> 可以找到关于 cmd 命令的帮助。</p>
</li>
<li><p>输入 <code>ctrl-w ctrl-w</code>  可以使您在窗口之间跳转。</p>
</li>
<li><p>输入 <code>:q</code> 以关闭帮助窗口</p>
</li>
<li><p>您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。</p>
</li>
<li><p>当输入 <code>:</code> 命令时，按 <code>ctrl-d</code> 可以查看可能的补全结果。按 <code>&lt;tab&gt;</code> 可以使用一个补全。</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/29/面向对象设计原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongxian Gu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/19640280?s=40&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dongxian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/29/面向对象设计原则/" class="post-title-link" itemprop="url">面向对象设计原则</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-29 18:15:54 / 修改时间：18:16:46" itemprop="dateCreated datePublished" datetime="2019-11-29T18:15:54+08:00">2019-11-29</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/软件开发/" itemprop="url" rel="index"><span itemprop="name">软件开发</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面向对象的七种设计原则"><a href="#面向对象的七种设计原则" class="headerlink" title="面向对象的七种设计原则"></a>面向对象的七种设计原则</h1><hr>
<h2 id="原则一：（SRP：Single-responsibility-principle）单一职责原则又称单一功能原则"><a href="#原则一：（SRP：Single-responsibility-principle）单一职责原则又称单一功能原则" class="headerlink" title="原则一：（SRP：Single responsibility principle）单一职责原则又称单一功能原则"></a>原则一：（SRP：Single responsibility principle）单一职责原则又称单一功能原则</h2><p><strong>核心</strong>：解耦和增强内聚性（高内聚，低耦合）</p>
<p><strong>描述</strong>：类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题。</p>
<h2 id="原则二：开闭原则（OCP：Open-Closed-Principle）"><a href="#原则二：开闭原则（OCP：Open-Closed-Principle）" class="headerlink" title="原则二：开闭原则（OCP：Open Closed Principle）"></a>原则二：开闭原则（OCP：Open Closed Principle）</h2><p><strong>核心思想</strong>：对扩展开放，对修改关闭。即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。</p>
<p><strong>扩展开放</strong>：某模块的功能是可扩展的，则该模块是扩展开放的。软件系统的功能上的可扩展性要求模块是扩展开放的。</p>
<p><strong>修改关闭</strong>：某模块被其他模块调用，如果该模块的源代码不允许修改，则该模块修改关闭的。软件系统的功能上的稳定性，持续性要求是修改关的。</p>
<h2 id="原则三：里氏替换原则（LSP：Liskov-Substitution-Principle）"><a href="#原则三：里氏替换原则（LSP：Liskov-Substitution-Principle）" class="headerlink" title="原则三：里氏替换原则（LSP：Liskov Substitution Principle）"></a>原则三：里氏替换原则（LSP：Liskov Substitution Principle）</h2><p><strong>核心</strong>：</p>
<ol>
<li><p>在任何父类出现的地方都可以用他的子类来替代（子类应当可以替换父类并出现在父类能够出现的任何地方）子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。</p>
</li>
<li><p>子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性</p>
</li>
<li><p>覆盖或实现父类的方法时输入参数可以被放大。即子类可以重载父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。</p>
</li>
<li><p>覆盖或实现父类的方法时输出结果可以被缩小。</p>
</li>
</ol>
<h2 id="原则四：依赖倒转原则-DIP：Dependence-Inversion-Principle"><a href="#原则四：依赖倒转原则-DIP：Dependence-Inversion-Principle" class="headerlink" title="原则四：依赖倒转原则(DIP：Dependence Inversion Principle)"></a>原则四：依赖倒转原则(DIP：Dependence Inversion Principle)</h2><p><strong>别名</strong>：依赖倒置原则或依赖反转原则</p>
<p><strong>核心</strong>：要依赖于抽象，不要依赖于具体的实现</p>
<ol>
<li><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）</p>
</li>
<li><p>抽象不应该依赖细节（具体实现）</p>
</li>
<li><p>细节（具体实现）应该依赖抽象。</p>
</li>
</ol>
<p><strong>三种实现方式</strong>:</p>
<ol>
<li><p>通过构造函数传递依赖对象</p>
</li>
<li><p>通过setter方法传递依赖对象</p>
</li>
<li><p>接口声明实现依赖对象</p>
</li>
</ol>
<h2 id="原则五：接口分离原则-ISP：Interface-Segregation-Principle"><a href="#原则五：接口分离原则-ISP：Interface-Segregation-Principle" class="headerlink" title="原则五：接口分离原则(ISP：Interface Segregation Principle)"></a>原则五：接口分离原则(ISP：Interface Segregation Principle)</h2><p><strong>核心思想</strong>：不应该强迫客户程序依赖他们不需要使用的方法。</p>
<p><strong>接口分离原则的意思就是</strong>：一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口当中.</p>
<p><strong>分离接口的两种实现方法</strong>：</p>
<ol>
<li><p>使用委托分离接口。（Separation through Delegation）</p>
</li>
<li><p>使用多重继承分离接口。（Separation through Multiple Inheritance）</p>
</li>
</ol>
<h2 id="原则六：合成复用原则（CRP：Composite-Reuse-Principle）"><a href="#原则六：合成复用原则（CRP：Composite-Reuse-Principle）" class="headerlink" title="原则六：合成复用原则（CRP：Composite Reuse Principle）"></a>原则六：合成复用原则（CRP：Composite Reuse Principle）</h2><p><strong>核心思想</strong>：尽量使用对象组合，而不是继承来达到复用的目的。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。</p>
<p><strong>复用的种类</strong>：</p>
<ol>
<li><p>继承</p>
</li>
<li><p>合成聚合</p>
</li>
</ol>
<p><em>注：在复用时应优先考虑使用合成聚合而不是继承</em></p>
<h2 id="原则七：迪米特原则（LOD：Law-of-Demeter）"><a href="#原则七：迪米特原则（LOD：Law-of-Demeter）" class="headerlink" title="原则七：迪米特原则（LOD：Law of Demeter）"></a>原则七：迪米特原则（LOD：Law of Demeter）</h2><p>又叫最少知识原则</p>
<p><strong>核心思想</strong>：一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。（类间解耦，低耦合）意思就是降低各个对象之间的耦合，提高系统的可维护性；在模块之间只通过接口来通信，而不理会模块的内部工作原理，可以使各个模块的耦合成都降到最低，促进软件的复用</p>
<p><em>注</em>：</p>
<ol>
<li><p>在类的划分上，应该创建有弱耦合的类；</p>
</li>
<li><p>在类的结构设计上，每一个类都应当尽量降低成员的访问权限；</p>
</li>
<li><p>在类的设计上，只要有可能，一个类应当设计成不变；</p>
</li>
<li><p>在对其他类的引用上，一个对象对其它对象的引用应当降到最低；</p>
</li>
<li><p>尽量降低类的访问权限；</p>
</li>
<li><p>谨慎使用序列化功能；</p>
</li>
<li><p>不要暴露类成员，而应该提供相应的访问器(属性)</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/29/Keras初体验/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongxian Gu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/19640280?s=40&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dongxian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/29/Keras初体验/" class="post-title-link" itemprop="url">Keras初体验</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-29 16:37:48 / 修改时间：16:46:51" itemprop="dateCreated datePublished" datetime="2019-11-29T16:37:48+08:00">2019-11-29</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Keras-初体验"><a href="#Keras-初体验" class="headerlink" title="Keras 初体验"></a>Keras 初体验</h1><h2 id="使用内置struct加载mnist手写字符数据集"><a href="#使用内置struct加载mnist手写字符数据集" class="headerlink" title="使用内置struct加载mnist手写字符数据集"></a>使用内置<code>struct</code>加载<code>mnist</code>手写字符数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># load mnist dataset</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadImageSet</span><span class="params">(filename)</span>:</span></span><br><span class="line">    imgfile = open(filename, <span class="string">'rb'</span>)</span><br><span class="line">    buffers = imgfile.read()</span><br><span class="line"></span><br><span class="line">    head = struct.unpack_from(<span class="string">'&gt;IIII'</span>, buffers, <span class="number">0</span>)<span class="comment"># 读取前四个int，解析返回列表</span></span><br><span class="line">    offset = struct.calcsize(<span class="string">'&gt;IIII'</span>) <span class="comment"># 计算前四个int大小</span></span><br><span class="line"></span><br><span class="line">    imgNum = head[<span class="number">1</span>]</span><br><span class="line">    width = head[<span class="number">2</span>]</span><br><span class="line">    height = head[<span class="number">3</span>]</span><br><span class="line">    bits = imgNum*width*height</span><br><span class="line">    bitstr = <span class="string">'&gt;'</span>+str(bits)+<span class="string">'B'</span></span><br><span class="line">    print(bitstr)</span><br><span class="line">    data = struct.unpack_from(bitstr, buffers, offset)</span><br><span class="line">    data = np.reshape(data, (imgNum, width*height))</span><br><span class="line">    imgfile.close()</span><br><span class="line">    <span class="keyword">return</span> data, head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadLabel</span><span class="params">(filename)</span>:</span></span><br><span class="line">    imgfile = open(filename, <span class="string">'rb'</span>)</span><br><span class="line">    buffers = imgfile.read()</span><br><span class="line"></span><br><span class="line">    head = struct.unpack_from(<span class="string">'&gt;II'</span>, buffers, <span class="number">0</span>)</span><br><span class="line">    offset = struct.calcsize(<span class="string">'&gt;II'</span>)</span><br><span class="line"></span><br><span class="line">    imgNum = head[<span class="number">1</span>]</span><br><span class="line">    bits = imgNum</span><br><span class="line">    bitstr = <span class="string">'&gt;'</span>+str(bits)+<span class="string">'B'</span></span><br><span class="line">    print(bitstr)</span><br><span class="line">    data = struct.unpack_from(bitstr, buffers, offset)</span><br><span class="line">    data = np.reshape(data, (imgNum, <span class="number">1</span>))</span><br><span class="line">    imgfile.close()</span><br><span class="line">    <span class="keyword">return</span> data, head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_data, train_head = loadImageSet(<span class="string">'./mnist/train-images.idx3-ubyte'</span>)</span><br><span class="line">label_data, label_head = loadLabel(<span class="string">'./mnist/train-labels-idx1-ubyte'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Train\n"</span>)</span><br><span class="line">print(<span class="string">f'Head information:<span class="subst">&#123;train_head&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'Shape:<span class="subst">&#123;train_data.shape&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Label\n"</span>)</span><br><span class="line">print(<span class="string">f'Head information:<span class="subst">&#123;label_head&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'Shape:<span class="subst">&#123;label_data.shape&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="构建模型并训练"><a href="#构建模型并训练" class="headerlink" title="构建模型并训练"></a>构建模型并训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_hot</span><span class="params">(data,n)</span>:</span></span><br><span class="line">    num = data.shape[<span class="number">0</span>]</span><br><span class="line">    res = np.zeros((num,n))</span><br><span class="line">    <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(data):</span><br><span class="line">        res[i,v]= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">label_data = one_hot(label_data,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line"></span><br><span class="line">model.add(Dense(input_dim=<span class="number">28</span>*<span class="number">28</span>, units=<span class="number">500</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">500</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">              optimizer=<span class="string">'adam'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line">model.fit(train_data, label_y, batch_size=<span class="number">100</span>, epochs=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h2 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test_data = loadImageSet(<span class="string">'./mnist/t10k-images-idx3-ubyte'</span>)[<span class="number">0</span>]</span><br><span class="line">test_label = one_hot(loadLabel(<span class="string">'./mnist/t10k-labels-idx1-ubyte'</span>)[<span class="number">0</span>],<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">score = model.evaluate(test_data,test_label)</span><br><span class="line">print(<span class="string">'Total loss on Testing Set:'</span>,score[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">'Accuracy of  Testing Set:'</span>,score[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/28/常见数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongxian Gu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/19640280?s=40&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dongxian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/28/常见数据结构/" class="post-title-link" itemprop="url">常见数据结构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-28 11:08:03 / 修改时间：11:31:58" itemprop="dateCreated datePublished" datetime="2019-11-28T11:08:03+08:00">2019-11-28</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构和算法/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常见的数据结构和算法"><a href="#常见的数据结构和算法" class="headerlink" title="常见的数据结构和算法"></a>常见的数据结构和算法</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><strong>线性表</strong>$Linear List$是由$n(n \geq 0)$个具有相同类型的数据元素$a_1,a_2,\dots,a_n$组成的有限序列。其中元素的个数$n$定义为表的长度。</p>
<p>非空线性表的逻辑特征：</p>
<ul>
<li>有且仅有一个开始结点$a_1$，该结点没有前趋，仅有一个后继$a_2$。</li>
<li>有且仅有一个终点结点$a_n$，该结点没有后继，仅有一个前趋$a_{n-1}$</li>
<li>其余内部内部结点$a_i \; (2 \leq i \leq n-1)\;$都有且仅有一个前趋$a_{i-1}$和一个后继$a_{i+1}$。</li>
</ul>
<p>线性表中的数据元素不限定形式，但同一线性表中的数据元素必须具有相同特性，相邻元素之间存在着序偶。</p>
<h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><p>线性表的两种存储表示方法：</p>
<ul>
<li>顺序存储表示</li>
<li>链式存储表示</li>
</ul>
<p>顺序表：线性表的顺序存储指的是把线性表的数据元素按逻辑顺序依次存放一组地址连续的存储单元里。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LISTINCREMENT = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqList_d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    SqList_d(<span class="keyword">int</span> n);</span><br><span class="line">    ~SqList_d();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SqListInsert</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">SqListDelete</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAllData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SqList_d::SqList_d(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    elem = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    maxSize = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqList_d::~SqList_d()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] elem;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    maxSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SqList_d::SqListInsert(<span class="keyword">int</span> i, <span class="keyword">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= maxSize)</span><br><span class="line">    &#123;</span><br><span class="line">        elem = (<span class="keyword">int</span> *)<span class="built_in">realloc</span>(elem, (maxSize + LISTINCREMENT) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入位置异常"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = length; j &gt;= i; j--)</span><br><span class="line">        elem[j] = elem[j - <span class="number">1</span>];</span><br><span class="line">    elem[i - <span class="number">1</span>] = e;</span><br><span class="line">    length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SqList_d::SqListDelete(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"溢出"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"删除位置异常"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e = elem[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        elem[j - <span class="number">1</span>] = elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    length--;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SqList_d::printAllData()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Item: "</span> &lt;&lt; i &lt;&lt; <span class="string">" value: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;elem[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    SqList_d la = SqList_d(<span class="number">10</span>);</span><br><span class="line">    la.SqListInsert(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    la.printAllData();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设顺序吧每个数据元素占有$m$个存储单元，且数据元素的存储位置定义为其所占的存储空间中第一个单元的存储地址，则表中相邻的数据元素$a_i$和$a_{i+1}$的存储位置$LOC(a_i)$和$LOC(a_{i+1})$也是相邻的，且满足如下关系：</p>
<script type="math/tex; mode=display">LOC(a_{i+1}) = LOC(a_i) + m</script><p>如果知道第一个元素$a_i$的存储位置则：</p>
<script type="math/tex; mode=display">LOC(a_{i}) = LOC(a_1) + (i-1)*m</script><p>由于计算任意数据元素存储地址的时间都是相等的，因此顺序表是一种 <strong>随机存取</strong>$(Random\;Access)$结构</p>
<p>顺序表的优点：</p>
<ul>
<li>节省存储空间</li>
<li>随机存取(直接存取)</li>
</ul>
<p>顺序表的缺点：</p>
<ul>
<li>插入和删除需要移动大量元素</li>
<li>表容量</li>
</ul>
<h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h3><p>链式存储结构：用一组地址任意的存储单元来依次存放线性表中的数据元素。</p>
<p>链式存储结构中的每个数据节点需要保存以下两部分信息：</p>
<ul>
<li>存储数据元素自身信息的部分。称为数据域；</li>
<li>存储与前驱和后继结点的逻辑关系。称为指针域。</li>
</ul>
<ol>
<li><p>单链表</p>
<p>单链表：如果结点只包含一个指针域。则称为单链表$Single\;Linked\;List$。</p>
<p>结构为：$\boxed{data|next}$</p>
<p>$data$为数据域，用来存放数据元素自身的信息；$next$为指针域也成链域，用来存放后继结点的地址。</p>
<p>表中的第一个结点$a_1$无前驱，故设置一个头指针$(Head\;Pointer)head$指向$a_1$,此外最后一个结点无后继，故$a_n$的指针域为空。</p>
<script type="math/tex; mode=display">head\;\to\;\boxed{a_1|\quad}\;\to\;\boxed{a_2|\quad}\;\to\;\boxed{a_3|\quad}\;\to\dots\;\to\;\boxed{a_n|\land}</script><p>链式映像或非顺序映像：逻辑上相邻的两个数据元素其存储的物理位置不一定相邻。</p>
<p>单链表是 <strong>非随机存取</strong> 的存储结构。(顺序存取)</p>
<p>单链表基本操作的实现：</p>
<ul>
<li>创建链表<ul>
<li>头插入法</li>
<li>尾插入法</li>
</ul>
</li>
<li>查找操作<ul>
<li>按位序查找</li>
<li>按值查找</li>
</ul>
</li>
<li>插入操作</li>
<li>删除操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Node *Head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        LinkList();</span><br><span class="line">        ~LinkList();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">CreateList1</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">CreateList2</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ListInsert</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> LinkList::CreateList1(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//头插法创建线性表：不停的从头部插入</span></span><br><span class="line">    Node *p,*s;</span><br><span class="line">    p = Head;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请依次输入"</span> &lt;&lt; n &lt;&lt; <span class="string">"个数据元素值："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = <span class="keyword">new</span> Node;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s-&gt;data;</span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态链表</p>
<p>静态链表：指用一维数组表示的单链表。</p>
</li>
<li><p>循环链表</p>
<p>循环链表：一种头尾相连的链表</p>
</li>
<li><p>双向链表</p>
<p>双向链表的结点结构：</p>
<script type="math/tex; mode=display">\boxed{piror|data|next}</script></li>
</ol>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><blockquote>
<p>栈和队列属于特殊的线性表 ，它们在逻辑结构上和线性表相似。栈和队列在操作比一般线性表多一些限制，栈只能在表的一端进行操作，而队列只能在一端进行插入，一端进行删除。</p>
</blockquote>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>栈</strong>：$Stack$，是限定仅在表尾进行插入或删除操作的线性表。</p>
<ul>
<li>栈顶：允许插入和删除的一端。</li>
<li>栈底：另一端。</li>
<li>空栈：当栈中没有任何元素。</li>
<li>进栈(入栈)：将一个元素从栈顶插入到栈的操作。</li>
<li>出栈(弹出):从栈顶删除一个元素的操作。</li>
</ul>
<p>特点：<strong>先进先出</strong>$FIFO$和<strong>后进先出</strong>$LIFO$</p>
<p>栈的抽象数据类型:</p>
<ul>
<li>数据对象：$D=\{a_i | a_i \in  ElemSet,i=1,2,\cdots,n,n \ge 0\}$</li>
<li>数据关系：$R=\{<a_{i-1},a_i>,a_i&gt;|a_{i-1},a_i \in D,i=1,2,\cdots,n\}$</a_{i-1},a_i></li>
</ul>
<p>约定$a_n$端为栈顶，$a_1$端为栈底。</p>
<ul>
<li>基本操作：<ul>
<li>$InitStack(\&amp;S)$</li>
<li>$DestroyStack(\&amp;S)$</li>
<li>$CleanStack(\&amp;S)$</li>
<li>$StackEmpty(S)$</li>
<li>$StackLength(S)$</li>
<li>$GetTop(S,\&amp;e)$</li>
<li>$Push(\&amp;S,e)$</li>
<li>$PopStack(\&amp;S,\&amp;e)$</li>
<li>$StackTraverse(S,visit())$</li>
</ul>
</li>
</ul>
<h4 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h4><p>顺序栈：采用顺序存储结构的栈。</p>
<p>顺序栈：利用一组地址连续的存储单元一次存放自栈底到栈顶的数据元素，同时附设$top$指针指示栈顶元素在顺序栈的位置。通常$top=0$表示空栈。</p>
<p>顺序栈的类定义和基本操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *base; <span class="comment">//栈底指针</span></span><br><span class="line">    <span class="keyword">int</span> top;   <span class="comment">//栈顶</span></span><br><span class="line">    <span class="keyword">int</span> stackSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    SqStack(<span class="keyword">int</span> m);</span><br><span class="line">    ~SqStack()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] base;</span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">        stackSize = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StackTranverse</span><span class="params">()</span></span>; <span class="comment">//显示栈中元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SqStack::Push(<span class="keyword">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == stackSize - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈满，无法入栈"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    top++;</span><br><span class="line">    base[top] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SqStack::Pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">if</span> (top = <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈空，无法出栈"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = base[top--];</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SqStack::GetTop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SqStack::StackTranverse()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"空栈"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"index: "</span> &lt;&lt; i &lt;&lt; <span class="string">" value: "</span> &lt;&lt; base[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序栈的应用：</p>
<ul>
<li>数制转换</li>
<li>括号匹配的检验</li>
<li>行编辑程序问题</li>
<li>迷宫求解</li>
</ul>
<h4 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h4><p>链栈的结点结构和单链表的结点结构相同。链表只能在栈顶执行插入和删除操作，因此以单链表的头部作为栈顶最方便，而且也没必要为单链表附加头结点链表的头指针即为栈顶指针。</p>
<p>链栈的类定义和基本操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Node *top;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    LinkStack() &#123; top == <span class="literal">NULL</span>; &#125;;</span><br><span class="line">    ~LinkStack();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> top != <span class="literal">NULL</span> ? <span class="number">1</span> : <span class="number">0</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LinkStack::~LinkStack()</span><br><span class="line">&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">while</span> (top)</span><br><span class="line">    &#123;</span><br><span class="line">        p = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> top;</span><br><span class="line">        top = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LinkStack::Push(<span class="keyword">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    Node *s = <span class="keyword">new</span> Node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = top;</span><br><span class="line">    top = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> LinkStack::Pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈溢出"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = top-&gt;data;</span><br><span class="line">    Node *p = top;</span><br><span class="line">    top = top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是线性表的特例。它将元素排列成队，有入口和出口，数据元素只能从队尾入队，从队头离队。队列具有<strong>先进先出 FIFO</strong>或<strong>后进后出LILO</strong></p>
<p><strong>队列</strong>：$Queue$是另一种限定存取位置的线性表。只允许在表的一端进入，在另一端删除，其中允许插入的一端称为<strong>队尾（Rear）</strong>，允许删除的一端称为<strong>队头（Front）</strong></p>
<ul>
<li>入队：从队尾插入元素</li>
<li>出队：从队头删除元素</li>
</ul>
<p>队列的抽象数据类型：</p>
<ul>
<li>数据对象：$D=\{a_i | a_i \in ElemSet,i=1,2,\cdots,n,n \ge 0\}$</li>
<li>数据关系：$R=\{<a_{i-1},a_i> | a_{i_1},a_i \in D,i=2,\cdots,n\}$</a_{i-1},a_i></li>
</ul>
<p>确定 $a_1$端为队头，$a_n$端为队尾。</p>
<ul>
<li>基本操作：<ul>
<li>$InitQueue(\&amp;Q)$</li>
<li>$DestroyQueue(\&amp;Q)$</li>
<li>$CleanQueue(\&amp;Q)$</li>
<li>$QueueEmpty(Q)$</li>
<li>$QueueLength(Q)$</li>
<li>$GetHead(Q,\&amp;e)$</li>
<li>$EnQueue(\&amp;Q,e)$</li>
<li>$DeQueue(\&amp;Q,\&amp;e)$</li>
<li>$QueueTraverse(Q,visit())$</li>
</ul>
</li>
</ul>
<h4 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h4><p>顺序队列：队列的顺序存储结构。</p>
<p>用一组地址连续的存储单元依次存放从队头到队尾的元素，由于队列的队头和队尾的位置是变化的，因而还需要两个指针front和rear作为队头指针和队尾指针来分别指示队头和队尾在队列中的位置。</p>
<p>当rear大于等于容量时，新元素无法入队，但事实上队列的低端还有空闲的存储单元，这种现象称为“假溢”。</p>
<p>为了解决这种现象引入了循环队列。</p>
<p>解决“假溢”现象的方法：将存储队列的数组看成是头尾相接的圆环，并成为循环存储空间，即允许队列直接从数组中下标最大的位置延续到下标最小的位置。</p>
<p>循环队列$(Circular\;Queue)$：队列的头尾相接的顺序存储结构</p>
<p>这种队列，队空和队满时头尾指针均相等，故无法通过$front==rear$来判断队列“空”还是“满”。</p>
<p>解决这个问题的办法：</p>
<ul>
<li>设置一个布尔变量以区别队列的空和满</li>
<li>少用一个元素空间：约定入队前，测试尾指针在循环意义下加1后是否等于头指针，若相等则认为队满，但实际还有一个空位置</li>
<li>使用一个计数器记录队列中元素的总数，即队列长度。</li>
</ul>
<p>以方法2讨论：</p>
<p>循环队列的长度$(rear-front+QueunSize) \% QueueSize$</p>
<p>循环队列的类定义和基本操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *base; <span class="comment">//存储空间基址</span></span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">int</span> queueSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    CQueue(<span class="keyword">int</span> m);</span><br><span class="line">    ~CQueue();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetHead</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">QueueDisplay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CQueue::CQueue(<span class="keyword">int</span> m)</span><br><span class="line">&#123;</span><br><span class="line">    queueSize = m;</span><br><span class="line">    base = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(queueSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    front = <span class="number">0</span>;</span><br><span class="line">    rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CQueue::~CQueue()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] base;</span><br><span class="line">    front = <span class="number">0</span>;</span><br><span class="line">    rear = <span class="number">0</span>;</span><br><span class="line">    queueSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CQueue::EnQueue(<span class="keyword">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((rear + <span class="number">1</span>) % (queueSize) == front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"上溢，无法入队"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    base[rear] = e;</span><br><span class="line">    rear = (rear + <span class="number">1</span>) % queueSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CQueue::DeQueue()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"下溢，不能出队"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = base[front];</span><br><span class="line">    front = (front + <span class="number">1</span>) % queueSize;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CQueue::GetHead()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"队空，无元素"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = base[front];</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CQueue::GetLast()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"队空，无元素"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = base[rear];</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CQueue::QueueDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"队空，无元素"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = front % queueSize; i &lt; rear; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; queueSize) &#123;</span><br><span class="line">            index = i % queueSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"index: "</span> &lt;&lt; index &lt;&lt; <span class="string">" value: "</span> &lt;&lt; base[index] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; (rear) % queueSize; i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; "index: " &lt;&lt; i &lt;&lt; " value: " &lt;&lt; base[i] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CQueue cq = CQueue(<span class="number">6</span>);</span><br><span class="line">    cq.EnQueue(<span class="number">1</span>);</span><br><span class="line">    cq.EnQueue(<span class="number">2</span>);</span><br><span class="line">    cq.EnQueue(<span class="number">3</span>);</span><br><span class="line">    cq.EnQueue(<span class="number">4</span>);</span><br><span class="line">    cq.EnQueue(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"入队后："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    cq.QueueDisplay();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"第一个元素出队后："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    cq.DeQueue();</span><br><span class="line">    cq.QueueDisplay();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h4><p>队列的链式存储结构称为<strong>链队列$(Linked\;Queue)$</strong></p>
<p>根据队列先进先出的特性，链队列是仅在表头删除元素和表尾插入元素的单链表。</p>
<p>链队列的类定义和基本操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Node *front;</span><br><span class="line">    Node *rear;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    LinkQueue();</span><br><span class="line">    ~LinkQueue();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetHead</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">QueueDisplay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LinkQueue::LinkQueue()</span><br><span class="line">&#123;</span><br><span class="line">    front = <span class="keyword">new</span> Node;</span><br><span class="line">    front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    rear = front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkQueue::~LinkQueue()</span><br><span class="line">&#123;</span><br><span class="line">    Node *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (front != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LinkQueue::EnQueue(<span class="keyword">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">"进入队列！！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Node *s = <span class="keyword">new</span> Node;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = rear-&gt;next;</span><br><span class="line">    rear-&gt;next = s;</span><br><span class="line">    rear = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (front-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        front-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> LinkQueue::DeQueue()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    Node *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rear == front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"下溢"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = front-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rear = front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> LinkQueue::GetHead()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"下溢"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = front-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"当前队列为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> LinkQueue::GetLast()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"下溢"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = rear-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LinkQueue::QueueDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"队列为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((p != rear));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkQueue lq = LinkQueue();</span><br><span class="line">    lq.EnQueue(<span class="number">1</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">2</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">3</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">4</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">5</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">7</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> e = lq.DeQueue();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    e = lq.DeQueue();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    e = lq.GetHead();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    e = lq.GetLast();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    lq.QueueDisplay();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组和广义表"><a href="#数组和广义表" class="headerlink" title="数组和广义表"></a>数组和广义表</h2><p>数组和广义表可以看做是线性表的扩展，即数组和广义表中的数据元素本身也是一种数据结构。数组中每个数据元素具有相同的结构，广义表中的数据元素可以有不同的数据结构。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组$(Array)$是由相同类型的一组数据元素组成的一个有限序列。其数据元素也称为数组元素。数组中的每个元素都有一个序号，称为<strong>下标$(index)$</strong>。可以通过下标访问数据元素。</p>
<p>数组元素受$n(n\ge1)$个线性关系的约束，每个数据元素在$n$<br>个线性关系中的符号$i_1,i_2,\cdots,i_n$成为数据元素的下标，并称该数组为$n$维数组。</p>
<p>当$n=2$是，为二维数组，任何一个数据元素有两个下标，一个为行号，一个为列号。如$a_{ij}$表示第$i$行第$j$列的数据元素</p>
<p>一维数组可以看作是一个线性表，二维数组可以看作数据元素是一维数组的线性表。</p>
<p>数组中的每个数据元素都和一组唯一的下标值对应。因此数组是一种随机存取机构。</p>
<p>数据的抽象数据类型</p>
<ul>
<li><p>数据对象：$j_i=0,\cdots,b_i-1,i=1,2,\cdots,n$</p>
<script type="math/tex; mode=display">D=\{a_{j_1j_2\cdots j_n}|n(n>0),b_i,j_i,a_{j_1j_2\cdots j_n}\in ElemSet\}</script><p>$n$是数据的维数，$b_i$是数据的第$i$维的长度，$j_i$是数组元素第$i$维的下标。</p>
</li>
<li><p>数据关系：$R=\{R_1,R_2,\cdots,R_n\}$</p>
</li>
</ul>
<script type="math/tex; mode=display">R_i=\{<a_{j1\cdots ji \cdots jn},a_{j1\cdots ji+1\cdots jn}>\}
    \\ 0\le j_k\le b_k-1,1\le k\le n\;n\neq i,
    \\ 0\le j_i \le b_i-2,
    - InitArray(\&A,n,bound1,...,boundn)
    \\a_{j1\cdots ji \cdots jn},a_{j1\cdots ji+1\cdots jn}\in D,i=2,\cdots,n</script><ul>
<li>基本操作<ul>
<li>$InitArray(\&amp;A,n,bound1,…,boundn)$<ul>
<li>初始条件：无</li>
<li>操作结果：若维数$n$和各维长度$b_1,…,b_n$合法，则构造相应的数组$A$，并返回$OK$</li>
</ul>
</li>
<li>$DestroyArray(\&amp;A)$<ul>
<li>初始条件：无</li>
<li>操作结果：销毁数组$A$</li>
</ul>
</li>
<li>$GetValue(A,\&amp;e,index1,…,indexn)$<ul>
<li>初始条件：$A$是$n$维数组，$e$为数据元素变量，$index1,\cdots,indexn$是$n$个下标值。</li>
<li>操作结果：若下标$index1,\cdots,indexn$都不超界，则读取与下标对应的数据元素的值，并赋值给$e$</li>
</ul>
</li>
<li>$Assign(\&amp;A,e,index1,…,indexn)$<ul>
<li>初始条件：$A$是$n$维数组，$e$为数据元素变量，$index1,\cdots,indexn$是$n$个下标值。</li>
<li>操作结果：若下标$index1,\cdots,indexn$都不超界，则将$e$赋值给下标对应的数据元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数组的存储结构"><a href="#数组的存储结构" class="headerlink" title="数组的存储结构"></a>数组的存储结构</h4><p>由于计算机内存结构是一维的，因此用一维内存来表示多维数组，必须按某种次序将数据元素排成一个序列，然后将这个序列放在存储空间中。</p>
<p>由于一般不对数组进行插入和删除操作，一般采用顺序存储的方法来表示数组。</p>
<p>用一组连续的存储单元存放数据元素存在一个次序约定的问题，是先存一行数据元素还是先存一列数据元素？</p>
<p>根据<strong>存储方式</strong>的不同，顺序存储方法分为一下两类：</p>
<ul>
<li><p>行优先顺序存储</p>
<p>以行序为主序的存储方式。将数据元素按行排列，第$i+1$个行向量紧接在第$i$个行向量后面。</p>
</li>
<li><p>列优先顺序存储</p>
<p>以列序为主序的存储方式。将数据元素按列排列，第$j+1$个列向量紧接在第$j$个列向量后面。</p>
</li>
</ul>
<p>行优先顺序存储：$\boxed{a_{11}|a_{12}|\cdots|a_{1n}|a_{21}|a_{22}|\cdots|a_{2n}|\cdots|a_{m1}|a_{m2}|\cdots|a_{mn}}$<br>列优先顺序存储：$\boxed{a_{11}|a_{21}|\cdots|a_{m1}|a_{12}|a_{22}|\cdots|a_{m2}|\cdots|a_{1n}|a_{2n}|\cdots|a_{mn}}$</p>
<p>二维数组元素地址，按行优先顺序存储的计算公式</p>
<p>任一数据元素$a_{ij}$的存储地址$LOC(a_{ij})$应为数组的基地址加上排在$a_{ij}$前面的数据元素所占用的单元数，因此$a_{ij}$的存储地址计算公式为：</p>
<script type="math/tex; mode=display">LOC(a_{ij})=LOC(a_{l_1l_2})+((i-l_1)*(h_2-l_2+1)+(j-l_2))*c\\=LOC(a_{l_1l_2})+i*(h_2-l_2+1)*c-l_1*(h_2-l_2+1)*c+j*c-l_2*c</script><p>令：$M_1=(h_2-l_2+1)*c,M_2=c,$则有</p>
<script type="math/tex; mode=display">LOC(a_{ij})=v_0+i*M_1+j*M_2</script><p>其中，$v_0=LOC(a_{l_1l_2})+-l_1<em>M_1-l_2</em>M_2,i\in[l_1,h_1],j\in[l_2,h_2],$且$i$和$j$均为整数；$LOC(a_l{ij})$是数据元素$a_{ij}$的存储地址，$LOC(a_{l_1l_2})$是二维数组中第一个元素的存储地址，即基地址。</p>
<p>二维数组推广到一般，按照行优先顺序存储，则下标为$i_1,i_2,\cdots,i_n$的存储地址为：</p>
<script type="math/tex; mode=display">LOC(a_{i_1,i_2,\cdots,i_n})
=LOC(a_{l_1,l_2,\cdots,l_n})+(j_1d_2d_3\cdots d_n+j_2d_3\cdots d_n+\cdots+j_{n-1}d_n+j_n)*c\\=V_0+i_1*M_1+i_2*M_2+\cdots+i_n*M_n</script><h4 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h4><p>在矩阵中，若非零元素呈现某种规律分布或举证中出现大量零数据元素。为了节省空间，可以对这类矩阵进行压缩。</p>
<p>压缩存储的原则：</p>
<ul>
<li>为多个值相同的非零数据元素分配一个存储空间</li>
<li>不为零数据元素分配存储空间</li>
</ul>
<p>特殊矩阵$(Special\;Matrix)$：值相同的数据元素或者零数据元素在矩阵中的分布有一定的规律。</p>
<p>稀疏矩阵$(Sparse\;Maxtrix)$：矩阵中有许多零数据元素(一般根据稀疏因子的值判定领数据元素是否较多)</p>
<ol>
<li><p>特殊矩阵的压缩存储<br>特殊矩阵是指非零数据元素或零<strong>数据元素的分布</strong>具有一定<strong>规律</strong>的矩阵。</p>
<p>常见的特殊矩阵有:对称矩阵、对角矩阵等，它们都是方阵，行数和列数相同。</p>
<ol>
<li><p>对称对称的压缩<br>在一个$n$阶方阵$A$中，若数据元素满足下述性质:</p>
<script type="math/tex; mode=display">a_{ij}=a_{ji}(i\ge1,j\le n)</script><p>则称为$A$为$n$阶对称矩阵。</p>
<p>对称矩阵只需存储矩阵中的上三角$a_{ij}(i\le j)$或下三角$a_{ij}(i\ge j)$的数据元素。</p>
<p>对称矩阵优先采用行优先顺序存储下三角中的数据元素。</p>
<p>下三角的数据元素可用一个容量是$n<em>(n+1)/2$的一维数组存储。对于下三角中任意数据元素$a_{ij}(i\ge j)$,$a_{ij}$在一维数组中的下标$k$与$i、j$的关系为：$k=i</em>(i+1)/2+j$。</p>
<script type="math/tex; mode=display">\boxed{a_{00}|a_{10}|a_{11}|a_{20}|a_{21}|a_{22}|\cdots|a_{ij}|\cdots|a_{n-1,0}|a_{n-1,1}|\cdots|a_{n-1,n-1}}</script><p>若采用上述的压缩存储方式，则矩阵中的任一数据元素$a_{ij}$与它在一维数组中的存储位置$k$之间存在如下的对应关系:</p>
<script type="math/tex; mode=display">k=\begin{cases}i(i-1)/2+j-1,\ge j
\\j(j-1)/2+i-1,\lt j\end{cases}</script><p>其中$k=0,1,2，\cdots,((n+1)n/2)-1,<br>\\1+2+3+(i-1)=(i-1)i/2,<br>\(i-1)i/2+j=k+1\quad i\ge j\quad and\quad i,j\ge 1$</p>
</li>
<li><p>对角矩阵的压缩存储</p>
<p>对角矩阵：所有的非零数据元素都集中在以主对角线为中心的带状区域中的举证，即除了<strong>主对角线上和主对角线相邻两侧</strong>的若干条对角线上的数据之外，其余所有数据元素均为零数据元素。</p>
</li>
</ol>
</li>
<li><p>稀疏矩阵的压缩存储</p>
<p><strong>稀疏矩阵$(Sparse\;Matrix)$</strong>:矩阵$A$中有$s$个非零数据元素，若$s$远远小于矩阵数据元素的总数即$(s\ll m*n)$。</p>
<p>稀疏因子：假设$m\ast n$阶矩阵中有$s$个非零元素，令$t=s/(m\ast n)$，称$t$为稀疏因子。</p>
<p>通常认为$s\ll0.05$时，称为稀疏矩阵。</p>
<p>存储方法：</p>
<pre><code>-  三元组顺序表
-  十字链表表示法(需要了解，笔记没有写)
</code></pre><ol>
<li><p>稀疏矩阵的三元组顺序表</p>
<ul>
<li>不存储零数据元素，只存储稀疏矩阵的非零数据元素。</li>
<li>除了存储非零数据的元素的数据值，还需要同时存储它所在的行和列的位置$(i,j)$。</li>
<li>一个三元组$(i,j,a_{ij})$唯一确定了矩阵$A$的一个非零数据元素。</li>
<li>若把稀疏矩阵的三元组线性表按顺序存储结构存储，则称为<strong>稀疏矩阵的三元组顺序表</strong></li>
</ul>
</li>
<li><p>稀疏矩阵的类定义和基本操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Triple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    ElemType e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMatrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mu; <span class="comment">//行数</span></span><br><span class="line">    <span class="keyword">int</span> nu; <span class="comment">//列数</span></span><br><span class="line">    <span class="keyword">int</span> tu; <span class="comment">//非零数据的个数</span></span><br><span class="line">    Triple *data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    SMatrix();</span><br><span class="line">    SMatrix(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, Triple data[]);</span><br><span class="line">    ~SMatrix();</span><br><span class="line">    <span class="function">SMatrix <span class="title">MCreate</span><span class="params">(<span class="keyword">int</span> d[][<span class="number">3</span>], <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MDisplay</span><span class="params">(SMatrix a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MatrixTrans_1</span><span class="params">(SMatrix A, SMatrix &amp;B)</span></span>; <span class="comment">//矩阵转置算法1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MatrixTrans</span><span class="params">(SMatrix A, SMatrix &amp;B)</span></span>;   <span class="comment">//快速转置算法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SMatrix::SMatrix()</span><br><span class="line">&#123;</span><br><span class="line">    mu = <span class="number">0</span>;</span><br><span class="line">    nu = <span class="number">0</span>;</span><br><span class="line">    tu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; tu; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[p].i = <span class="number">0</span>;</span><br><span class="line">        data[p].j = <span class="number">0</span>;</span><br><span class="line">        data[p].e = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SMatrix::SMatrix(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, Triple data[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mu = m;</span><br><span class="line">    <span class="keyword">this</span>-&gt;nu = n;</span><br><span class="line">    <span class="keyword">this</span>-&gt;tu = k;</span><br><span class="line">    <span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SMatrix SMatrix::MCreate(<span class="keyword">int</span> d[][<span class="number">3</span>], <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    SMatrix M = &#123;m, n, k, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="number">0</span>)</span><br><span class="line">        M.data = <span class="keyword">new</span> Triple[k];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        M.data[i].i = d[i][<span class="number">0</span>];</span><br><span class="line">        M.data[i].j = d[i][<span class="number">1</span>];</span><br><span class="line">        M.data[i].e = d[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//矩阵遍历</span></span><br><span class="line"><span class="keyword">void</span> SMatrix::MDisplay(SMatrix a)</span><br><span class="line">&#123;</span><br><span class="line">    Triple p;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, c = <span class="number">0</span>;</span><br><span class="line">    p = a.data[k];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; a.mu; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; a.nu; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; a.tu &amp;&amp; p.i == i &amp;&amp; p.j == j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; p.e;</span><br><span class="line">                k++;</span><br><span class="line">                <span class="keyword">if</span> (k &lt; a.tu)</span><br><span class="line">                    p = a.data[k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于三元组顺序表的转置算法</span></span><br><span class="line"><span class="keyword">void</span> SMatrix::MatrixTrans_1(SMatrix A, SMatrix &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    B.mu = A.nu;</span><br><span class="line">    B.nu = A.tu;</span><br><span class="line">    B.tu = A.tu;</span><br><span class="line">    <span class="keyword">int</span> q, p;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">if</span> (B.tu)</span><br><span class="line">    &#123;</span><br><span class="line">        q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt; A.nu; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt;= A.tu - <span class="number">1</span>; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (A.data[p].j == col)</span><br><span class="line">                &#123;</span><br><span class="line">                    B.data[q].i = A.data[p].j;</span><br><span class="line">                    B.data[q].j = A.data[p].i;</span><br><span class="line">                    B.data[q].e = A.data[p].e;</span><br><span class="line">                    q++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速转置算法</span></span><br><span class="line"><span class="keyword">void</span> SMatrix::MatrixTrans(SMatrix A, SMatrix &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> col, k, p, q;</span><br><span class="line">    <span class="keyword">int</span> *num, *cpot;</span><br><span class="line">    num = <span class="keyword">new</span> <span class="keyword">int</span>[B.nu];</span><br><span class="line">    cpot = <span class="keyword">new</span> <span class="keyword">int</span>[B.nu];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (B.tu)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">0</span>; col &lt; A.tu; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[col] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; A.tu; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[A.data[k].j]++;</span><br><span class="line">        &#125;</span><br><span class="line">        cpot[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt;= A.nu; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            cpot[col] = cpot[col - <span class="number">1</span>] + num[col - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; A.tu; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            col = A.data[p].j;</span><br><span class="line">            q = cpot[col];</span><br><span class="line">            B.data[q].i = A.data[p].j;</span><br><span class="line">            B.data[q].j = A.data[p].i;</span><br><span class="line">            B.data[q].e = A.data[p].e;</span><br><span class="line">            cpot[col]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矩阵的运算一般有<strong>矩阵转置、矩阵相加、矩阵相减、矩阵相乘</strong>等。</p>
<ul>
<li><p>矩阵转置</p>
<p>$def：$一个$m\ast n$的矩阵$A$，它的转置矩阵$B$是一个$n\ast m$的矩阵，且<br>$a[i][j]==b[j][i],1\le i\le m,1\le j\le m$，即$A$的行是$B$的列，$A$的列是$B$的行。</p>
<ol>
<li><p>基于三元组顺序表的转置算法</p>
<ul>
<li><p>基本思想：对矩阵$A$的三元组从头到尾多次扫描</p>
<ol>
<li>第一次扫描时，将$A$中列号为1的三元组行列交换并赋值到矩阵$B$的三元组中；</li>
<li>第二次扫描时，将$A$中列号为2的三元组行列交换并赋值到矩阵$B$的三元组中；</li>
<li>依次类推直到$A$中所有的三元组都赋值到矩阵$B$的三元组中。</li>
</ol>
</li>
<li><p>评价:基于三元组顺序表的矩阵算法更加复杂，虽然节省了存储空间，但可能增大算法的时间复杂度，故基于三元组顺序表的转置算法仅适用<br>$tu \ll m\ast n$情况。</p>
</li>
</ul>
</li>
<li><p>快速转置算法</p>
<ul>
<li><p>快速转置算法的核心思想：对矩阵$A$扫描一次，按矩阵$A$提供的列号一次确定装入矩阵$B$的一个三元组$d$的位置。</p>
<ol>
<li>一遍扫描先确定三元组的位置关系(具体是根据矩阵$A$中非零数据元素的分布确定每列第一个非零数据元素在矩阵$B$中的位置)</li>
<li>二次扫描由位置关系装入三元组。</li>
</ol>
</li>
<li><p>位置关系是快速转置算法的关键<br>为求得矩阵$A$各列第一个非零数据元素的三元组的所在位置，引入两个辅助运算功能的一个数组$num[],cpot[]$</p>
<ul>
<li><p>$num[col]$:存放矩阵$A$中第$col$列的非零数据元素的个数。</p>
</li>
<li><p>$cpot[col]$:存放矩阵$A$中第$col$列第一个非零数据元素的三元组在$B$的位置。</p>
</li>
<li><p>位置计算公式</p>
<script type="math/tex; mode=display">\begin{cases}cpot[1]=1\\
cpot[col]=cpot[col-1]+num[col-1];2\le col\leq n\end{cases}</script></li>
</ul>
</li>
<li><p>步骤：</p>
<ol>
<li>求矩阵$A$中各列非零数据元素的个数$num[]$</li>
<li>求矩阵$A$中各列第一个非零数据元素在转置矩阵$B$中的下标$cpot[col]$</li>
<li>对矩阵$A$进行一次扫描，遇到第$col$列的第一个非零三元组时，按照$cpot[col]$的位置，将其放至矩阵$B$中，当再次遇到第$col$列的非零元三元组时，只需顺序放到第$col$列数据元素的后面。</li>
</ol>
</li>
<li><p>评价：相对于基于三元组顺序表的转置算法，多占用了两个数组的存储空间，同时算法本身比较复杂，但时间复杂度较低，为$O(nu+tu)$。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>矩阵相乘<br>由于两个稀疏矩阵相乘不一定是稀疏矩阵，所以矩阵的乘积采用二维数组表示。设矩阵$A$为$m$行$p$列，矩阵$B$为$p$行$n$列，则计算矩阵乘积$C$($C$为$m$行$n$列)的一般传统方式，依据下述公式计算：</p>
<script type="math/tex; mode=display">C[i][j]=\sum^{p-1}_{k=1}A[i][k]\ast B[k][j]</script><p>一般传统的矩阵相乘的算法代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        c[i][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;p;k++)</span><br><span class="line">            c[i][j]+=a[i][k]*b[k][j];</span><br></pre></td></tr></table></figure>
<p>算法的时间复杂度为$O(m<em>n</em>p)$</p>
<p>如果采用三元组顺序存储表示，则不能采用上述传统矩阵相乘算法。</p>
<p>思路：先求得各个$c[i][j]$的部分积，最后分别累加，只需对$B$每一行扫描一次。</p>
<p>采用上述思路，需要一些辅助数组：</p>
<ol>
<li>一个累加器$ctemp[]$存储当前行中$c[i][j]$的部分积，待当前行中所有数据元素全部算完后，再将非零数据元素的结果存放到$C.data$中。</li>
<li>为了便于在$B$的三元组表中找到各行的第一个非零数据元素，与快速矩阵转置算法类似，引入$num[row]$和$cpot[row]$两个一维数组。其中$num[row]$指示$row$行的非零元个数，$cpot[row]$指示第$row$行第一个非零数据元素的位置。$cpot[row]$的计算公式如下：</li>
</ol>
<script type="math/tex; mode=display">\begin{cases}cpot[0]]=1\\
            cpot[row]=cpot[row-1]+num[row-1];\end{cases}</script><p>采用三元组顺序表表示的稀疏矩阵的乘法步骤如下：</p>
<ol>
<li>如果矩阵$A$的列数和矩阵$B$的行数不同，则不满足计算条件，算法退出。</li>
<li>如果矩阵$A$的列数与矩阵$B$的行数相同，则申请矩阵$C$的存储空间，令矩阵$C$的行数等于矩阵$A$的行数，矩阵$C$的列数等于矩阵$B$的列数。</li>
<li>如果矩阵$A$或矩阵$B$中的非零数据元素个数为0，则矩阵$C$为全零矩阵，计算结束，算法退出。</li>
<li>如果矩阵$A$和矩阵$B$的非零数据元素个数均不为0，求$B$的$num[row]$和$cpot[row]$。</li>
<li>按矩阵$A$的行号从小到大的顺序，执行一下操作。<ol>
<li>对每行非零数据元素执行一下操作：<ul>
<li>累加器$ctemp[nu]$清零；</li>
<li>数据元素$a[i][k]$与$b[k][j]$相乘，累加到$ctemp[j]$中。</li>
</ul>
</li>
<li>如果$ctemp[j]$非零，则得到一个$c[i][j]$即在$C$中新添加一个三元组，$C$的非零数据元素个数增1。</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><p><strong>广义表</strong>$(Generalized\;Lists)$是$n(n\ge 0)$个数据元素的有限序列，一般记作:</p>
<script type="math/tex; mode=display">LS=(a_1,a_2,\cdots,a_n)</script><p>其中,$LS$是广义表的名称，$a_i(i\le i\le n)$是$LS$的直接数据元素，也称成员，它可以是单个数据元素，也可以是一个广义表，它们分别称为$LS$的单数据元素(原子)或子表。</p>
<p>当广义表$LS$非空时：</p>
<ul>
<li>表头$(Head)$：第一个数据元素</li>
<li>表尾$(Tail)$：除去表头后其余数据元素组成的广义表</li>
<li>长度：直接数据元素的个数</li>
<li>深度：括号中最大嵌套层数</li>
</ul>
<p>广义表$()$和广义表$(())$是不同的，前者为空表，长度为0，后者长度为1。</p>
<p>广义表的性质：</p>
<ul>
<li>广义线性：不考虑其数据元素的内部结构，则它是一个线性表，它的直接数据元素之间是线性关系</li>
<li>数据元素复合性：数据元素分为单数据元素和子表，数据类型不统一。</li>
<li>数据元素递归性：广义表是递归的。即广义表可以是自身的子表。</li>
<li>数据元素共享性：广义表以及广义表的数据元素可以被其他广义表共享。</li>
</ul>
<p>广义表的抽象数据类型：</p>
<ul>
<li>数据对象：$D=\{e_i|i=1,2,\cdots,n;n\ge 0;e_i\in AtomSet\;or\;e_i\in GList\}$$AtomSet$为某个数据对象</li>
<li>数据关系：$R=\{<e_{i-1},e_i>|e_{i-1},e_i\in D,2\le i\le n\}$</e_{i-1},e_i></li>
<li>基本操作：<ul>
<li>$InitGList(\&amp;L)$</li>
<li>$CreateGList(\&amp;L,S)$</li>
<li>$CopyGList(\&amp;T,L)$</li>
<li>$GListLength(L)$</li>
<li>$GListDepth(L)$</li>
<li>$GListEmpty(L)$</li>
<li>$GetHead(L)$</li>
<li>$GetTail(L)$</li>
<li>$InsertFirst_GL(\&amp;L,e)$</li>
<li>$DeleteFirst_GL(\&amp;L,e)$</li>
<li>$Traverse_GL(L,visit())$</li>
</ul>
</li>
</ul>
<h4 id="广义表的存储结构"><a href="#广义表的存储结构" class="headerlink" title="广义表的存储结构"></a>广义表的存储结构</h4><p>由于数据元素<strong>类型的不统一</strong>，难以采用顺序存储结构，而采用链式存储结构存储广义表。</p>
<p>若广义表不空，则可分解为<strong>表头和表尾</strong>；反之，一对确定的表头和表尾可唯一确定一个广义表。</p>
<p>根据上述性质可采用<strong>头尾表示法</strong>$(Head\;Tail\;Express)$来存储广义表。</p>
<p>广义表的数据元素可以是单数据元素也可以是广义表，相应的在头尾表示法中链表的结点结构也有两种：</p>
<ul>
<li>表结点，用于存储广义表</li>
<li>数据元素结点，用于存储但数据元素</li>
</ul>
<p>为了区别这两类结点，在结点设置一个标识域，标志为1，则为表结点；标志为0，则该结点为数据元素结点。</p>
<script type="math/tex; mode=display">\boxed{tag=1|hp|tp}\quad\quad\boxed{tag=0|data}</script><ul>
<li>tag:区分表结点和数据元素结点的标志</li>
<li>hp:指向表头结点的指针</li>
<li>tp:指向表尾结点的指针</li>
<li>data:存储数据元素自身的信息</li>
</ul>
<p><code>LS=((),(a),(a,(b,c,d)))</code>的头尾链表存储结构。(自己完成)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">atom</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        GLNode *hp, *tp;</span><br><span class="line">    &#125; ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    GLNode *ls; <span class="comment">//指向表头的指针</span></span><br><span class="line">    <span class="keyword">char</span> result[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> count;                      <span class="comment">//计数</span></span><br><span class="line">    <span class="function">GLNode *<span class="title">CreateGList</span><span class="params">(<span class="built_in">string</span> st)</span></span>; <span class="comment">//由广义表的书面格式s创建广义表</span></span><br><span class="line">    <span class="function">GLNode *<span class="title">CopyGList</span><span class="params">(GLNode *ts, GLNode *ls)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(GLNode *ls)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(GLNode *ls)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    GList();</span><br><span class="line">    GList(<span class="built_in">string</span> s);</span><br><span class="line">    ~GList();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DepthGList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GListCopy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Server</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="built_in">string</span> &amp;hstr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GListDisplay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GList::GList()</span><br><span class="line">&#123;</span><br><span class="line">    ls = <span class="literal">NULL</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GList::~GList()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] ls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树和二叉树-重点"><a href="#树和二叉树-重点" class="headerlink" title="树和二叉树(重点)"></a>树和二叉树(重点)</h2><p>树是一种非线性结构。树是一种<strong>层次结构</strong>。</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树$(Tree)$:是$n(n\ge0)$个结点的有限集。</p>
<p>树的递归定义如下：</p>
<p>当$n=0$时，$T$称为空树；当$n&gt;0$时，$T$是非空树。在一棵非空树中：</p>
<ol>
<li><p>有且仅有一个特定的结点，它只有后继结点，没有前驱结点，这个结点称为根$(Root)$</p>
</li>
<li><p>当$n\gt1$时，除了根以外的其余结点分为$m(m\gt0)$个互不相交的有限集合$T_1,T_2，\cdots,T_m$其中每一个集合本身又是一棵树，并且称为根的<strong>子树</strong>$(SubTree)$。T的定义记作：</p>
<script type="math/tex; mode=display">T=\begin{cases}\varPhi,n=0\\
\{root,T_1,T_2,\cdots,T_m\},n\gt0\end{cases}</script><p>其中，$root$表示$T$的根，$T_1,T_2,\cdots,T_m$表示$T$的$m$棵子树。</p>
</li>
</ol>
<blockquote>
<p>树中结点数目 = 每种结点的度 * 每种结点个数 + 1 </p>
</blockquote>
<h4 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h4><ul>
<li>结点$(Node)$:树中的每个元素对应一个结点</li>
<li>结点的度$(Degree)$:是结点所拥有的子树的个数</li>
<li>树的度$(Degree)$:树中所有结点的度的最大值</li>
<li>叶子结点$(Deaf)$:即度为0的结点，又称为终端结点，叶子结点简称叶子</li>
<li>分支结点$(Branch)$:即度不为0的结点，又称非终端结点，分支结点简称为分支</li>
<li>孩子结点$(Child)$:若结点$X$有子树，则子树的根结点即为结点$X$的孩子结点，孩子结点简称孩子</li>
<li>双亲结点$(Parent)$:若结点$X$有孩子，则$X$即为孩子的双亲结点，双亲结点简称双亲</li>
<li>兄弟结点$(Sibling)$:同一双亲的孩子结点间互称为兄弟结点，兄弟结点简称兄弟</li>
<li>堂兄弟结点$(Cousin)$:结点在树中的层次相同，但双亲不同的结点称为堂兄弟结点，堂兄弟结点简称堂兄弟</li>
<li>结点的层次:根结点的层次为1，根结点的孩子的层次为2，根结点的孩子的孩子的层次为3.依次类推</li>
<li>祖先结点$(Ancestor)$:从根结点到结点$X$所经过分支上的所有结点，都称为$X$的祖先结点，祖先结点简称为祖先</li>
<li>子孙结点$(Descendant)$:结点$X$的孩子，以及这些孩子的孩子都是$X$的子孙结点，子孙结点简称子孙</li>
<li>树的深度$(Depth)$:树中距离根最远的结点所处的层次即为树的深度。空树的深度为0，有一个根结点的树的深度为1.</li>
<li>树的高度$(Height)$:叶子结点的高度为1，非叶子结点的高度等于它的孩子结点的高度的最大值加1,这样定义树的高度等于根结点的高度。高度的深度的计算的方向不同，但数值相等</li>
<li>路径$(Path)$:从树的双亲结点移动到其孩子结点和其他子孙结点所经过的路线；路径上经过的边的个数成为路径长度。</li>
<li>有序树$(Ordered\;Tree)$:树中个结点的各棵子树从左到右都是有次序的树</li>
<li>无序树$(Unordered\;Tree)$:树中各个结点的各棵子树不存在确定的次序关系</li>
<li>森林$(Forest)$:$m(m\ge0)$棵互不相交的树的集合称之为森林</li>
</ul>
<h4 id="树的性质和存储"><a href="#树的性质和存储" class="headerlink" title="树的性质和存储"></a>树的性质和存储</h4><ol>
<li><p>树的性质</p>
<ul>
<li>树中的结点个数等于树中所有结点的度数之和再加1<br>假设树中的结点个数为</li>
<li>度为$m$的树中第$i$层上至多有$m^{i-1}$个结点$(i\ge1)$</li>
</ul>
</li>
<li><p>树的存储结构</p>
<ol>
<li><p>树的顺序存储结构</p>
<p>双亲表示法：$(Parent\;Express)$，一维数组来存储树的每个结点的信息，数组中的一个数据元素表示树中的一个结点，数据元素为结构体类型，其中包括结点本身的信息以及其双亲结点在数组中的位置信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> parent</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PNode</span> <span class="title">Tree</span>[<span class="title">MaxSize</span>];</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>树的链式存储结构</p>
<ul>
<li><p>孩子表示法</p>
<ul>
<li>多重链表表示法：每个结点包括一个信息域和多个指针域，每个指针域指向该结点的一个孩子。<ul>
<li>每个结点的指针域的个数等于树的度数</li>
<li>每个结点的指针域的个数等于该结点的度数</li>
</ul>
</li>
<li>孩子链表示法：存储单元的主体是一个与结点个数大小一样的一维数组，数组的每个元素由两个域组成，一个域用来存放结点的自身信息，另一个域用来存放指针，该指针指向由该结点孩子组成的单链表的表头。</li>
</ul>
</li>
<li><p>双亲孩子表示法：将双亲表示法和孩子表示法相结合的存储方法。将各结点的孩子组成单链表，同时用一维数组顺序存储树的各结点，一维数组中的数组元素除了本身的信息和该结点的孩子结点链表的头指针之外，还有一个域指向双亲结点。</p>
</li>
<li><p>孩子兄弟表示法：又称二叉链表表示法或二叉树表示法。以二叉链表作为树的存储结构，链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，分别命名为$firstchild$和$nextsibling$域。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    TNode *firstchild,*nextsibling;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>树的遍历<br>遍历：$(Traverse)$是树的基本操作。</p>
<p>树的遍历：指从根结点出发，按照某种次序访问树中所有结点，使得每个结点被访问一次且仅被访问一次。</p>
<ul>
<li>先根遍历(先序遍历)</li>
<li>后根遍历(后序遍历)</li>
<li>层次遍历(一层一层的访问)</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h4><ol>
<li>森林的存储结构<ol>
<li>森林的顺序存储结构</li>
<li>森林的链式存储结构<ul>
<li>双亲孩子表示法</li>
<li>孩子兄弟表示法</li>
</ul>
</li>
</ol>
</li>
<li>森林的遍历<ul>
<li>先序遍历森林<br>若森林非空<ol>
<li>访问森林第一棵树的根节点</li>
<li>先序遍历第一棵树中根结点的子树森林</li>
<li>先序遍历除去第一棵树之后剩余的树构成的森林</li>
</ol>
</li>
<li>中序遍历森林<br>若森林非空<ol>
<li>中序遍历第一个棵树的根结点和子树森林</li>
<li>访问第一个棵树的根结点</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="二叉树-重点"><a href="#二叉树-重点" class="headerlink" title="二叉树(重点)"></a>二叉树(重点)</h4><ol>
<li><p>定义</p>
<p>二叉树：$(Binary\;Tree)$:一种树形结构，每个结点至多有两棵子树，分别称为左子树和右子树。</p>
<p>二叉树的递归定义如下：</p>
<script type="math/tex; mode=display">T=\begin{cases}\phi,n=0\\\{root,T_L,T_r\},n\gt0\end{cases}</script></li>
<li><p>性质</p>
<ul>
<li>在二叉树的第$i(i\ge1)$层上至多有$2^{i-1}$个结点。</li>
<li>深度为$k(k\ge1)$的二叉树至多有$2^{k}-1$个结点</li>
<li>对任何一棵非空二叉树，如果其叶子结点数为$n_0$,度为2的结点数为$n_2$则$n_0=n_2+1$.<ul>
<li>满二叉树：$(Full\;Binary\;Tree)<br>$深度为$k$且有$2^{k}-1$个结点的二叉树。除最底层结点度为0，其余都为2。</li>
<li>完全二叉树：$(Complete\;Binary\;Tree)$<br>如果一棵深度为$k$且具有$n$个结点的二叉树，它的每一个结点都与深度为$k$的满二叉树中顺序编号为$1\sim n$的结点一一对应。</li>
</ul>
</li>
<li>具有$n(n\gt0)$个结点的完全二叉树的深度为$\left\lfloor log_2n\right\rfloor+1$</li>
<li>如果将一棵$n$个结点的完全二叉树按照自顶向下，同一层自左向右的顺序连续给结点编号$1,2,3,\cdots,n$。<br>按照此结点编号将树中各结点顺序地存放于一个一维数组，并简称编号为$i$的结点为结点$1\le i\le n)$<ol>
<li>若$i=1$，则结点$i$为根，无双亲结点；若$i\gt1$,则结点的双亲结点为结点$\left\lfloor\frac{i}{2}\right\rfloor$</li>
<li>若$2i\le n$，则结点$i$的左孩子为结点$2i$，否则$i$无左孩子</li>
<li>若$2i+1\le n$，则结点$i$的右孩子为结点$2i+1$，否则结点$i$无右孩子</li>
</ol>
</li>
</ul>
</li>
<li><p>二叉树的存储结构</p>
<ul>
<li><p>二叉树的顺序存储结构</p>
<ol>
<li>完全二叉树的顺序存储表示</li>
<li>一般二叉树的顺序表示：对不存在的结点仍然编号。</li>
</ol>
</li>
<li><p>二叉树的链式存储结构</p>
<p>顺序存储方式用于完全二叉树的存储非常有效，但用于一般二叉树，存储空间浪费。</p>
<p>根据二叉树的定义，每个结点可以有两个分支：<br>二叉树的结点至少三个域，分别存放数据信息$data$、左孩子结点指针$lchild$和右孩子结点指针$rchild$，这种结构称为二叉链表$(Binary)\;Linked\;List$。<br>为了便于查找，可以增加一个指向双亲结点的指针域。这样的结构称为三叉链表$(Trifurcate\;Linked\;List)$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    BiTNode *lchild, *rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    BiTNode *bt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">RCreate</span><span class="params">(BiTNode *p, <span class="keyword">int</span> k, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">PreTraverse</span><span class="params">(BiTNode *p)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InTraverse</span><span class="params">(BiTNode *p)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">PostTraverse</span><span class="params">(BiTNode *p)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    BinaryTree();</span><br><span class="line">    ~BinaryTree();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(<span class="keyword">int</span> end)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BiTNode *<span class="title">GetRoot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BiTreeDisplay</span><span class="params">(BiTNode *bt, <span class="keyword">int</span> level = <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BinaryTree::BinaryTree()</span><br><span class="line">&#123;</span><br><span class="line">    bt = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinaryTree::~BinaryTree()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] bt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>平衡二叉树：每个结点的左右子树的高度之差的绝对值不超过1.</p>
</blockquote>
</li>
<li><p>二叉树的遍历</p>
<ol>
<li><p>二叉树遍历的概念</p>
<ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层次遍历</li>
</ul>
</li>
<li><p>二叉树遍历的递归算法和非递归算法</p>
<ol>
<li><p>递归算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> BinaryTree::PreTraverse(BiTNode *p)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        PreTraverse(p-&gt;lchild);</span><br><span class="line">        PreTraverse(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BinaryTree::InTraverse(BiTNode *p)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InTraverse(p-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        InTraverse(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BinaryTree::PostTraverse(BiTNode *p)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PostTraverse(p-&gt;lchild);</span><br><span class="line">        PostTraverse(p-&gt;rchild);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>非递归算法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BinaryTree::PreOrderTraverse()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"先序非递归遍历二叉树："</span>;</span><br><span class="line">    BiTNode *p = bt;</span><br><span class="line">    <span class="function">SqStack <span class="title">s</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (p || !s.StackEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            s.Push(p-&gt;data);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.Pop();</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>二叉树遍历的应用</p>
<ul>
<li>利用后序递归遍历计算结点个数</li>
<li>利用后序递归遍历计算树的高度</li>
<li>利用后序递归遍历销毁二叉树</li>
<li>利用先序递归遍历复制二叉树</li>
<li>利用先序递归遍历判断两棵二叉树是否相等</li>
<li>利用先序递归遍历构造二叉树</li>
<li>利用先序遍历输出显示二叉树</li>
</ul>
</li>
</ol>
</li>
<li><p>线索二叉树</p>
<p>一个具有$n$个结点的二叉树若采用二叉链表存储结构，在$2n$个指针域中只有$n-1$个指针域用来存储孩子结点的地址，另外的$n+1$个指针域为空，利用这些空指针域存放指向该结点的某种遍历序列中的前驱和后继结点的位置信息。</p>
<p>其中：</p>
<script type="math/tex; mode=display">ltag=\begin{cases}0,*lchild\;is\;lchild\\
1,*lchild\;is\;preNode\end{cases}</script><script type="math/tex; mode=display">rtag=\begin{cases}0,*rchild\;is\;rchild\\
1,*rchild\;is\;postNode\end{cases}</script><p>线索$(Thread)$：指向结点前驱和后继的指针<br>线索二叉树$(Thread\;Binary\;Tree)$：加上线索的二叉树<br>线索链表$(Thread\;Linked\;List)$：加上线索的二叉链表<br>线索化：对二叉树以某种次序进行遍历使其成为线索二叉树的过程</p>
<p>结点结构示意图：</p>
<script type="math/tex; mode=display">\boxed{lchild|ltag|data|rtag|rchild}</script><p>线索二叉树的定义和基本操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    BiThrNode *lchild, *rchild;</span><br><span class="line">    <span class="keyword">int</span> LTag, RTag;</span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadBiTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    BiThrNode *bt;</span><br><span class="line">    BiThrNode *pre;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RCreate</span><span class="params">(BiThrNode *p, <span class="keyword">int</span> flag, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    BiThrNode *Thrt;</span><br><span class="line">    ThreadBiTree();</span><br><span class="line">    ~ThreadBiTree();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(<span class="keyword">int</span> end)</span></span>;</span><br><span class="line">    <span class="function">BiThrNode *<span class="title">GetRoot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InOrderThreading</span><span class="params">(BiThrTree &amp;Thrt, BiThrTree T)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BiTreeDisplay</span><span class="params">(BiThrNode *bt, <span class="keyword">int</span> level = <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">ThreadBiTree::ThreadBiTree()</span><br><span class="line">&#123;</span><br><span class="line">    bt = <span class="literal">NULL</span>;</span><br><span class="line">    Thrt = <span class="keyword">new</span> BiThrNode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadBiTree::~ThreadBiTree()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ThreadBiTree::InThreading(BiThrTree p)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        InThreading(p-&gt;lchild);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;LTag = <span class="number">1</span>;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pre-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;RTag = <span class="number">1</span>;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        InThreading(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="树，森林与二叉树的转换"><a href="#树，森林与二叉树的转换" class="headerlink" title="树，森林与二叉树的转换"></a>树，森林与二叉树的转换</h3><ol>
<li><p>树与二叉树的转换</p>
<p>由于树和二叉树都可以采用二叉链表作为存储结构，则以二叉链表作为中间形态导出树和二叉树之间的对应关系。</p>
<p>将一棵树转换成二叉树的方法如下：</p>
<ol>
<li>加线：在树中所有相邻兄弟之间加一条连线</li>
<li>抹线：对树中的每个结点，只保留它与第一个孩子结点之间的连线，删除它与其他孩子结点之间的连线</li>
<li>旋转：以树的根结点为轴心，将整棵树顺时针旋转45°，使之成为一棵层次分明的二叉树</li>
</ol>
</li>
<li><p>森林与二叉树的转换</p>
<ol>
<li>将森林中的每棵树转换成对应的二叉树</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子。</li>
</ol>
</li>
</ol>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆：设有$n$个元素的序列$\{k_1,k_2,\cdots,k_n\}$,当且仅当满足下述关系之一时：</p>
<script type="math/tex; mode=display">\begin{cases}k_i\le k_{2i}\\
k_i\le k_{2i+1}\end{cases}
\;or\;
\begin{cases}k_i\ge k_{2i}\\
k_i\ge k_{2i+1}\end{cases}</script><p>若以一维数组存储堆，则堆对应为一棵完全二叉树，且所有非叶子结点的值均不大于或不小于其子女的值，根结点的值是最小或最大的。</p>
<p>堆具有下列其中某一条性质的完全二叉树：</p>
<ol>
<li>每个结点的值都小于或等于其左右孩子结点的值，称为小根堆或小顶堆。</li>
<li>每个结点的值都大于或等于其左右孩子结点的值，称为大根堆或大顶堆。</li>
</ol>
<h3 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h3><ol>
<li><p>概念</p>
<p>哈夫曼树：又称最优二叉树，指带权路径长度最小的二叉树。</p>
<p>涉及的术语：</p>
<ul>
<li>结点的权：对结点赋予的一个有着某种意义的数值</li>
<li>结点的带权路径长度：从树根结点到该结点之间的路径长度与该结点权值的乘积</li>
<li>叶子结点：树中度为0的结点</li>
<li>树的带权路径长度：树中所有叶子结点的带权路径长度之和</li>
</ul>
<p>树的带权路径长度$WPL$可记为：</p>
<script type="math/tex; mode=display">WPL=\sum^n_{k=1}W_k\bullet L_k</script><p>其中$W_k$为第$k$个叶子结点的权值，$L_k$为第$k$个叶子结点的路径长度。</p>
</li>
<li><p>哈夫曼树的构造</p>
<p>哈夫曼树的构造算法如下：</p>
<ol>
<li>根据给定的$n$个权值$\{w_1,w_2,\cdots,w_n\}$构造$n$棵二叉树的集合$F=(T_1,T_2,\cdots,T_n)$，其中每棵二叉树$T_i$中只有一个权值为$W_i$的根结点，其左右子树均为空。</li>
<li>在$F$中选取两个根结点的权值最小的树，分别作为左右子树构造一棵新的二叉树，且将新的二叉树的根结点的权值为置其左右子树上根结点的权值之和。</li>
<li>在$F$中删除作为左右子树的两棵二叉树，同时将新得到的二叉树加入$F$中。</li>
<li>重复2和3，直到$F$只含有一棵树为止，这棵树就是哈夫曼树。</li>
</ol>
</li>
<li><p>哈夫曼编码</p>
<p>在数据通信中，需要将传送的文字转换成由二进制字符0、1组成的字符串也称编码。</p>
<p>每个字符所转换的二进制字符长度相等称为<strong>等长编码</strong>。</p>
<p>如果让出现频率高的字符采用尽可能短的编码，出现频率低的字符采用稍长的编码，构造一种<strong>不等长编码</strong>，则电文的代码总长度会更短。</p>
<p>设计电文总长最短的编码方式：构造以字符使用频率作为权值的哈夫曼树。</p>
<p>具体操作如下：设需要编码的字符集合为$\{d_1,d_2,\cdots,d_n\}$，它们在电文中出现的次数或频率集合为$\{w_1,w_2,\cdots,w_n\}$，以$d_1,d_2,\cdots,d_n$作为叶子结点，$w_1,w_2,\cdots,w_n$作为它们的权值，构造一棵哈夫曼树，规定哈夫曼树的左分支代表0，右分支代表1，则从根结点到每个叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，称之为<strong>哈夫曼编码</strong>。</p>
<p><strong>在不等长编码的选择上，必须使任何一个字符的编码都不是其他字符编码的前缀，以保证译码的唯一性。</strong></p>
<p>若采用哈夫曼编码，则能确保译码的唯一性。</p>
<p>哈夫曼编码的算法：</p>
<ol>
<li>构造哈夫曼树。</li>
<li>在哈夫曼树上求叶子结点的编码。</li>
</ol>
</li>
</ol>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><ul>
<li>图：是由有穷非空的顶点集合和顶点之间的边的集合组成的，可表示为：</li>
</ul>
<p>  其中，表示图，图中的数组元素通常叫做<strong>顶点</strong>称为顶点的非空有穷集合，是图中顶点之间边的集合。</p>
<ul>
<li><p>无向边：若顶点和间的边没有方向，用表示</p>
</li>
<li><p>无向图：只有无向边的图</p>
</li>
<li><p>有向边(弧)：若顶点和间的边有方向,用表示且称为弧尾或初始点,称为弧头或终端点</p>
</li>
<li><p>有向图：只有有向边的图</p>
</li>
<li><p>自环:顶点有直接与自身相连的边</p>
</li>
<li><p>多重图：任意连个顶点之间有多条边直接相连</p>
</li>
<li><p>完全图：在由个边组成的<strong>无向图</strong>中，若有条边，则称之<strong>无向完全图</strong>。在由个边组成的<strong>有向图</strong>中，若有条边，则称之为<strong>有向完全图</strong></p>
</li>
<li><p>权：在某些图上，边或弧上具有与它相关的数据信息称之为权</p>
</li>
<li><p>网或网络：带权的图</p>
<p>分别称带权的有向图和带权的无向图为<strong>有向网和无向网</strong></p>
</li>
<li><p>邻接顶点：相邻的两个结点互为邻接顶点</p>
</li>
<li><p>子图：设图和，若且，则称图为图的子图。</p>
</li>
<li><p>度：与顶点关联的边的数目，记作。</p>
<ul>
<li>有向图中，顶点的度等于出度加入度</li>
<li>入度：以顶点为弧头的弧的数目，记作</li>
<li>出度：以顶点为弧尾的弧的数目，记作</li>
<li></li>
<li>无论有向图和无向图，若图有n个顶点和e条边，则有：</li>
</ul>
</li>
<li><p>路径：从一个顶点到另一个顶点经过的顶点序列</p>
</li>
<li><p>路径长度：一条路径上经过的边或弧的数目</p>
</li>
<li><p>简单路径和回路：路径上的各顶点补充度称为简单路径，若第一个顶点和最后一项顶点重复，称这样的路径为回路或环。</p>
</li>
<li><p>连通图和连通分量：在无向图中，两顶点之间存在路径，则两顶点是连通的。如果图中任意一对顶点都是连通的，则此图为连通图。非连通图的极大连通子图叫做连通分量</p>
</li>
<li><p>强连通图与强连通分量：在有向图中，若在每一对顶点和之间都存在一条从到的路径，也存在一条从到的路径，则此图叫做强连通图，而非强连通图的极大强连通子图叫做强连通分量。</p>
</li>
<li><p>生成树：具有个顶点的连通图的生成树是包含中全部顶点的一个极小连通子图，在生成树中添加任意一条原图中的边必会产生回路或环，减少一条边则必然会成为非连通图。一棵具有个顶点的生成树有且仅有条边</p>
</li>
<li><p>生成森林：非连通图的每个连通分量都可以得到一棵生成树，这些连通分量的生成树构成了森林，即生成森林</p>
</li>
<li><p>稀疏图和稠密图：边很少的图称为稀疏图，反之称为稠密图。稀疏和稠密是模糊的概念，稀疏图和稠密图常常是相对而言。</p>
<blockquote>
<p>Prim常用求稠密图的最小生成树</p>
</blockquote>
</li>
</ul>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><ol>
<li><p>图的顺序存储结构——邻接矩阵</p>
<p>邻接矩阵存储结构是指用两个数组表示图。</p>
<p>一个一维数组存储图中顶点的信息，一个二维数组存储图中顶点之间的关系。</p>
<p>设图包含个顶点，则的邻接矩阵是一个二维数组</p>
<ul>
<li>若是一个无权图，则的邻接矩阵定义为：</li>
</ul>
</li>
</ol>
<ul>
<li>若是一个网，则的邻接矩阵定义为：</li>
</ul>
<p>   图的邻接矩阵存储结构具有的特点：</p>
<ul>
<li>无向图的邻接矩阵是对称的，采用压缩矩阵进行存储。</li>
<li>有向图的邻接矩阵不一定对称，因此采用邻接矩阵存储据具有个顶点的有向图，需要个存储单元。</li>
<li>无向图邻接矩阵的第行(或第列)中非零元素的个数，就是顶点的度。</li>
<li>有向图邻接矩阵的第行中非零元素的个数，就是顶点的出度，第列中非零元素的个数就是顶点的入度。</li>
<li><p>邻接矩阵容易确定图中两顶点的是否有边，但检测边需要很大的时间代价。</p>
<p>邻接矩阵的存储结构的类定义和基本操作：</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_VERTEX_NUM 20</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int infinity = INT32_MAX;</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct ArcCell</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int adj; //对无权图1,0表示是否相邻，对带权图表示权值类型</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *info;</span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct MGraph</span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string vexs[MAX_VERTEX_NUM];                  //顶点表</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArcCell arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; //邻接矩阵表，即  边表</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int vexnum;                                   //顶点数</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arcnum;                                   //边数</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int kind;                                     //邻接矩阵存储的  图的种类</span><br></pre></td></tr></table></figure>
<p>16</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>17</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Graph</span><br></pre></td></tr></table></figure>
<p>18</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>19</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br></pre></td></tr></table></figure>
<p>20</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MGraph mgraph;</span><br></pre></td></tr></table></figure>
<p>21</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool visited[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>
<p>22</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>23</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br></pre></td></tr></table></figure>
<p>24</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Graph(/* args */);</span><br></pre></td></tr></table></figure>
<p>25</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~Graph();</span><br></pre></td></tr></table></figure>
<p>26</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void CreateGraph();</span><br></pre></td></tr></table></figure>
<p>27</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int LocateVex(string u); //返回顶点u在图中的位置</span><br></pre></td></tr></table></figure>
<p>28</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool CreateDG();         //构造有向图</span><br></pre></td></tr></table></figure>
<p>29</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool CreateUDG();        //构造无向图</span><br></pre></td></tr></table></figure>
<p>30</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool CreateDN();         //构造有向网</span><br></pre></td></tr></table></figure>
<p>31</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool CreateUDN();        //构造无向网</span><br></pre></td></tr></table></figure>
<p>32</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Display();          //输出邻接矩阵</span><br></pre></td></tr></table></figure>
<p>33</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void DFSTraverse(int v); //深度优先遍历</span><br></pre></td></tr></table></figure>
<p>34</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void BFDTraverse(int v); //广度优先遍历</span><br></pre></td></tr></table></figure>
<p>35</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>图的链式存储结构</p>
<ol>
<li><p>邻接表是图的一种链式存储结构</p>
<ul>
<li>基本思想： 邻接表只存储有关联的信息，对图中存在的相邻顶点之间边的信息进行存储，而对于不相邻的顶点则不保留信息。设图具有个顶点，则用顶点数组表和边表来表示图</li>
<li>顶点数组表 用于存储顶点的名或其他有关信息，也称为数据域。该数组的大小为图中的顶点个数。顶点数组表中的数据元素也称为表头结点。 每个表头结点由两个域组成：<ul>
<li>：结点的数据域，用来保存结点的数据值</li>
<li>：结点的指针域，也称为链域，指向自该结点出发的第一条边的边结点</li>
</ul>
</li>
<li>边表(弧表) 图中每一个顶点建立一个单链表，第个单链表的结点表示依附于顶点的边。该单链表中的结点称为边结点， 每个边结点由三个域组成：<ul>
<li>:指示该边所指向的顶点在图中的位置，也称为邻接点域</li>
<li>:边结点的指针域，指向下一条边结点</li>
<li>:存储和边相关的信息，如权值</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<pre><code>  1

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//邻接表</span><br><span class="line"></span><br><span class="line">struct ArcNode</span><br></pre></td></tr></table></figure>


  3

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>


  4

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int adjvex;</span><br></pre></td></tr></table></figure>


  5

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArcNode *next;</span><br></pre></td></tr></table></figure>


  6

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


  7

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


  8

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct VertexNode</span><br></pre></td></tr></table></figure>


  9

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>


  10

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int vertex;</span><br></pre></td></tr></table></figure>


  11

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArcNode *firstedge;</span><br></pre></td></tr></table></figure>


  12

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


  13

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


  14

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_VERTEX_NUM 20</span><br></pre></td></tr></table></figure>


  15

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


  16

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct ArcNode</span><br></pre></td></tr></table></figure>


  17

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>


  18

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int adjvex;</span><br></pre></td></tr></table></figure>


  19

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct ArcNode *nextarc;</span><br></pre></td></tr></table></figure>


  20

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *info;</span><br></pre></td></tr></table></figure>


  21

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


  22

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


  23

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct VNode</span><br></pre></td></tr></table></figure>


  24

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>


  25

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string data;</span><br></pre></td></tr></table></figure>


  26

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArcNode *firstarc;</span><br></pre></td></tr></table></figure>


  27

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


  28

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


  29

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct AdjLGraph</span><br></pre></td></tr></table></figure>


  30

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>


  31

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VNode vertices[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>


  32

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int vexnum;</span><br></pre></td></tr></table></figure>


  33

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arcnum;</span><br></pre></td></tr></table></figure>


  34

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int kind;</span><br></pre></td></tr></table></figure>


  35

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


  36

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class ALGraph</span><br></pre></td></tr></table></figure>


  37

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>


  38

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br></pre></td></tr></table></figure>


  39

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdjLGraph algraph;</span><br></pre></td></tr></table></figure>


  40

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool visited[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>


  41

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


  42

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br></pre></td></tr></table></figure>


  43

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALGraph(/* args */);</span><br></pre></td></tr></table></figure>


  44

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ALGraph();</span><br></pre></td></tr></table></figure>


  45

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void CreateGraph();</span><br></pre></td></tr></table></figure>


  46

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int LocateVex(string u);</span><br></pre></td></tr></table></figure>


  47

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void ALGraphDisplay();</span><br></pre></td></tr></table></figure>


  48

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void FindInDegree(int indegree[]);</span><br></pre></td></tr></table></figure>


  49

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool TopologicalSort();</span><br></pre></td></tr></table></figure>


  50

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li>十字链表 十字链表是有向图的一种链式存储方式。 十字链表将邻接表和逆邻接表结合起来得到的</li>
</ol>
<pre><code>  弧结点中共五个域：

  - tailevex：弧尾结点，即弧尾在顶点表的下标
  - headvex：弧头结点，即弧头在顶点表的下标
  - hlink：指向弧头相同的下一条弧
  - tlink：指向弧尾相同的下一条弧
  - info：存储该弧的相关信息

  顶点结点即链表的头结点：

  - data：存储和该顶点相关的信息
  - firstin：指向该顶点的第一个弧结点
  - firstout：指向该顶点为弧尾的第一个弧结点

  1

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//十字链表</span><br></pre></td></tr></table></figure>

  2

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  3

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_INFO 10</span><br></pre></td></tr></table></figure>

  4

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  5

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct ArcBox</span><br></pre></td></tr></table></figure>

  6

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  7

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int tailvex, headvex;</span><br></pre></td></tr></table></figure>

  8

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArcBox *hlink, *tlink;</span><br></pre></td></tr></table></figure>

  9

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *info;</span><br></pre></td></tr></table></figure>

  10

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  11

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  12

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct VexNode</span><br></pre></td></tr></table></figure>

  13

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  14

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string data;</span><br></pre></td></tr></table></figure>

  15

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArcBox *firstin, *firstout;</span><br></pre></td></tr></table></figure>

  16

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  17

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  18

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct OLGraph</span><br></pre></td></tr></table></figure>

  19

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  20

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VexNode xlist[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>

  21

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int vexnum, arcnum;</span><br></pre></td></tr></table></figure>

  22

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  23

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  24

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class OrListGraph //有向图的十字链表表示</span><br></pre></td></tr></table></figure>

  25

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  26

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br></pre></td></tr></table></figure>

  27

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OLGraph olgraph;</span><br></pre></td></tr></table></figure>

  28

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool visited[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>

  29

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  30

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br></pre></td></tr></table></figure>

  31

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OrListGraph(/* args */) &#123;&#125;</span><br></pre></td></tr></table></figure>

  32

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~OrListGraph() &#123;&#125;</span><br></pre></td></tr></table></figure>

  33

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void CreateGraph();</span><br></pre></td></tr></table></figure>

  34

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int LocateVex(string u);</span><br></pre></td></tr></table></figure>

  35

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Display();</span><br></pre></td></tr></table></figure>

  36

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li>邻接多重表 邻接多重表是无向图的一种链式存储方式。</li>
</ol>
<pre><code>  - mark：标志域，可以标记改边是否被搜索过
  - ivex、jvex：与该边依附的两个顶点在顶点表的下标
  - ilink、jlink：指针域，指向下一条依附于顶点ivex和jvex的边
  - info：存储和边相关的信息
  - data：存储和该点相关的信息
  - firstedge：指示第一条依附于该顶点的边
</code></pre><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><ol>
<li><p>深度优先搜索 类似树的先根遍历。 从图中的某个点v出发，作为当前顶点，访问此顶点，并设置该顶点的访问标志，接着从v的为被访问的邻接点中找出一个作为下一步探查的当前顶点。倘若当前顶点的所有邻接顶点都被访问过，则退回一步，将前一步访问的顶点重新取出，作为当前探查顶点，重复上述过程，直至图中最初指定起点的所有邻接顶点都被访问到。</p>
<p>深度优先搜索的过程中所有访问过的顶点和经过的边，构成一个连通的无环图，也就是深度优先搜索树，简称DFS树</p>
<p>深度优先搜索的递归实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Graph::DFSTraverse(int v)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; mgraph.vertex[v];</span><br><span class="line">    visited[v]=1;</span><br><span class="line">    for(j=0;j&lt;mgraph.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(mgraph.arcs[v][j]==1 &amp;&amp; visited[j]==0)</span><br><span class="line">            DFSTraverse(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>广度优先搜索</p>
<p>类似树的层次遍历</p>
<p>无向连通图广度优先搜索的实现</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Graph::BFSTraverse(int v)</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">front = rear = -1;</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; mgraph.vertex[v];</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visited[v]=1;</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q[++rear]=v;</span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(front!=rear)</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v=Q[++front];</span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(mgraph.arcs[v][j]==1 &amp;&amp; visited[j]==0)</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DFSTraverse(j);</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; mgraph.vertex[j];</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visited[j]=1;</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q[++rear]=j;</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>连通分量和重连通分量</p>
<ul>
<li>连通分量：当无向图为非连通图时，利用或,无法遍历图中的所有顶点，而只能遍历到该顶点所在的最大连通子图的所有顶点，这些顶点构成一个连通分量。</li>
<li>关节点:在无向连通图中，当且仅当删去一个点及其依附于它的边，图被分为两个连通分量。</li>
<li>重连通图：没有关节点的连通图</li>
</ul>
</li>
</ol>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>设是一个无向连通网</p>
<ul>
<li>代价：的生成树上任一条边的权值称为该边的代价</li>
<li>最小生成树：一棵生成树的代价就是树上各边代价之和，代价最小的生成树就是最小代价生成树，简称最小生成树。</li>
</ul>
<p>根据生成树的定义，若连通带权图由个顶点组成，其生成树必含个顶点，条边，因此构造最小代价生成树的准则有3条：</p>
<ol>
<li>只能使用该网络中的边来构造最小生成树</li>
<li>能且只能使用条边来连接网络中的n个顶点</li>
<li>选用的条边不能产生回路</li>
</ol>
<p>构造最小生成树的方法多数利用了最小生成树的一种性质，简称MST</p>
<ul>
<li>:假设是一个连通网，是顶点集的一个非空子集。若是一条具有最小权值的边，其中，，则必存在一棵包含边的最小生成树。</li>
</ul>
<p>构造最小生成树的典型算法：</p>
<ul>
<li>算法</li>
<li>算法</li>
</ul>
<p>都利用了性质，采用逐步求解的策略，亦称<strong>贪心策略</strong></p>
<ol>
<li><p>算法(适用于稀疏图)</p>
<p>基本思想：设一个有个顶点的连通网络。</p>
<ul>
<li>首先构造一个由个顶点组成，不含任何边的图，其中每个顶点自成一个连通分量</li>
<li>不断从中去除代价最小的一条边（若有多条，任选其一）,若该边的两个顶点来自T的不同的连通分量，则将此边加入到T中，否则舍去此边选择下一条代价最小的边。</li>
<li>依次类推，直到T中所有的顶点在同一个连通分量为止。</li>
</ul>
</li>
</ol>
<ol>
<li><p>算法(适用于稠密图)</p>
<p>基本思想：</p>
<ul>
<li>给定任意带权连通网络是的最小生成树。</li>
<li>算法始终将顶点集合分成没有元素重叠的两部分，，的初始状态为,然后重复执行一下操作：</li>
<li>在所有的边中找出一条代价最小的边并入集合,同时并入，直至为止。</li>
</ul>
</li>
</ol>
<h3 id="有向无环图及其应用"><a href="#有向无环图及其应用" class="headerlink" title="有向无环图及其应用"></a>有向无环图及其应用</h3><ul>
<li><p>有向无环图：一个无环的有向图，简称图</p>
<ul>
<li><p>有向无环图是描述含有公共子式的表达式的有效工具。例如：</p>
</li>
<li><p>有向无环图也是描述一项工程或系统的有效工具</p>
<p>关心的问题：</p>
<ol>
<li>工程是否能够顺利进行</li>
<li>估算整个工程完成所必须的最短时间 对应于有向图，则进行拓扑排序和求关键路径的操作。</li>
</ol>
</li>
</ul>
</li>
<li><p>网与拓扑排序</p>
<ul>
<li>活动：所有工程或某种流程可以分成若干个小的工程或阶段，这些小的工程或阶段就是活动</li>
<li>网：用顶点表示活动，有向边表示活动的优先关系</li>
<li>若顶点到顶点之间存在一条有向路径，则称顶点是顶点的前驱或顶点是顶点的后继</li>
<li>拓扑排序：就是由某个集合的一个偏序得到该集合上的一个全序的操作<ul>
<li>若集合的关系满足自反、反对称和传递性，则称是集合上的偏序</li>
<li>若是集合上的偏序，如果对每个必有或，则称是上的全序关系 对一个有向无环图进行拓扑排序，是将G中所有顶点排成一个线性序列， 使得图中任意一对顶点u和v,若边，则u在线性序列中出现在v之前。 通常，这样的线性序列称为满足拓扑次序的序列，简称拓扑序列。</li>
</ul>
</li>
</ul>
</li>
<li><p>网与关键路径(重点)</p>
<ul>
<li>网：边表示活动的网。网是一个带权的有向无环图。顶点表示事件，弧表示活动，权表示活动持续的时间，网可以用来表示工程的进度计划</li>
<li>在正常情况下(无环)下：网中只有一个入度为0的点,称之为源点；一个出度为0的点，称之为汇点</li>
</ul>
<p>用于工程估算：</p>
<ol>
<li>完成整个工程所需的时间(假设网中无环)？</li>
<li>那些活动是影响工程进度的关键？</li>
</ol>
<ul>
<li>关键路径：完成整个工程所需的时间取决于从源点到汇点的最长路径的长度，即在这条路径上所有活动的持续时间之和，这条最长的路径即关键路径</li>
<li>关键活动：不按时完成就会影响整个工程的活动。关键路径上的活动就是关键活动</li>
</ul>
</li>
</ul>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><ul>
<li><p>最短路径：由于从一个顶点到另一个顶点可能存在多条路径，每条路径上所经过的边数可能不同，即路径长度不同，则称路径长度最短即边数最少的路径为最短路径</p>
</li>
<li><p>带权图路径长度：若图是带权图，则把一个顶点到图中其余任一个顶点的一条路径所经过边上的权值之和定义为带权图路径长度</p>
</li>
<li><p>最短路径问题包括：</p>
<ul>
<li>求图中一个顶点到其余顶点的最短路径</li>
<li>求图中每对顶点之间的最短路径</li>
</ul>
</li>
<li><p>单源最短路径 利用算法解决单源最短路径问题：给定带权有向图和源点,求到中其余个点的最短路径，其时间复杂度为</p>
<p><strong> 搞清执行过程</strong></p>
</li>
<li><p>每对顶点间的最短路径 求各个顶点之间最短路径的算法，其时间复杂度也是：</p>
<p>通过计算图中各个顶点的最短路径时，需要引入两个矩阵，- 矩阵中的元素表示顶点(第个顶点)到顶点(第个顶点)的距离。</p>
<ul>
<li>矩阵中的元素，表示顶点到顶点经过了记录的值所表示的顶点。</li>
</ul>
<p>假设图G中顶点个数为，则需要对矩阵和矩阵进行次更新。初始时，矩阵中顶点的距离为顶点到顶点的权值; 如果和不相邻，则，矩阵的值为顶点的的值。接下来开始，对矩阵进行次更新。 第1次更新时，如果”的距离”“”(表示”与之间经过第1个顶点的距离”)，则更新为””,更新。 同理，第次更新时，如果”的距离”“”，则更新为””,。更新次之后，操作完成！</p>
<p><a href="https://blog.csdn.net/qq_35644234/article/details/60875818" target="_blank" rel="noopener">最短路径问题—-Floyd算法详解</a></p>
</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h3><ul>
<li><p><strong>静态查找表</strong>：仅对查找表进行查找操作，不进行插入和删除操作的查找表</p>
</li>
<li><p><strong>动态查找表</strong>：可以查找表进行查找、插入和删除操作的表。</p>
</li>
<li><p>面向查找操作的数据结构称为<strong>查找结构</strong></p>
<ul>
<li><strong>线性表</strong>：适用于静态查找，主要采用顺序查找技术、折半查找技术</li>
<li><strong>树表</strong>：适用于动态查找，主要采用二叉排序树的查找技术；</li>
<li><strong>散列表</strong>：静态和动态查找均适用，主要采用<strong>散列技术</strong>。</li>
</ul>
<p>以“关键字与给定值的比较次数”作为衡量算法效率的方法，该比较次数的期望值，称为查找成功的<strong>平均查找长度</strong></p>
<p>对于含有n个记录的表，查找成功的平均查找长度为：</p>
</li>
</ul>
<p>  是查找第个记录的概率，且表示找到给定关键字与给定值相等的第个记录，已和给定值进行过比较的关键字个数。</p>
<h3 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h3><ol>
<li><p>顺序查找</p>
<ul>
<li><p>又称线性查找。</p>
</li>
<li><p>基本思想</p>
<p>首先将顺序表中的第一个存储单元(即下标为0的单元)设置为“监视哨”，即把待查值放入该单元，查找时从顺序表的最后一个单元开始，依次向前搜索进行查找</p>
</li>
<li><p>算法分析</p>
<ul>
<li>查找成功的情况下： 若每个记录的查找概率相等，即，则为：</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code> - 查找失败和查找成功的可能性相同，且每个记录的查找概率相等，则 在查找失败的情况下，不管查找的关键字为何值，其比较次数都为。在该条件下的平均查找长度为：
</code></pre><ul>
<li><p>优点：算法简单，对表的结构没有任何要求</p>
</li>
<li><p>缺点：当很大，查找效率很低</p>
</li>
</ul>
<ol>
<li><p>有序表的查找</p>
<ul>
<li><p>当查找表中的数据元素无序，选择顺序查找简单又实用。但但查找表中的数据元素在顺序存储时是有序的情况下，可以采用<strong>折半查找</strong>，又称<strong>二分查找</strong></p>
</li>
<li><p>基本思想</p>
<p>给定有序表ST,在表ST中取位于中间的记录作为比较对象，若中间记录和关键字与给定值相等，则查找成功；若中间记录的关键字大于给定值，则在中间记录的左半区继续查找；若中间记录的关键字小于给定值，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功或所查找的区域无记录即查找失败</p>
</li>
<li><p>折半查找算法的非递归实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int Search_Bin(int key)</span><br><span class="line">&#123;</span><br><span class="line">    int low=0;high=st.length-1;</span><br><span class="line">    int mid;</span><br><span class="line">    while(low&lt;=hight)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/2;</span><br><span class="line">        if(st.elem[mid]==key)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;查找成功，处于第&quot;&lt;&lt;mid+1&lt;&lt;&quot;位置&quot;&lt;&lt;endl;</span><br><span class="line">            return mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(st.elem[mid]&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(st.elem[mid]&lt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;未找到！&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造折半查找判定树</p>
<ol>
<li>确定下标范围：0-10</li>
<li>L[(0+10)/2]=5 —&gt; 根结点为6 左子树的下标为0-4 右子树的下标范围为 6-10</li>
<li>L[(0+4)/2]=2 ,…..</li>
<li>L[(6+10)/2]=8 ,…..</li>
</ol>
</li>
<li><p>算法分析</p>
<p>对于折半查找，查找成功时进行的关键字比较次数至多为。 查找成功的平均查找长度为</p>
</li>
</ul>
</li>
</ol>
<pre><code> 当比较大时， 查找失败时的平均查找长度的量级为：
</code></pre><ol>
<li><p>分块查找</p>
<ul>
<li><p>分块查找又称索引顺序查找</p>
</li>
<li><p>前提：查找表，满足分块有序，分块有序即整个查找表无序，但把查找表看做几个子表时，每个子表的关键字是有序的。</p>
</li>
<li><p>基本思想</p>
<p>在查找时，首先用待查值key在索引表中进行区间查找(即查找key所在的子表，由于索引表按最大关键字项有序，因此可采用折半查找或者顺序查找)，然后在对应的子表进行顺序查找</p>
</li>
<li><p>算法分析</p>
<p>设对索引表查找的平均查找长度为,对待查子表中查找元素的平均查找长度为，则分块查找的平均查找长度可以通过两种算法的平均查找长度之和表示：</p>
</li>
</ul>
</li>
</ol>
<pre><code> 采用分块查找：长度为n的表分为b块，每个块m个记录，则。

 - 采用顺序查找确定块的位置

   块的查找概率为，块中每个记录的查找概率为，该条件下分块查找的平均查找长度为：



   当时，平均查找厂区取最小值为。

 - 采用折半查找确定块
</code></pre><ol>
<li><p>二叉排序树</p>
<ul>
<li><p>二叉排序树又称二叉查找树</p>
</li>
<li><p>性质</p>
<ol>
<li>若左子树不空，则左子树上的所有结点的值均小于根结点的值</li>
<li>若右子树不空，则右子树上的所有结点的值均大于根结点的值</li>
<li>它的左右子树也分别是二叉排序树</li>
</ol>
</li>
<li><p>查找方法</p>
<p>首先将给定值key与根结点的关键字进行比较，若相等，则查找成功；若根结点的关键字大于key，则在根结点的左子树上进行查找，否则在根结点的右子树上进行查找</p>
</li>
<li><p>查找代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int key;</span><br><span class="line">&#125;;</span><br><span class="line">struct BTSNode</span><br><span class="line">&#123;</span><br><span class="line">    Node data;</span><br><span class="line">    BTSNode *lchild,*rchild;</span><br><span class="line">&#125;;</span><br><span class="line">void SearchBST(BTSNode *T,int key)</span><br><span class="line">&#123;</span><br><span class="line">    if((!T)||(key==T-&gt;data.key))</span><br><span class="line">    &#123;</span><br><span class="line">        if(!T)</span><br><span class="line">            cout &lt;&lt; &quot;找不到&quot;&lt;&lt;key&lt;&lt;“的结点”&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;找到&quot;&lt;&lt;key&lt;&lt;“的结点”&lt;&lt;endl;</span><br><span class="line">        else if(key&lt;T-&gt;data.key)</span><br><span class="line">            SearchBST(T-&gt;lchild,key);</span><br><span class="line">        else</span><br><span class="line">            SearchBST(T-&gt;rchild,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int SearchBST(BTSNode *T,int key,BTSNode *f,BTSNode* &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    if(!T)//查找不成功</span><br><span class="line">    &#123;</span><br><span class="line">        p=f;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(key==T-&gt;data.key)//查找成功</span><br><span class="line">    &#123;</span><br><span class="line">        p=T;</span><br><span class="line">        return = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(key&lt;T-&gt;data.key)</span><br><span class="line">        return SearchBST(T-&gt;lchild,key,T,p);</span><br><span class="line">    else</span><br><span class="line">        return SearchBST(T-&gt;rchild,key,T,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉排序树的插入(插入的位置为查找失败的位置)</p>
<ul>
<li><p>插入方法</p>
<p>首先在树中查找是否已有关键字为key的结点，若查找成功，则说明待插入结点已经存在，不能插入重复结点。只有当查找失败，才能在树中插入关键字为key的新节点。</p>
</li>
<li><p>插入代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int InsertBST(int e)</span><br><span class="line">&#123;</span><br><span class="line">    int key =e;</span><br><span class="line">    BTSNode *p = new BTSNode;</span><br><span class="line">    BTSNode *T = BT;</span><br><span class="line">    if(!SearchBST(T,key,NULL,p))</span><br><span class="line">    &#123;</span><br><span class="line">        BTSNode *s = new BTSNode;</span><br><span class="line">        s-&gt;data.key = e;</span><br><span class="line">        s-&gt;lchild=s-&gt;rchild=NULL:</span><br><span class="line">        if(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            BT=s;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(key&lt;p-&gt;data.key)</span><br><span class="line">            p-&gt;lchild=s;</span><br><span class="line">        else</span><br><span class="line">            p-&gt;rchild=s;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>二叉排序树的删除</p>
<ul>
<li><p>删除代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int DeleteBST(BSTNode* &amp;T，int key)</span><br><span class="line">&#123;</span><br><span class="line">    if(!T)</span><br><span class="line">        return 0;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if(key==T-&gt;data.key)</span><br><span class="line">            return Delete(T);</span><br><span class="line">        else if(key&lt;T-&gt;data.key)</span><br><span class="line">            return DeleteBST(T-&gt;lchild,key);</span><br><span class="line">        else</span><br><span class="line">            return DeleteBST(T-&gt;rchild,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>平衡二叉树的构造（AVL）首先是一个二叉树排序树(重点，补充平衡二叉树的调整)</p>
</li>
</ul>
</li>
<li><p>B_树</p>
<p>上述介绍的查找方法都是适用于内部查找的方法，称为<strong>内部查找法</strong>。适用于数据集不大，可以放入内存中，适用于对较小的文件进行查找，而不适用于对较大的存放在外存储器中文件。</p>
<ul>
<li><p>B_树：特点是插入、删除时易于保持平衡，外部查找效率高，适用于组织磁盘文件的动态索引结构。</p>
<p>B_树是一种平衡的多路查找树，作为索引组织文件，用以提高访问速度。</p>
</li>
<li><p>一棵m阶的B_树，可以为空树，或者是一棵满足下列性质的m叉树：</p>
<ol>
<li>树中的每个结点至多有m棵子树</li>
<li>若根结点不是叶子结点，则至少有两棵子树</li>
<li>除根结点之外所有非叶子结点至少有棵子树</li>
<li>有s个子树的非叶子结点具有s-1个关键字，所有非叶子结点包含下列信息： ，其中为关键字个数，为关键字，为指向子树根结点的指针，且指针所指子树中所有结点的关键字均小于，所指子树中所有结点的关键字均大于 </li>
<li>B_树总是树高平衡的，所有的叶子结点都在同一层，且不包含任何关键字信息。通常叶子结点也被称为失败结点。</li>
</ol>
</li>
<li><p>B树的构造(补充)</p>
</li>
</ul>
</li>
</ol>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>在查找时，如果给定值在表中存在，则需根据并通过对应关系，即可的到在表中的存储位置。因此不需要比较，仅通过的计算，就能获得要查找的记录。称这样的对应关系为<strong>哈希函数</strong>或<strong>散列函数</strong>或<strong>杂凑函数</strong>，根据这个思想建立的表称为<strong>哈希表</strong>或<strong>散列表</strong>或<strong>杂凑表</strong>，根据哈希函数所得到的存储位置称为<strong>哈希地址</strong>或<strong>散列地址</strong>，而这种映像过程被称为<strong>哈希造表</strong>或<strong>散列</strong>。</p>
<p>根据函数的性质可知，对于某个函数，不同的通过获得的可能是相同的。</p>
<ul>
<li><strong>冲突</strong>：不同的关键字有可能的到相同的哈希地址的现象</li>
<li><strong>同义词</strong>：相同函数值的关键字称为函数上的同义词。</li>
</ul>
<p>采用散列技术需要考虑的两个问题：</p>
<ul>
<li>哈希函数的设计</li>
<li>冲突的处理</li>
</ul>
<ol>
<li><p>哈希函数</p>
<p>设计哈希函数应该遵循的原则</p>
<ul>
<li>计算简单，否则会降低查找效率</li>
<li>每个关键字所对应的哈希地址分布均匀。</li>
</ul>
<p>常见的几种哈希函数的构造方法：</p>
<ol>
<li><p>直接定址法</p>
<ul>
<li>定义 直接定义一个线性函数，取关键字对于该函数的函数值作为哈希地址，即：</li>
</ul>
</li>
</ol>
</li>
</ol>
<pre><code>    其中a和b是常数。

  - 特点 这类函数是一一对应函数，因此不会产生冲突，但要求地址集合和关键字集合的大小相同，并且当关键字跨度非常大时并不适用。该方法在实际生活中并不常用
</code></pre><ol>
<li><p>数学分析法</p>
<ul>
<li><p>定义 在关键字集合中，若每个关键字均由位组成，而每位上都有中不同的取值，通过分析中不同符号在每一位上的分布情况，选择其中某几位分布较为均匀的符号组成哈希地址。</p>
</li>
<li><p>Example 例如：一组关键字进行关键字分析</p>
<p>| 第一位 | 第二位 | 第三位 | 第四位 | 第五位 | 第六位 | 第七位 |<br>| ——— | ——— | ——— | ——— | ——— | ——— | ——— |<br>| 6      | 5      | 3      | 7      | 6      | 8      | 5      |<br>| 6      | 5      | 3      | 3      | 2      | 5      | 1      |<br>| 6      | 5      | 3      | 6      | 5      | 4      | 3      |<br>| 6      | 5      | 4      | 2      | 0      | 1      | 9      |<br>| 6      | 5      | 3      | 9      | 8      | 3      | 4      |<br>| 6      | 5      | 4      | 1      | 2      | 3      | 4      |<br>| 6      | 5      | 4      | 5      | 4      | 3      | 7      |</p>
<p>其中所有关键字的第一、二位均为6/5，而第三位也只有3和4，因此 这三位不用作哈希地址，剩余4位的取值分布比较均匀，可以作为哈希地址，因此可选取者四位中任意两位组合成哈希地址，也可以对这四位进行适当的处理来获得哈希地址。</p>
</li>
</ul>
</li>
<li><p>平方取中法</p>
<ul>
<li><p>定义 取关键字平方后的中间几位作为哈希地址。</p>
</li>
<li><p>Example 例如：关键字集合</p>
<p>| 关键字 | 关键字平方 | 所选取哈希地址 |<br>| ——— | ————— | ——————— |<br>| 3456   | 11943936   | 43             |<br>| 2564   | 6574096    | 40             |<br>| 3466   | 12013156   | 13             |<br>| 3454   | 11930116   | 30             |</p>
<p>平方后可取地中第4、5位作为哈希地址</p>
</li>
</ul>
</li>
<li><p>折叠法</p>
<ul>
<li><p>定义 将关键字按位数分割成几部分(其中最后一部分的长度会较小)，然后将这些部分按一定的方式进行求和，按哈希表表长取后几位作为哈希地址</p>
</li>
<li><p>形式</p>
<ul>
<li>位移法：将各部分按最后一维对齐相加</li>
<li>间接折叠法：从一端向另一端沿分割界来回折叠，然后对齐相加</li>
</ul>
</li>
<li><p>Example 例子：一个关键字为83950661436，哈希表长为3 首先将关键字表长分割成若干部分：</p>
<p>位移法： 间接折叠法：</p>
<p>由于哈希表长度为3，分别取后三位991和721作为关键地对应的哈希地址。</p>
</li>
</ul>
</li>
<li><p>除留余数法</p>
<ul>
<li>定义 选择一个常数，取关键字除以所得的余数作为哈希地址，即</li>
</ul>
</li>
</ol>
<pre><code>    该方法对的选取非常重要，若哈希表长度为，则要求小于等于且接近，并且一般选质数作为，或者是一个不包含小于20质因子的合数。
</code></pre><ol>
<li><p>处理冲突的方法</p>
<ol>
<li><p>开放定址法</p>
<ul>
<li>定义 开放地址，即一旦根据关键字所得到的哈希地址发生冲突，则按照某种规则寻找下一个空闲单元的哈希地址，只要哈希地址足够大，空的哈希地址总是能找到的。 其函数定义为：</li>
</ul>
</li>
</ol>
</li>
</ol>
<pre><code>    其中，为哈希函数，为哈希表长，的所取的增量序列。每种再散列的方法区别在于的取值不同。

  - 常用的方法

    - 线性探测再散列 取增量序列为的方法。 其过程描述为：当哈希地址发生冲突时，查看哈希地址是否为空，若为空则将数据放入，否则查看是否为空，依次类推
    - 二次探测在散列 取增量序列为 其过程描述为：当哈希地址发生冲突时，查看哈希地址是否为空，若为空则将数据放入，否则查看是否为空，若为空则将数据放入，否则查看是否为空，依次类推
    - 伪随机探测在散列 取增量序列为一个伪随机数 其过程描述为：当哈希地址发生冲突时，产生一个伪随机数，查找哈希地址是否为空，若为空则将数据放入，否则重新产生一个伪随机数查看是否为空，依次类推。
</code></pre><ol>
<li><p>再哈希法</p>
<ul>
<li>定义 再哈希法用数学表达式可以描述为:</li>
</ul>
</li>
</ol>
<pre><code>    其中，均为不同的哈希函数。 在哈希法的本质是使用个哈希函数，若第一个函数发生冲突，则利用第二个函数再生生成一个地址，直到产生的地址不冲突为止。
</code></pre><ol>
<li><p>链地址法</p>
<ul>
<li>定义 将每个哈希地址都作为一个指针，指向一个链表。 若哈希表长为，则建立个空链表，将哈希函数对关键字进行转换为后，映射到统一哈希地址的同义词均加入到地址指向的链表中</li>
</ul>
</li>
<li><p>建立一个公共溢出区</p>
<ul>
<li>定义 设哈希函数产生的哈希地址集为，则分配两个表。一个表作为基本表，其每个存储单元仅存放一个数据元素；另一个表为溢出表，只要关键字对应的哈希地址在基本表上发生了冲突，则将发生冲突的元素一律放入该表中。</li>
</ul>
<p>查找时，对应给定关键字，通过哈希函数计算出哈希地址为，则先与基本表中的地址为的数据元素进行比较，若相等则查找成功；否则再在溢出表中进行查找。</p>
</li>
</ol>
<ol>
<li><p>哈希查找算法及分析</p>
<p>查找元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define p 13//MOD 13</span><br><span class="line">struct HashTable</span><br><span class="line">&#123;</span><br><span class="line">    int *elem;//数据元素基址</span><br><span class="line">    int count;//当前数据元素个数</span><br><span class="line">    int size;//哈希表长度</span><br><span class="line">&#125;ht;</span><br><span class="line">int SearchHash(int key,int &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    s = CalHash(key);</span><br><span class="line">    while((ht.elem[s]!=-1)&amp;&amp;(ht.elem[s]!=key))//发生冲突</span><br><span class="line">        Collision(s);</span><br><span class="line">    if(ht.elem[s]==key)</span><br><span class="line">        return 1;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算哈希地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int CalHash(int key)//由哈希函数求哈希地址</span><br><span class="line">&#123;</span><br><span class="line">    return key % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发生冲突，计算下一地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Collision(int &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    s=s++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int InsertHash(int e)</span><br><span class="line">&#123;</span><br><span class="line">    int s;</span><br><span class="line">    if(ht.count == ht.size)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;表满，不能插入！&quot; &lt;&lt; endl;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        s = CalHash(e);</span><br><span class="line">        int r = SearchHash(e,s);</span><br><span class="line">        if(r)//表中已有和e的关键字相同的元素，不能插入操作</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;元素已经存在，不能插入！&quot; &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ht.elem[s]=e;</span><br><span class="line">            ht.count++;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找过程中，关键字的比较次数取决于产生冲突的次数，冲突产生越少，查找效率就越高。</p>
<p>影响冲突产生的因素有：</p>
<ol>
<li><p>哈希函数是否均匀</p>
</li>
<li><p>冲突的处理方法</p>
</li>
<li><p>哈希表的<strong>装填因子</strong> 将哈希表中元素的个数和哈希长度的比值最为哈希表的装填因子，即</p>
</li>
</ol>
</li>
</ol>
<pre><code>  是哈希表装满程度的指标，即装填因子。 与填入表中的元素的个数成正比，填入表中元素越多越大，冲突产生的可能性越大。
</code></pre><h2 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h2><h3 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h3><ul>
<li><p>排序</p>
<p>设有记录序列，其相应的关键字序列为， 若存在某种确定的关系，其中且各不相同，则将记录序列排成按关键字有序的序列的操作。</p>
</li>
<li><p>正序：若待排序序列中的记录已按关键字排序，此序列为正序</p>
</li>
<li><p>逆序和反序：若待排序序列中的记录的排序顺序与排序后的排列顺序正好相反</p>
</li>
<li><p>一趟：指在排序过程中，将待排序的记录序列扫描一遍</p>
</li>
<li><p>单关键字排序：根据一个关键字进行的排序</p>
</li>
<li><p>多关键字排序：根据多个关键字进行的排序，多关键字排序主要针对关键字有重复的情况下。</p>
</li>
<li><p>按照排序过程中数据元素是否完全在内存，分为：</p>
<ol>
<li>内部排序：在排序的整个过程，待排序的所有记录全部放置在内存中的排序方法，也称内排序</li>
<li>外部排序：指待排序的记录个数太多，不能同时放置在内存，需要将一部分记录放置在内存中，另一部分放置在外存中，整个排序过程需要在内外存之间多次交换数据才能得到排序结果的方法，也称外排序</li>
</ol>
</li>
<li><p>按照是否建立在关键字比较的基础上，分为：</p>
<ol>
<li>基于比较的排序方法：通过关键字之间的比较、记录的移动者两种操作来实现的方法 如：插入排序、交换排序、选择排序和归并排序</li>
<li>不基于比较的排序方法：根据待排序数据的特点所采取的其他方法，通常没有大量的关键字之间的比较和记录的移动这两种操作的排序 如：基数排序</li>
</ol>
</li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li>插入排序的工作原理：每次将一个待排序的数据按其关键字的大小<strong>插入</strong>到一个已经完成排序的<strong>有序序列</strong>中，直到所有记录排序结束。</li>
<li>根据排序的执行过程分为<ul>
<li>直接插入排序</li>
<li>折半插入排序</li>
<li>表插入排序</li>
<li>Shell排序</li>
</ul>
</li>
</ul>
<ol>
<li><p>直接插入排序</p>
<ul>
<li><p>算法思路</p>
<p>通过构建有序序列，对于未排序数据，在已排序序列中从后往前扫描，从而找到相应的位置并插入。 在从后往前扫描过程中，需要反复把已排序逐步往后挪位，为待插入的新元素提供插入空间</p>
</li>
<li><p>步骤</p>
<ol>
<li>设置</li>
<li>将待插入记录放入编号为0的结点(即下标为0的结点)，即;并令，从第个记录开始向前查找插入位置</li>
<li>若,执行5；否则执行4</li>
<li>将第个记录后移，即；并令;执行3</li>
<li>完成插入记录：。若，则排序结束，否则执行2</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void SInsertSort(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=2;i&lt;=L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(L.r[i]&lt;=L.r[i-1])</span><br><span class="line">        &#123;</span><br><span class="line">            L.r[0]=L.r[i];</span><br><span class="line">            L.r[i]=L.r[i-1];</span><br><span class="line">            for(int j=i-2;L.r[0]&lt;=L.r[j];j--)</span><br><span class="line">                L.r[j+1]=L.r[j];</span><br><span class="line">            L.r[j+1]=L.r[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：两层嵌套循环结构，其外层循环n-1次，而内层循环执行次数取决于待排序列记录初始的排列情况。<ul>
<li>最好情况：待排序序列为正序，算法时间复杂度为</li>
<li>最坏情况：待排序序列为逆序，算法时间复杂度为</li>
<li>平均情况：算法的平均时间复杂度为</li>
</ul>
</li>
<li>空间复杂度：由于只需一个作为暂存待插入记录的存储单元，空间复杂度为</li>
<li>稳定性：该算法是稳定的排序算法</li>
</ul>
</li>
</ul>
<ol>
<li><p>折半插入排序</p>
<blockquote>
<p>当待排序记录数量很小时，直接插入排序方法是一种效率较高的排序算法。当记录数量较大，不宜用直接插入排序。</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>既然在有序表中确定插入位置，可以不断二分有序表来确定插入位置，即在一次比较中，通过比较待插入记录和有序表中中间记录的关键字，将有序表一分为二，而下一次比较则在其中一个有序子表中进行，将子表再次一分为二。这样继续下去，直到要比较的子表中只有一个记录时，做最后一次比较以确定插入位置。</p>
</li>
<li><p>步骤</p>
<ol>
<li>设置</li>
<li>顺序表中前个记录有序，将第个记录插入。令，，</li>
<li>若,得到插入位置；执行6；否则执行4</li>
<li>则取有序子表的中点</li>
<li>若,则插入位置在低半区，令；否则插入位置在高半区，令;执行3</li>
<li>即为待插入位置，从到的记录，逐个后移，。若，则排序结束，否则执行2</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void BInsertSort(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">    int high,low,m;</span><br><span class="line">    for(int i=2;i&lt;=L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.r[0]=L.r[i];</span><br><span class="line">        low = 1;</span><br><span class="line">        high = i-1;</span><br><span class="line">        while(low&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            m = (low+high)/2;</span><br><span class="line">            if(L.r[0]&lt;=L.r[m])</span><br><span class="line">                high=m-1;</span><br><span class="line">            else</span><br><span class="line">                low=m+1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=i-1;j&gt;high+1;j--)</span><br><span class="line">            L.r[j+1]=r[j];</span><br><span class="line">        L.r[high+1]=L.r[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：关键字比较次数最多为因此时间复杂度为</li>
<li>空间复杂度：</li>
<li>稳定性：折半插入排序是稳定的排序方法</li>
</ul>
</li>
</ul>
<ol>
<li><p>表插入排序</p>
<blockquote>
<p>前面介绍的两种插入排序算法都要大量移动记录，表插入排序则是一种不移动记录而是通过改变存储结构来进行排序的算法</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>表插入排序是通过链接指针、按关键字的大小实现从小到大的链接过程，为此需增设一个指针项。</p>
<p>具体的操作方法与直接插入排序类似，不同的是表插入排序是直接修改链接指针来完成记录的排序。</p>
<p>所需结点定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define SIZE 150</span><br><span class="line">struct SLNode</span><br><span class="line">&#123;</span><br><span class="line">    int rc;//记录项</span><br><span class="line">    int next;//指针项</span><br><span class="line">&#125;;</span><br><span class="line">struct SLinkList</span><br><span class="line">&#123;</span><br><span class="line">    SLNode node[size];//0号单元为表头结点</span><br><span class="line">    int curlen;//链表实际长度</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>具体思想：</p>
<p>首先设置空循环链表，即头结点指针置0，并在头结点数据中存放比所有记录的关键字都大的整数，然后把结点逐个向链表中插入即可。</p>
</li>
<li><p>步骤</p>
<ol>
<li>进行初始化操作。令</li>
<li>若，调整结束；否则根据对静态链表进行遍历：<ol>
<li>当时停止遍历，令执行2</li>
<li>当时，，执行2.1</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void SLInsertSort(SlinkList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">    int min,max;</span><br><span class="line">    L.node[0].next = 1;</span><br><span class="line">    L.node[1].next = 0;//初始化形成指头头结点的循环链表</span><br><span class="line">    max = min = 1;</span><br><span class="line">    for(int i=2;i&lt;=L.curlen;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(L.node[i].rc&lt;=L.node[min].rc)</span><br><span class="line">        &#123;</span><br><span class="line">            L.node[0].next = i;</span><br><span class="line">            L.node[i].next = i-1;</span><br><span class="line">            min = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(L.node[i].rc&gt;=L.node[max].rc)</span><br><span class="line">        &#123;</span><br><span class="line">            L.node[i].next = 0;</span><br><span class="line">            L.node[max].next = i;</span><br><span class="line">            max = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(L.node[i].rc&lt;L.node[max].rc &amp;&amp; L.node[i].rc &gt; L.node[min].rc)</span><br><span class="line">        &#123;</span><br><span class="line">            int index1=min,index2;//index2标记index1的前一个下标</span><br><span class="line">            while(L.node[i].rc&gt;=L.node[index1].rc)</span><br><span class="line">            &#123;</span><br><span class="line">                index2=index1;</span><br><span class="line">                index1=L.node[index1].next;</span><br><span class="line">            &#125;</span><br><span class="line">            L.node[i].next=index1;</span><br><span class="line">            L.node[index2].next=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;表插入排序结果如下：&quot; &lt;&lt; endl;</span><br><span class="line">    int index = L.node[0].next;</span><br><span class="line">    while(index!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; L.node[index].rc &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        index = L.node[index].next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：</li>
<li>空间复杂度：</li>
<li>稳定性：表插入排序是稳定的排序方法</li>
</ul>
</li>
</ul>
<ol>
<li><p>希尔排序</p>
<blockquote>
<p>希尔排序又称缩小增量排序，是1969年D.L.Shell提出的，它是对直接插入排序的一种改进</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<ul>
<li><p>先将待排序记录分成若干个子序列，在子序列内分别进行直接插入排序；</p>
</li>
<li><p>直到整个序列基本有序时，在对全体记录进行一次直接插入排序。</p>
</li>
<li><p>与直接插入排序的区别</p>
<p>希尔排序不是每次一个元素挨着一个元素比较，而是初期选用大跨步(增量较大)间隔比较，使记录跳跃式的接近它的排序位置；然后增量逐步缩小，最后增量为1.</p>
</li>
</ul>
</li>
<li><p>步骤</p>
<ol>
<li>选择一个步长序列，其中且当时，</li>
<li>按步长序列个数，对序列执行次3</li>
<li>每次排序，根据对应的步长，将待排序列分成若干个子序列，分别对各子序列进行直接插入排序。当步长为1时，整个序列作为一个表来处理，表长度即为整个序列的长度</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述</p>
<ul>
<li><p>子程序(一趟希尔排序)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void ShellInsert(SqList &amp;L,int dk)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=dk+1;i&lt;=L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.r[0]=L.r[i];</span><br><span class="line">        for(int j=i-dk;j&gt;0 &amp;&amp; L.r[0]&lt;=L.r[j];j-=dk)</span><br><span class="line">            L.r[j+dk]=L.r[j];</span><br><span class="line">        L.r[j+dk]=L.r[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主程序(按照增量序列对顺序表调用子程序)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void ShellSort(SqList &amp;L,int dlta[],int t)</span><br><span class="line">&#123;</span><br><span class="line">    for(int k=0;k&lt;t;k++)</span><br><span class="line">        ShellInsert(L,dlta[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：时间性能在，当在某个特定范围，希尔排序算法的时间复杂度约为</li>
<li>空间复杂度：</li>
<li>稳定性：不稳定，以为例，该序列经过步长序列的希尔排序得到有序序列为</li>
</ul>
</li>
</ul>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><blockquote>
<p>交换排序是一类借助比较和交换进行排序的犯法。其中交换是指对序列中两个记录的关键字进行比较，如果排序不对则对换两个记录在序列中的位置。交换排序的特点是：将关键字较大的记录向序列的一端移动，而关键字较小的记录向序列的另一端移动。</p>
</blockquote>
<ol>
<li><p>冒泡排序</p>
<blockquote>
<p>冒泡排序也称为起泡排序，是交换排序中常用的排序方法</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>通过对排序元素中相邻元素间的关键字的比较和交换，是关键字最大的元素如气泡一样逐渐“上浮”。</p>
</li>
<li><p>步骤</p>
<ol>
<li>从存储个待排序元素的表尾开始，并令</li>
<li>若，则排序结束</li>
<li>从第一个元素开始进行两两比较，令</li>
<li>若，则冒泡排序结束，；待排序表记录数为-1，转2</li>
<li>比较与，若，则不交换，转7</li>
<li>当时，将和交换</li>
<li>，转4继续比较</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void BubbleSort(SqList &amp;L)</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt; L.length; i++)</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int j = 0; j &lt; L.length - i; j++)</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (L.r[j] &gt; L.r[j + 1])</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int t = L.r[j];</span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.r[j] = L.r[j + 1];</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.r[j + 1] = t;</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度 总需要进行次冒泡，对个记录的表进行一趟冒泡排序需要次关键字比较，平均的总比较次数为:</li>
</ul>
</li>
</ul>
<pre><code>   - 平均时间复杂度为：
   - 最好情况：
   - 最坏情况：

 - 稳定性：冒泡排序是一种稳定的排序方法。比较是相邻单元进行的，如果关键字值相同则不进行交换。
</code></pre><ol>
<li><p>快速排序</p>
<blockquote>
<p>快速排序也称分区交换排序</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>通过对关键字的比较和交换，以待排序列中的某个数据为支点(或称枢轴量)，将待排序列分成两个部分，其中左半部分小于等于支点，右半部分大于等于支点。然后对左右两部分分别进行快速排序的递归处理，直到整个序列按关键字有序为止。</p>
<p>其中将待排序列按关键字以支点分成两个部分的过程称为<strong>一次划分</strong></p>
</li>
</ul>
</li>
</ol>
<pre><code> 冒泡排序中，元素的比较和移动是在相邻位置进行的，元素比较次数和移动次数较多。 而在快速排序中，元素的比较和移动是从两端向中间进行的，关键字较大的记录一次就能从前面移动到后面，关键字较小的记录一次移动到前面，记录移动的距离较远，从而减少了总的比较次数和移动次数。 可将快速排序看做对冒泡排序的一种改进。
</code></pre><ul>
<li><p>步骤</p>
<ol>
<li>如果待排序子序列中元素的个数等于1，则排序结束；否则以为支点，按如下方法进行一次划分：<ol>
<li>设置两个搜索指针：是向后搜索指针，初始指向序列第一个结点；是向前搜索指针，初始指向最后一个结点；取第一个记录为支点，位暂时取值为支点。</li>
<li>若,枢轴空位确定为，一次划分结束。</li>
<li>若且，则从所指定的位置向前搜索：，重新执行1.3； 否则若有并且有，则设置为新的支点位置。 并交换和，然后令,执行1.4；若，则执行1.2</li>
<li>若且。则从所指的位置开始向后搜索：，重新执行1.4； 否则若由并且有，则设置为新的支点位置， 并交换和，然后令，执行1.3；若，则执行1.2</li>
</ol>
</li>
<li>对支点左半子序列重复1</li>
<li>对支点右半子序列重复1</li>
</ol>
</li>
<li><p>语言描述</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int QSort::Partition(SqList &amp;L, int low, int high)/对序列的一次划分</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pivotkey;</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.r[0] = L.r[low];   //用子表的第一个记录作枢轴记录</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pivotkey = L.r[low]; //关键字</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while (low &lt; high) //从表的两边交替向中间扫描</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while (low &lt; high &amp;&amp; L.r[high] &gt;= pivotkey)</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--high;</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.r[low] = L.r[high]; //将比枢轴小的记录移至低端</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>16</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while (low &lt; high &amp;&amp; L.r[low] &lt;= pivotkey)</span><br></pre></td></tr></table></figure>
<p>17</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>18</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++low;</span><br></pre></td></tr></table></figure>
<p>19</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>20</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.r[high] = L.r[low]; //将比枢轴大的记录移至高端</span><br></pre></td></tr></table></figure>
<p>21</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>22</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.r[low] = L.r[0]; //枢轴记录到位</span><br></pre></td></tr></table></figure>
<p>23</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return low;        //返回枢轴位置</span><br></pre></td></tr></table></figure>
<p>24</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>25</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void QSort::QuickSort1(SqList &amp;L, int low, int high) //按分区对子程序进行调用</span><br></pre></td></tr></table></figure>
<p>26</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>27</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int mid;</span><br></pre></td></tr></table></figure>
<p>28</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (low &lt; high)</span><br></pre></td></tr></table></figure>
<p>29</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>30</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mid = Partition(L, low, high);</span><br></pre></td></tr></table></figure>
<p>31</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QuickSort1(L, low, mid - 1);</span><br></pre></td></tr></table></figure>
<p>32</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QuickSort1(L, mid + 1, high);</span><br></pre></td></tr></table></figure>
<p>33</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>34</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度<ul>
<li>最好情况：每次支点都将待排序划分成两个长度相等的子列时，</li>
<li>最坏情况：每次划分都只得到一个子列时，快速排序的过程类似冒泡排序，</li>
<li>为了避免最坏情况，对快速排序进行一定的改进，改进方法是选取支点时选最左、最右和中间三个元素取值处于中间的元素作为支点。</li>
</ul>
</li>
<li>空间复杂度：</li>
<li>稳定性：以为例，经过快速排序得到有序序列为，因此快速排序是<strong>不稳定</strong>的排序方法</li>
</ul>
</li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote>
<p><strong>选择排序</strong>是一类借助”选择”进行排序的方法</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>每一趟从待排序列中选取一个关键字最小的记录，也即第一趟从个记录中选取关键字最小的记录，第二趟从剩下的个记录中选取关键字最小的记录，直到全部元素排序完毕。</p>
<p>适用于从大量元素中选择一部分排序元素的应用，如从50000个元素中选择前10个关键字最小的元素等。</p>
</li>
</ul>
<ol>
<li><p>简单选择排序</p>
<ul>
<li><p>算法思想</p>
<p>第一趟从个记录中选出关键字最小的记录和第一个记录交换；第二趟从第二个记录开始的个记录中选出关键字最小的记录与第二个记录交换；如此第趟则从第个记录开始的个记录中选出关键字最小的记录与第个记录交换，直到整个序列按关键字有序。</p>
</li>
<li><p>步骤</p>
<blockquote>
<p>注：书上的设置i=1，因为书上默认列表的第一个元素即用来暂存待移动的下标</p>
</blockquote>
<ol>
<li>创建一个辅助变量用于存放每次遍历关键字最小记录的下标，设指变量</li>
<li>遍历第个记录到第个记录。选这一个关键字最小的记录，将其下标保存指中</li>
<li>若第个记录的关键字小于中保存的记录的关键字，则交换这两个记录</li>
<li>，若，则执行2；否则排序结束</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void QSort::SSelectionSort(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">    int t, j;</span><br><span class="line">    for (int x = 0; x &lt;= L.length - 1; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = x;</span><br><span class="line">        for (int y = x; y &lt;= L.length - 1; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (L.r[y] &lt; L.r[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (x != j)</span><br><span class="line">        &#123;</span><br><span class="line">            t = L.r[x];</span><br><span class="line">            L.r[x] = L.r[j];</span><br><span class="line">            L.r[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：总比较次数为：，</li>
<li>空间复杂度：</li>
<li>稳定性：简单选择排序是稳定的排序方法</li>
</ul>
</li>
</ul>
<ol>
<li><p>树形选择排序</p>
<blockquote>
<p><strong>树形选择排序</strong>又称<strong>锦标赛排序</strong>，它是一种按照锦标赛的思想设计的选择排序方法</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>将个参赛选择完全视为完全二叉树的叶子结点，则该完全二叉树有或个结点。首先，叶子结点进行两两比较，胜出(关键字较小者胜出)的结点在在兄弟结点之间再两两比较，直至产生第一名；接下来将作为第一名的结点视为最差的，并从该结点开始，沿该结点到根路径上，依次进行各分支结点孩子之间的比较，胜出的就是第二名(因为和它比赛的均是刚刚输给第一名的结点)。这样继续下去，直到所有选手的名次排定。</p>
</li>
<li><p>步骤</p>
<ol>
<li>从底层的叶子结点开始，逐层进行兄弟间的比较，关键字较小者上升为双亲结点，直到树根为止。</li>
<li>将树的根结点输出，并将底层叶子结点中的一个值与输出结点值相同的结点设为.</li>
<li>如果输出的结点总数小于初始树的叶子结点个数，则重复步骤1；否则结束排序。</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：树的深度为，进行了次比较，</li>
<li>空间复杂度：</li>
<li>稳定性：树形选择排序是稳定的排序方法</li>
</ul>
</li>
</ul>
<ol>
<li><p>堆排序</p>
<blockquote>
<p>堆排序利用堆的特性进行排序的方法。 堆排序适用于从1000个数据中选出较小的十个数据</p>
</blockquote>
<p>堆：设有个元素的序列,当且仅当满足下述关系之一时：</p>
</li>
</ol>
<p>   其中，，分别称为小顶堆和大顶堆。</p>
<p>   根据堆的性质，它也是完全二叉树，且具有下列性质之一：</p>
<ol>
<li>每个结点的值都小于或等于其左右孩子的值，称之为<strong>小顶堆</strong></li>
<li>每个结点的值都大于或等于其左右孩子的值，称之为<strong>大顶堆</strong></li>
</ol>
<ul>
<li><p>算法思想</p>
<p>首先用待排序列的记录序列构造出一个堆，此时选出了堆中所有记录的最小者为堆顶，随后将它从堆中移走(通常是将堆顶记录和堆中最后一个记录交换)，并将剩余记录在调整成堆，这样又找出了次小的记录，依次类推，直到堆中只有一个记录位置。</p>
</li>
<li><p>步骤</p>
<ol>
<li>i=1，基于顺序表中的元素先建一个小顶堆</li>
<li>将堆顶元素和交换</li>
<li>，若，则再对进行调整，形成新的小顶堆，执行2； 若，则排序结束</li>
</ol>
</li>
</ul>
<pre><code> &gt; 图片的内容没有过关联，只是在网上找的图片示例，便于理解堆排序的过程。

 堆的创建：(按照二叉树顺序放好，对第一个有孩子的结点进行比较)
</code></pre><ul>
<li><p>语言描述</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//堆的建立</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void HeapAdjust(SqList &amp;L, int s, int m) //对顺序表做查找，从值最小的孩子结点向下筛选，找到最小值</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int rc = L.r[s];</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int j = 2 * s; j &lt;= m; j *= 2)</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (j &lt; m &amp;&amp; L.r[j] &gt;= L.r[j + 1])</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j++;</span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (rc &lt; L.r[j])</span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break;</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.r[s] = L.r[j];</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = j;</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.r[s] = rc;</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//完整的堆排序</span><br></pre></td></tr></table></figure>
<p>17</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void HeapSort(SqList &amp;L) //对顺序表L进行堆排序</span><br></pre></td></tr></table></figure>
<p>18</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>19</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int value;</span><br></pre></td></tr></table></figure>
<p>20</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br></pre></td></tr></table></figure>
<p>21</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (i = L.length / 2; i &gt; 0; i--) //把L.r[1...L.length]调整为小顶堆</span><br></pre></td></tr></table></figure>
<p>22</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HeapAdjust(L, i, L.length);</span><br></pre></td></tr></table></figure>
<p>23</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (i = L.length; i &gt; 1; i--)</span><br></pre></td></tr></table></figure>
<p>24</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>25</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = L.r[1];</span><br></pre></td></tr></table></figure>
<p>26</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.r[1] = L.r[i];</span><br></pre></td></tr></table></figure>
<p>27</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.r[i] = value;</span><br></pre></td></tr></table></figure>
<p>28</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HeapAdjust(L, 1, i - 1);</span><br></pre></td></tr></table></figure>
<p>29</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>30</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：建堆需要，每次取完顶堆进行调整需要的时间为，且过程经过次，总的时间复杂度：</li>
<li>空间复杂度：</li>
<li>稳定性：不稳定的排序方法</li>
</ul>
</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><strong>归并排序</strong>是借助归并进行排序的方法。</p>
<p>归并的含义：将两个或两个以上的有序序列归并成一个有序序列的过程。</p>
<p>归并排序按所合并的表的个数分为：二路归并排序和多路归并排序</p>
<ul>
<li><p>二路归并排序</p>
<ul>
<li><p>算法思想</p>
<p>将待排序的个元素看成是个有序的子序列，每个子序列的长度为1，然后两两归并，得到个长度为2或1(最后一个有序序列长度可能为1)的有序子序列；再两两归并，得到个长度为4或小于4(最后一个有序序列长度可能小于4)的有序子序列;再两两归并，直至得到一个长度为的有序序列</p>
</li>
<li><p>步骤</p>
<ol>
<li>将待排序序列划分为两个长度相当的子序列</li>
<li>若子序列长度大于1，则对子序列执行一次归并排序</li>
<li>执行下列步骤对子序列两两合并成有序序列<ol>
<li>创建一个辅助数组。假设两个子列的长度分别为，两个子列的下标为。设置两个子表的起始下标和辅助数组的起始下标：</li>
<li>若h或，说明其中一个子表已经合并完毕，直接执行3.4</li>
<li>选取和中关键字较小的存入辅助数组:若，则否则，返回执行3.2</li>
<li>尚未处理完的子表元素与此存入，结束合并，并将结果返回。</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>语言描述</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//一趟归并排序</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Merge(int *SR, int *TR, int i, int m, int n)</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int j, k;</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (j = m + 1, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++) //将SR中的记录由大到小并入TR</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (SR[i] &lt;= SR[j])</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TR[k] = SR[i++];</span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TR[k] = SR[j++];</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>17</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (i &lt;= m) //将剩余的SR[i...m]赋值到TR</span><br></pre></td></tr></table></figure>
<p>18</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>19</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int a = i; a &lt;= m; a++)</span><br></pre></td></tr></table></figure>
<p>20</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>21</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TR[k++] = SR[a];</span><br></pre></td></tr></table></figure>
<p>22</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>23</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>24</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (j &lt;= n) //将剩余的SR[j...n]赋值到TR</span><br></pre></td></tr></table></figure>
<p>25</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>26</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int b = j; b &lt;= n; b++)</span><br></pre></td></tr></table></figure>
<p>27</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>28</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TR[k++] = SR[b];</span><br></pre></td></tr></table></figure>
<p>29</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>30</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>31</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>32</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//归并排序递归算法</span><br></pre></td></tr></table></figure>
<p>33</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void MergeSort(int *SR, int *TR1, int s, int t)</span><br></pre></td></tr></table></figure>
<p>34</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>35</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int TR2[100];</span><br></pre></td></tr></table></figure>
<p>36</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int m;</span><br></pre></td></tr></table></figure>
<p>37</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (s == t)</span><br></pre></td></tr></table></figure>
<p>38</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>39</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TR1[s] = SR[s];</span><br></pre></td></tr></table></figure>
<p>40</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>41</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else</span><br></pre></td></tr></table></figure>
<p>42</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>43</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = (s + t) / 2;</span><br></pre></td></tr></table></figure>
<p>44</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MergeSort(SR, TR2, s, m);</span><br></pre></td></tr></table></figure>
<p>45</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MergeSort(SR, TR2, m+1, t);</span><br></pre></td></tr></table></figure>
<p>46</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Merge(TR2,TR1,s,m,t);</span><br></pre></td></tr></table></figure>
<p>47</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>48</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：</li>
<li>空间复杂度：</li>
<li>稳定性：归并排序是稳定的排序算法</li>
</ul>
</li>
<li><p>Ex:{49,38,65,97,76,13,27}</p>
<ol>
<li>看成一个关键字的子序列</li>
<li>第一趟两两归并：{38,49}，{65,97}，{13,76}，{27}</li>
<li>第二趟：{38,49,65,97},{13,27,79}</li>
<li>第三趟：13,27,38,49,95,76,97</li>
</ol>
</li>
</ul>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><strong>基数排序</strong>不利用关键字之间的比较和移动操作来进行排序，而是通过多关键字排序的思想，根据关键字每个位上的有效数字的取值，借助分配和收集两种操作对单关键字进行排序。</p>
<ol>
<li><p>多关键字的排序</p>
<blockquote>
<p><strong>多关键字排序</strong>是应用在多关键字的序列上的排序方法，最常见的多关键字序列的排序方法是<strong>最低优先法</strong></p>
</blockquote>
<ul>
<li><p>最低优先法的算法思想</p>
<p>首先按照最低位进行排序，再对高一位关键字进行排序，一次类推直到所有关键字都排序完毕。</p>
</li>
<li><p>Example</p>
<p>代表性的例子就是扑克牌的排序。可以将扑克牌的52张牌按花色和值分成两个关键字，其关系如下：</p>
<ul>
<li>花色：梅花方块红桃黑桃</li>
<li>值： 且花色的关键字等级高于值关键字。 花色相同时，才根据值确定大小。</li>
</ul>
</li>
</ul>
</li>
<li><p>链式基数排序</p>
<blockquote>
<p>对于单关键字的序列，也可以通过将关键字拆分成若干项，每一项都看作是一个新的关键字，则可以利用上述多关键字排序的方法对单关键字的序列进行排序。如对于一个2位的整数，可以将其按照位数拆分为2项。这样拆分后，每个关键字的范围都相同，这样关键字可以出现的符号个数称为”基”,例如，二进制数的基是2，十进制数的基是10。基于这样的设定，可以通过多关键字排序的方法方便地进行单关键字序列排序。</p>
</blockquote>
<p>链式基数排序：采用单链表作为分配的”容器”.</p>
<ul>
<li><p>步骤</p>
<ol>
<li>建立待排序序列的静态链表和分配记录用的若干个单链表</li>
<li>从最低位关键字开始，按关键字将中记录分配到各个单链表中</li>
<li>按照关键字的值从小到大从各个单链表中收集记录到静态链表中，重复Step2直至排序完成。</li>
</ol>
</li>
<li><p>Example</p>
<p>例如：给定8个2位的十进制数序列：49,39,65,97,76,13,27,69，采用链式基数排序的过程如下。</p>
</li>
</ul>
</li>
</ol>
<pre><code> 方法：设置若干桶，因十进制分别有数字：，因此其基为10。设置十个桶，分别用进行标识。排序分两步：位数字相同的数放入同一个桶。

 1. 分配：将右起第位数字相同的数放入同一桶。比如数字为1者(若位数不同则左边补0),将其看成01，放入桶。其余类推
 2. 收集：按的顺序进行收集。 重复1,2从最右位直到最左位共2次。
</code></pre><ul>
<li><p>语言描述</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RADIX 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ArrType[RADIX];</span><br><span class="line">ArrType f, e;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLCell</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *keys; <span class="comment">//关键字</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SLCell *SList;</span><br><span class="line">    <span class="keyword">int</span> keynum; <span class="comment">//记录当前关键字个数</span></span><br><span class="line">    <span class="keyword">int</span> recnum; <span class="comment">//记录当前静态链表的长度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Distrbute</span><span class="params">(SLCell *r, <span class="keyword">int</span> i, ArrType &amp;f, ArrType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; RADIX; j++)</span><br><span class="line">        f[j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = r[<span class="number">0</span>].next; a; a = r[a].next)</span><br><span class="line">    &#123;</span><br><span class="line">        j = r[a].keys[i];</span><br><span class="line">        <span class="keyword">if</span> (!f[j])</span><br><span class="line">            f[j] = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r[e[j]].next = a;</span><br><span class="line">        e[j] = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//收集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Collect</span><span class="params">(SLCell *r, <span class="keyword">int</span> i, ArrType &amp;f, ArrType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; !f[j]; j++)</span><br><span class="line">        ;             <span class="comment">//找到第一个非空子集</span></span><br><span class="line">    r[<span class="number">0</span>].next = f[j]; <span class="comment">//r[0].next 指向第一个非空子表中第一个结点</span></span><br><span class="line">    <span class="keyword">int</span> t = e[j];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; RADIX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j++; j &lt; RADIX - <span class="number">1</span> &amp;&amp; !f[j]; j++)</span><br><span class="line">            ; <span class="comment">//找下一个非空子集</span></span><br><span class="line">        <span class="keyword">if</span> (f[j])</span><br><span class="line">        &#123;</span><br><span class="line">            r[t].next = f[j];</span><br><span class="line">            t = e[j]; <span class="comment">//链接两个非空子表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r[t].next = <span class="number">0</span>; <span class="comment">//t指向最后一个非空子表的左后一个结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(SLList &amp;SL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = SL.keynum; i &gt;= <span class="number">1</span>; i--) <span class="comment">//按最高位优先依次对各关键字进行分配收集</span></span><br><span class="line">    &#123;</span><br><span class="line">        Distrbute(SL.SList, i, f, e); <span class="comment">//第i趟分散</span></span><br><span class="line">        Collect(SL.SList, i, f, e);   <span class="comment">//第i趟收集</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：设待排序列有个记录，个关键字，每个关键字的取值范围(基)为,进行一趟分配的时间复杂度为，一趟收集的时间复杂度为，总共要进行趟分配和收集，因此链式基数排序的时间复杂度为</li>
<li>空间复杂度：链式基数排序需要个指向队列的辅助空间，且需要个用于静态链表的指针，因此空间复杂度</li>
<li>稳定性：链式基数排序是稳定的排序方法</li>
</ul>
</li>
</ul>
<h3 id="各种内部排序方法的比较"><a href="#各种内部排序方法的比较" class="headerlink" title="各种内部排序方法的比较"></a>各种内部排序方法的比较</h3><ol>
<li>快速排序、堆排序、归并排序的平均时间复杂度最好。</li>
<li>直接插入排序思路明了、算法简单，是一种常用的排序算法。</li>
<li>基数排序的时间复杂度为，因此党待排序列的记录数量很大且关键字长度很小时，其时间性能好。</li>
<li>从空间复杂度上看，大多数排序算法的辅助空间为。但快速排序和归并排序例外，分别为和。而基数排序的空间复杂度和关键字的数量和基有关。</li>
<li>从稳定性上讲，属于稳定性算法的有直接插入排序、简单选择排序、归并排序和基数排序，属于不稳定排序算法的有希尔排序、快速排序和堆排序。</li>
<li>从算法本身的复杂度上看，直接插入排序、简单选择排序比较容易理解，属于简单算法，其时间性能理论上较差；而另一类像希尔排序、快速排序、堆排序和归并排序这样较为复杂的算法，属于改进算法，时间性能理论上较好。</li>
<li>从待排记录个数来看，当越小，采用简单排序算法更为合适，当很大时，采用改进算法更为合适。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>排序算法</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>平均情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>希尔排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>快速排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>简单选择排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>堆排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>归并排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基数排序</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><blockquote>
<p>对于一个规模为n的问题，若问题比较容易解决(比如规模n较小)，则直接解决，否则将该问题分割为k个规模较小的子问题，这些子问题互相独立且与原问题的形式相同，递归的解决这些子问题，然后将各个子问题的解合并到原问题的解，这就是分治法。</p>
</blockquote>
<ul>
<li><p>基本思想</p>
<p>“分治”就是“分而治之”，即将一个难以解决的大问题分割成若干个规模较小的子问题，以便各个击破，分而治之。</p>
<p>分治法是很多算法的基础，如快速排序、归并排序等排序算法，以及傅里叶变换。</p>
</li>
</ul>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><blockquote>
<p><strong>回溯法</strong>可以系统地搜索问题的所有解，是一个具有系统性和跳跃性的算法。</p>
</blockquote>
<p>如搜索问题和优化问题，它们的解分布在一个<strong>解空间</strong>里，求解这些问题的算法就是一种遍历搜索解空间的系统方法，所以解空间又称为<strong>搜索空间</strong>。</p>
<p>回溯法将搜索空间看成树形结构，一个问题的解对应树中的一个叶子结点。</p>
<ul>
<li>基本思想<ul>
<li>回溯法在问题的解空间中，按照深度优先策略，从根结点出发搜索解空间树。</li>
<li>算法搜索至解空间的任一结点，先判断该结点是否包含问题的解。<ul>
<li>如果不包含，则跳过对该结点为根的子树的搜索，逐层向其祖先结点回溯；</li>
<li>否则，进入该子树，继续进行深度优先策略搜索。</li>
</ul>
</li>
<li>回溯法求问题的所有解时，要回溯到根结点，且根结点所有子树都被搜索完才算结束。</li>
</ul>
</li>
</ul>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><blockquote>
<p><strong>贪心算法</strong>是一种通用的算法设计方法，在许多<strong>最优化问题</strong>求解中得到了广泛应用，例如求图的最小生成树的Prim算法和Kruskal算法，单源最短路径的Dijkstra算法，数据压缩的Huffman算法</p>
</blockquote>
<p>贪心算法和动态规划算法一样，常用于求解最优化问题，即量的最大化或最小化。</p>
<ul>
<li><p>基本思想</p>
<p>贪心算法的求解是一个多步决策的过程，每步决策不考虑子问题的计算结果，而是经过少量的计算，根据当前情况做出取舍，这样一步步地构筑解，每一步均建立在局部最优解的基础上，同时又扩大了局部解的规模。</p>
<p>贪心选择：每一个选择都是当前状态下局部的最好选择</p>
</li>
<li><p>贪心算法的性质</p>
<p>贪心算法求解问题，一般具有两个性质：贪心选择性质和最优子结构性质</p>
<ul>
<li><p>贪心选择性质</p>
<p>贪心选择性质是指所求问题的整体最优解可以通过一系列的局部最优的选择(贪心选择)来达到，它采用自顶向下的方式将所求问题简化为规模更小的子问题。</p>
</li>
<li><p>最优子结构性质</p>
<p>当一个问题的最优解包括其子问题的最优解时，称此问题具有最优子结构性质</p>
</li>
</ul>
</li>
</ul>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><blockquote>
<p>动态规划：是一种将问题实例分解为更小的、相似的子问题，并存储子问题的解而避免重复计算的子问题，以解决最优化问题的算法策略。</p>
</blockquote>
<ul>
<li><p>基本思想</p>
<p>与分治法类似，将带求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适用于动态规划求解的问题，经分割得到的子问题往往不是互相独立的。若用分治法解决这些问题，分割的子问题数目太多，以致最后解决原问题需要耗费的指数时间。</p>
<p>在使用分治法求解时，有些子问题被重复计算多次。若保存已解决的子问题的答案，在需要时找出已求出的答案，可以避免大量重复计算，从而得到多项式时间的算法，这就是动态规划的基本思想。</p>
</li>
<li><p>设计步骤</p>
<ol>
<li>找出最优解的性质，并刻画其结构特征</li>
<li>递归的定义最优值</li>
<li>自底向上的方式计算得出最优值</li>
<li>根据计算最优值时得到的信息构造最优解</li>
</ol>
<p>步骤1-3是动态规划算法的基本步骤。</p>
<p>若只需求出最优值，则步骤4可以省略。 若需求出问题的最优解，则必须执行步骤4，此时，在步骤3中计算最优值，通常需要记录更多的信息，以便在步骤4中，能够根据记录的信息快速构造出最优解。</p>
</li>
</ul>
<p>动态规划算法解决的问题需要一定条件：最优化原理(最优子结构性质)和子问题的重叠性。</p>
<ul>
<li><p>条件</p>
<ul>
<li><p>最优化原理(最优子结构性质)</p>
<p>一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理称起具有最优子结构性质。</p>
</li>
<li><p>子问题的重叠性</p>
<p>对于重复出现的子问题，只在第一次遇到时加以求解，并把答案保存起来，让以后再遇到时直接引用，不必重新求解。</p>
</li>
</ul>
</li>
</ul>
<h3 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h3><blockquote>
<p><strong>分支限界法</strong>类似回溯法，都是在解空间树上搜索问题的解，也可以看做是回溯法的改进。回溯法是在整个状态空间树中搜索解，并用约束条件判断搜索过程，一旦发生不可能产生问题的不分解，就终止对相应子树的搜索，从而避免不必要的工作。</p>
</blockquote>
<p>分支限界法和回溯在两个方法存在差异：控制条件和搜索方式</p>
<ul>
<li><p>控制条件</p>
<p>回溯法一般使用约束条件产生部分解。若满足约束条件，则继续扩大解；否则丢弃，重新搜索。 分支限界法中，除了使用约束函数外，还使用更有效的评判函数——目标函数控制搜索进行，从而能够尽快得到最优解。</p>
</li>
<li><p>搜索方式</p>
<p>回溯法中的搜索一般是以深度优先的方式进行，而分支限界法中一般以广度优先方式进行搜索。</p>
</li>
<li><p>基本思想</p>
<p>略</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/DTW动态时间调整/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongxian Gu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/19640280?s=40&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dongxian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/26/DTW动态时间调整/" class="post-title-link" itemprop="url">动态时间调整</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-26 15:52:11" itemprop="dateCreated datePublished" datetime="2019-11-26T15:52:11+08:00">2019-11-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-28 11:08:45" itemprop="dateModified" datetime="2019-11-28T11:08:45+08:00">2019-11-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构和算法/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="动态时间调整"><a href="#动态时间调整" class="headerlink" title="动态时间调整"></a>动态时间调整</h1><blockquote>
<p><code>DTW</code>能够衡量这两个序列的相似程度，或者说两个序列的距离。同时<code>DTW</code>能够对两个序列的延展或者压缩能够有一定的适应性，举个例子，不同人对同一个词语的发音会有细微的差别，特别在时长上，有些人的发音会比标准的发音或长或短，<code>DTW</code>对这种序列的延展和压缩不敏感，所以给定标准语音库，<code>DTW</code>能够很好得识别单个字词，这也是为什么<code>DTW</code>一直被认为是语音处理方面的专门算法。实际上，<code>DTW</code>虽然老，但简单且灵活地实现模板匹配，能解决很多离散时间序列匹配的问题，视频动作识别，生物信息比对等等诸多领域都有应用。</p>
</blockquote>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ol>
<li>根据给定样本序列和比对序列，计算序列点之间的欧式距离，生成序列距离矩阵。</li>
<li>根据距离矩阵生成损失矩阵（累积距离矩阵）<ol>
<li>第一行第一列元素为 距离矩阵的第一行第一列元素；</li>
<li>其他位置的元素 $(M_c(i,j)M_c(i,j))$的值则需要逐步计算，具体值的计算方法为 $M_c(i,j)=M(i,j)+\min(M_c(i−1,j−1),M_c(i−1,j),M_c(i,j−1))$。</li>
<li>两个序列的距离为损失矩阵最后一行最后一列给出。</li>
</ol>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态时间调整</span></span><br><span class="line">X = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">1</span>]</span><br><span class="line">Y = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">n, m = len(X), len(Y)</span><br><span class="line"></span><br><span class="line">matrix = [[<span class="number">0</span>]*m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">        matrix[i][j] = abs(X[i]-Y[j])</span><br><span class="line">        </span><br><span class="line">mat_coss = [[<span class="number">0</span>]*m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    mat_coss[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">    mat_coss[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">        mat_coss[i][j] = matrix[i][j] + min(mat_coss[i<span class="number">-1</span>][j<span class="number">-1</span>],mat_coss[i<span class="number">-1</span>][j],mat_coss[i][j<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">print(<span class="string">f'X和Y之间的距离为:<span class="subst">&#123;mat_coss[n<span class="number">-1</span>][m<span class="number">-1</span>]&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/编辑距离算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongxian Gu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/19640280?s=40&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dongxian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/26/编辑距离算法/" class="post-title-link" itemprop="url">编辑距离算法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-26 15:20:51" itemprop="dateCreated datePublished" datetime="2019-11-26T15:20:51+08:00">2019-11-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-28 11:09:09" itemprop="dateModified" datetime="2019-11-28T11:09:09+08:00">2019-11-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构和算法/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="编辑距离-Edit-Distance"><a href="#编辑距离-Edit-Distance" class="headerlink" title="编辑距离 Edit Distance"></a>编辑距离 Edit Distance</h1><blockquote>
<p>指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。又称<code>Levenshtein</code>距离</p>
</blockquote>
<p>三种基本操作：插入，删除，替换</p>
<h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><ol>
<li>A和B的长度为0返回另一个字符串的长度。</li>
<li>初始化矩阵，shape：(n+1)(m+1)，第一行和第一列从0开始增长，如果A[i]==B[j]，temp=0，否则为1.然后在矩阵<code>mat[i][j]</code>中赋值为<code>mat[i-1][j]+1,mat[i][j-1]+1,mat[i-1][j-1]+temp</code>三者中的最小值，这三个操作分别对应插入、删除、替换。</li>
</ol>
<p>3.扫描完后，返回矩阵的最后一个值<code>mat[n][m]</code>即是它们的距离。</p>
<p>相似度公式:$\frac{1-mat[n][m]}{\max(n,m)}$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>C</th>
<th>o</th>
<th>w</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>C</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>a</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>t</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑距离算法</span></span><br><span class="line">A = <span class="string">'Cat'</span></span><br><span class="line">B = <span class="string">'Cow'</span></span><br><span class="line"></span><br><span class="line">n, m = len(A)+<span class="number">1</span>, len(B)+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">matrix = [[<span class="number">0</span>]*m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    matrix[i][<span class="number">0</span>] = i</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">    matrix[<span class="number">0</span>][j] = j</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">        tmp = <span class="number">0</span> <span class="keyword">if</span> A[i<span class="number">-1</span>] == B[j<span class="number">-1</span>] <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        matrix[i][j] = min(matrix[i<span class="number">-1</span>][j]+<span class="number">1</span>, matrix[i]</span><br><span class="line">                           [j<span class="number">-1</span>]+<span class="number">1</span>, matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]+tmp)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'编辑距离:<span class="subst">&#123;matrix[n<span class="number">-1</span>][m<span class="number">-1</span>]&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'相似度:<span class="subst">&#123;<span class="number">1</span>-matrix[n<span class="number">-1</span>][m<span class="number">-1</span>]/max(n<span class="number">-1</span>,m<span class="number">-1</span>)&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://blog.csdn.net/chichoxian/article/details/53944188" target="_blank" rel="noopener">https://blog.csdn.net/chichoxian/article/details/53944188</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/DSP基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongxian Gu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/19640280?s=40&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dongxian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/26/DSP基础知识/" class="post-title-link" itemprop="url">DSP基础知识</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-26 10:53:46 / 修改时间：14:47:46" itemprop="dateCreated datePublished" datetime="2019-11-26T10:53:46+08:00">2019-11-26</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/课程/" itemprop="url" rel="index"><span itemprop="name">课程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数字信号处理"><a href="#数字信号处理" class="headerlink" title="数字信号处理"></a>数字信号处理</h1><blockquote>
<p>记录DSP的一些概念和理论知识</p>
</blockquote>
<ul>
<li><p>信号：随着时间、空间或其他自变量而变化的物理量。</p>
<p>数学描述：</p>
<script type="math/tex; mode=display">
s_1(t) = 5t \\
s_2(t)=20t^2 \\
s(x,y)=3x+2xy+10y^2</script><p>可以存在多个自变量，如表示平面空间上的坐标。</p>
<p>上面描述的信号属于一类准确定义的信号，指定了对于自变量的函数依赖关系。</p>
<p>但是有些情况下的函数关系是未知的或太复杂以至于难以使用。</p>
<p>例如，某种语音信号无法用上面的表达式函数进行描述。</p>
<p>一般来说，一段语音可被高精度的表示为几种不同幅度和频率的总和，即</p>
<script type="math/tex; mode=display">
\sum_{i=1}^N A_i(t) \sin[2\pi F_i(t)t+\theta_i(t)]</script><p>其中，$|A_i(t)|,|F_i(t)|,|\theta_i(t)|$分别是正弦信号的(可能时变的)幅度、频率和相位的集合。</p>
</li>
<li><p>生成信号：通常和某系统相关联，以对某些刺激或压力作出响应。</p>
</li>
<li><p>信号处理的含义从有用信号中对噪声和干扰信号进行滤波。</p>
</li>
<li><p>模数(A/D)转换器：模拟信号和数字处理器之间的接口，输出数字信号，作为数字处理器的输入。</p>
</li>
<li><p>数模(D/A)转换器：数字域到模拟域的接口，将信号以模拟的形式提供给用户。</p>
</li>
<li><p>数字信号处理的优点：灵活配置、精度高、存储方便、价格便宜。</p>
</li>
<li><p>数字处理的局限性：受限于A/D转换器和数字信号处理器的运算速度。</p>
</li>
<li><p>多通道信号：采用矢量表示信号。</p>
</li>
<li><p>多维信号：多个自变量的函数。单个自变量的函数称为一维信号。</p>
</li>
<li><p>连续时间信号：模拟信号，在每个时间值上有定义且在一个连续的区间内取值的信号。数学上可采用一个连续变量的函数描述。</p>
</li>
<li><p>离散时间信号：定义在某些特定的时间值上，时间点不需要是等距的，实际上为了简单和数学易于处理，通常等间隔取值。</p>
</li>
<li><p>采样：在离散时间点上选择模拟信号值。</p>
</li>
<li><p>连续值信号：信号的值是连续的。信号在一个有限或无限范围内取所有可能的值。</p>
</li>
<li><p>离散值信号：信号的值是离散的。信号只在可能取值的有限集上取值。</p>
</li>
<li><p>量化：将连续值信号转化为离散值信号的过程，基本上是一个近似过程。量化可以只通过四舍五入或截断完成。</p>
</li>
<li><p>确定性信号：任何可以被一个显式数学表达式、一个数据表或者一个定义好的规则所唯一描述的信号。强调信号的过去、现在、将来的所有取值可以准确知道，不存在任何不确定性。</p>
</li>
<li><p>随机信号：无法被数学公式显式表达到一个合理的精度或这描述太复杂以至于没有实际用处，在时间轴上以不可知的方式展开。例如噪声生成器的输出、地震信号、语音信号。</p>
</li>
<li><p>随机信号的理论分析基于概率论和随机过程。</p>
</li>
<li><p>欧拉公式：$e^{ix}=\cos x + i\sin x$，i是复数单位。</p>
</li>
<li><p>能量信号和功率信号</p>
<ul>
<li>离散时间信号$x(n)$的能量$E \equiv \sum_{n=-\infty}^\infty |x(n)|^2$</li>
<li>离散时间信号的平均功率：$P=\lim_{N \rightarrow \infty} \frac{1}{2N+1} \sum_{n=-N}^N |x(n)|^2$</li>
<li>有限区间$-N \le n \le N$内定义的信号能量$E_N= \sum_{n=-N}^N |x(n)|^2$</li>
</ul>
</li>
<li><p>周期信号和非周期信号</p>
<ul>
<li>信号$x(n)$是周期为$N(N\gt 0)$的周期信号当且仅当$x(n+N)=x(n)$</li>
</ul>
</li>
<li><p>对称(偶)和反对称(奇)信号</p>
<ul>
<li>$x(-n)=x(n)$</li>
<li>$x(-n)=-x(n)$</li>
</ul>
</li>
<li><p>因果系统和非因果系统</p>
</li>
<li><p>稳定系统与不稳定系统</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/pacman常用命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongxian Gu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/19640280?s=40&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dongxian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/26/pacman常用命令/" class="post-title-link" itemprop="url">pacman常用命令</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-26 10:19:20 / 修改时间：10:25:09" itemprop="dateCreated datePublished" datetime="2019-11-26T10:19:20+08:00">2019-11-26</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="pacman-常用命令"><a href="#pacman-常用命令" class="headerlink" title="pacman 常用命令"></a>pacman 常用命令</h1><h2 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h2><p>在 Archlinux 中，使用一条命令即可对整个系统进行更新：<br> <code>pacman -Syu</code><br> 如果你已经使用<code>pacman -Sy</code>将本地的包数据库与远程的仓库进行了同步，也可以只执行：<code>pacman -Su</code></p>
<h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><ul>
<li><code>pacman -S 包名</code>：例如，执行 <code>pacman -S firefox</code> 将安装 Firefox。你也可以同时安装多个包，只需以空格分隔包名即可。</li>
<li><code>pacman -Sy</code> 包名：与上面命令不同的是，该命令将在同步包数据库后再执行安装。</li>
<li><code>pacman -Sv 包名</code>：在显示一些操作信息后执行安装。</li>
<li><code>pacman -U</code>：安装本地包，其扩展名为 pkg.tar.gz。</li>
<li><code>pacman -U http://www.example.com/repo/example.pkg.tar.xz</code> 安装一个远程包（不在 pacman 配置的源里面）</li>
</ul>
<h2 id="删除包"><a href="#删除包" class="headerlink" title="删除包"></a>删除包</h2><ul>
<li><code>pacman -R 包名</code>：该命令将只删除包，保留其全部已经安装的依赖关系</li>
<li><code>pacman -Rs 包名</code>：在删除包的同时，删除其所有没有被其他已安装软件包使用的依赖关系</li>
<li><code>pacman -Rsc 包名</code>：在删除包的同时，删除所有依赖这个软件包的程序</li>
<li><code>pacman -Rd 包名</code>：在删除包时不检查依赖。</li>
</ul>
<h2 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h2><ul>
<li><code>pacman -Ss 关键字</code>：在仓库中搜索含关键字的包。</li>
<li><code>pacman -Qs 关键字</code>： 搜索已安装的包。</li>
<li><code>pacman -Qi 包名</code>：查看有关包的详尽信息。</li>
<li><code>pacman -Ql 包名</code>：列出该包的文件。</li>
</ul>
<h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><ul>
<li><code>pacman -Sw 包名</code>：只下载包，不安装。</li>
<li><code>pacman -Sc</code>：清理未安装的包文件，包文件位于 <code>/var/cache/pacman/pkg/</code> 目录。</li>
<li><code>pacman -Scc</code>：清理所有的缓存文件。</li>
</ul>
<h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h2><ul>
<li><a href="https://www.jianshu.com/p/ea651cdc5530" target="_blank" rel="noopener">https://www.jianshu.com/p/ea651cdc5530</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/25/基础机器学习公式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongxian Gu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/19640280?s=40&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dongxian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/基础机器学习公式/" class="post-title-link" itemprop="url">基础机器学习公式</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 12:36:41 / 修改时间：12:41:38" itemprop="dateCreated datePublished" datetime="2019-11-25T12:36:41+08:00">2019-11-25</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="机器学习-Formula"><a href="#机器学习-Formula" class="headerlink" title="机器学习 Formula"></a>机器学习 Formula</h1><h2 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h2><ol>
<li><p>The Least Mean Square (<strong>LMS</strong>) Algorithm</p>
<script type="math/tex; mode=display">
h_\theta(x) = \sum_{i=1}^{n}\theta_i x_i = \theta^T xParameters</script><ul>
<li>Parameters <script type="math/tex; mode=display">
\theta</script></li>
</ul>
</li>
</ol>
<ul>
<li>Cost function</li>
</ul>
<script type="math/tex; mode=display">
   \begin{split}
   J_l(\theta) & = \frac{1}{2} \sum_{i=1}^{m} (h_\theta(x^{(i)})-y^{(i)})^2 \\
   & = \frac{1}{2} \sum_{i=1}^{m} (\theta^T x^{(i)}-y^{(i)})^2
   \end{split}</script><ul>
<li>Goal</li>
</ul>
<script type="math/tex; mode=display">
   \theta^*=arg_\theta \; minJ_l(\theta)</script><ol>
<li><p>Close-form Solution of LMS</p>
<script type="math/tex; mode=display">
J_l(\theta) = \frac{1}{2} \sum_{i=1}^{m} (h_\theta(x^{(i)})-y^{(i)})^2 = \frac{1}{2}(X\theta - y)^T(X\theta - y)</script><script type="math/tex; mode=display">
\begin{split}
\nabla_\theta J(\theta) &= \nabla_\theta \frac{1}{2} (X\theta - y)^T(X\theta - y)\\
& = \frac{1}{2} \nabla_\theta (\theta^TX^TX\theta - \theta^TX^Ty - y^TX\theta + y^Ty) \\
& = \frac{1}{2} \nabla_\theta tr(\theta^TX^TX\theta - \theta^TX^Ty - y^TX\theta + y^Ty) \\
& = \frac{1}{2} \nabla_\theta (tr\theta^TX^TX\theta - 2tr\theta^TX\theta) \\
& = X^TX\theta - X^Ty
\end{split}</script><script type="math/tex; mode=display">
\theta^* = (X^TX)^{-1}X^Ty</script></li>
<li><p>Gradient Descent for Linear Regression</p>
<ul>
<li>Gradient<script type="math/tex; mode=display">
\begin{split}
\frac{\partial J_l(\theta)}{\partial \theta} & = \frac{1}{2}\frac{\partial}{\partial \theta}\sum_{i=1}^{n} (h_\theta (x^{(i)}) - y^{(i)})^2 \\
& = \frac{1}{2} 2 \sum_{i=1}^n (h_\theta (x^{(i)}) - y^{(i)}) \frac{\partial}{\partial \theta}(h_\theta (x^{(i)}) - y^{(i)}) \\
& = \sum_{i=1}^n (h_\theta (x^{(i)}) - y^{(i)}) \frac{\partial}{\partial \theta}(\theta^T x^{(i)}) \\
& = \sum_{i=1}^n (h_\theta (x^{(i)}) - y^{(i)})x^{(i)}
\end{split}</script></li>
</ul>
</li>
</ol>
<ul>
<li>Gradient Descent (GD) Optimization<script type="math/tex; mode=display">
   \theta: = \theta - \alpha\frac{\partial}{\partial \theta} J_l(\theta) = \theta - \alpha \sum_{i=1}^n (h_\theta (x^{(i)}) - y^{(i)})x^{(i)}</script></li>
</ul>
<h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><ul>
<li><p>Sigmoid Function:</p>
<script type="math/tex; mode=display">
\begin{split}
& \delta(z) = \frac{1}{1+e^{-z}} \\
& \frac{d\delta}{dz} = \delta(z)(1-\delta(z))
\end{split}</script></li>
<li><p>Hypothesis</p>
<script type="math/tex; mode=display">
\begin{split}
& p(y=1 | x;\theta) = h_\theta(x) = \delta(\theta^Tx) = \frac{1}{1+e^{-\theta^Tx}} \\
& p(y=0 | x;\theta) = 1 - h_\theta(x)
\end{split}</script><p>or</p>
<script type="math/tex; mode=display">
p(y|x;\theta) = (h_\theta(x))^y(1-h_\theta(x))^{1-y} = (\frac{1}{1+e^{-\theta^Tx}})^y(1-\frac{1}{1+e^{-\theta^Tx}})^{1-y}</script></li>
<li><p>Conditional Likelihood Function</p>
<script type="math/tex; mode=display">
\begin{split}
L(\theta) & = \prod_{i=1}^N p(y^{(i)}|x^{(i)};\theta)\\
& = \prod_{i=1}^N (h_\theta(x^{(i)}))^{y^{(i)}}(1-h_\theta(x^{(i)}))^{(1-y)^{(i)}} \\
& = \prod_{i=1}^N (\frac{1}{1+e^{-\theta^Tx^{(i)}}})^{y^{(i)}}(1-\frac{1}{1+e^{-\theta^Tx^{(i)}}})^{(1-y)^{(i)}}
\end{split}</script></li>
<li><p>Maximum Likelihood Estimation</p>
<script type="math/tex; mode=display">
\max_{\theta} L(\theta) \Leftrightarrow = \max_{\theta} \sum_{i=1}^{n}y^{(i)}\log{}{h_\theta(x^{(i)}) + (1-y^{(i)})\log{}{}}1-h_\theta(x^{(i)})</script><blockquote>
<p> The neg log-likelihood function is also known as the <strong>Cross-Entropy</strong> cost function</p>
</blockquote>
</li>
<li><p>Unconstraint Optimization Methods</p>
<ul>
<li>Gradient Descent</li>
</ul>
</li>
<li><p>Stochastic Gradient Descent</p>
<ul>
<li>Newtom Method</li>
</ul>
</li>
<li><p>Quasi-Newtom Method</p>
<ul>
<li>Conjugate Gradient</li>
</ul>
</li>
<li>waiting….</li>
</ul>
<h2 id="Softmax-Regression"><a href="#Softmax-Regression" class="headerlink" title="Softmax Regression"></a>Softmax Regression</h2><ul>
<li>Softmax Regression is a multi-class classification model, also called Multi-class Logistic Regression;</li>
<li>It is also known as the Maximum Entropy Model (in NLP);</li>
<li>It is one of the most used classification algorithms</li>
</ul>
<h3 id="Model-Description"><a href="#Model-Description" class="headerlink" title="Model Description"></a>Model Description</h3><ul>
<li><p>Model Hypothesis</p>
<script type="math/tex; mode=display">
\begin{split}
& p(y=j|x;\theta) = h_j(x) = \frac{e^{\theta_j^Tx}}{1+\sum_{j^{'}=1}^{c-1}e^{\theta_{j^{'}}^Tx}}, j=1,\dots,C-1 \\
& p(y=C|x;\theta) = h_C(x) = \frac{1}{1+\sum_{j^{'}=1}^{c-1}e^{\theta_{j^{'}}^Tx}}
\end{split}</script></li>
<li><p>Model Hypothesis (Compact Form)</p>
<script type="math/tex; mode=display">
p(y=j|x;\theta) = h_j(x) = \frac{e^{\theta_j^Tx}}{\sum_{j^{'}=1}^{c-1}e^{\theta_{j^{'}}^Tx}}, j=1,\dots,C \quad where \; \theta_C =  \vec{0}</script></li>
<li><p>Parameters</p>
<script type="math/tex; mode=display">
\theta_{C \times M}</script></li>
</ul>
<h3 id="Maximun-Likelihood-Estimation"><a href="#Maximun-Likelihood-Estimation" class="headerlink" title="Maximun Likelihood Estimation"></a>Maximun Likelihood Estimation</h3><p>(Conditional) Log-likelihood</p>
<script type="math/tex; mode=display">
\begin{split}
l(\theta) & = \sum_{i=1}^N \log{p(y^{(i)}|x^{(i)};\theta)} \\
& = \sum_{i=1}^N \log \prod_{j=1}^C \big(\frac{e^{\theta_j^Tx}}{\sum_{j^{'}=1}^{C}e^{\theta_{j^{'}}^Tx}}\big)^{1\{y^{(i)}=j\}} \\
& = \sum_{i=1}^{N}\sum_{j=1}^{C}\bold{1}\{y^{(i)}=j\}\log \big(\frac{e^{\theta_j^Tx}}{\sum_{j^{'}=1}^{C}e^{\theta_{j^{'}}^Tx}}\big)\\
& = \sum_{i=1}^{N}\sum_{j=1}^{C}\bold{1}\{y^{(i)}=j\}\log h_j(x^{(i)})
\end{split}</script>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://avatars3.githubusercontent.com/u/19640280?s=40&v=4" alt="Dongxian Gu">
            
              <p class="site-author-name" itemprop="name">Dongxian Gu</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiangsu,Dongxian Gu</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  



  




  

  

  
  

  
  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      document.getElementById(all[i].inputID + '-Frame').parentNode.className += ' has-jax';
    }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
