<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Life,Happy,Code">
<meta property="og:type" content="website">
<meta property="og:title" content="Summer So Cold">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Summer So Cold">
<meta property="og:description" content="Life,Happy,Code">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="DongxianGu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Summer So Cold</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Summer So Cold</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/25/ManjaroLinux%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DongxianGu">
      <meta itemprop="description" content="Life,Happy,Code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Summer So Cold">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/25/ManjaroLinux%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">ManjaroLinux启动问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-25 15:26:16 / 修改时间：15:35:06" itemprop="dateCreated datePublished" datetime="2020-03-25T15:26:16+08:00">2020-03-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">技能</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/03/25/ManjaroLinux%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/03/25/ManjaroLinux%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ManjaroLinux启动问题"><a href="#ManjaroLinux启动问题" class="headerlink" title="ManjaroLinux启动问题"></a>ManjaroLinux启动问题</h1><p>今早无意中更新系统失败，导致无法开机，提示无法找到linux内核模块。通过采取了一系列方式终于挽救了系统。</p>
<ul>
<li>一个使用较新版本Manjaro Linux的liveUSB</li>
<li>待修复设备需要联网环境</li>
</ul>
<p>通过liveUSB启动：</p>
<p>由于原先系统的文件保存在硬盘上，故liveUSB不会自动挂载硬盘，手动挂载硬盘到对应位置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/manjaro</span><br><span class="line">sudo mount /dev/sda2 /mnt/manjaro <span class="comment"># sda2为/分区所在设备，可以使用lsblk查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#由于原来系统采用UEFI安装，分了一个分区作为引导分区，所以引导分区也要挂载对应位置，否则无法安装内核</span></span><br><span class="line">sudo mount /dev/sda1 /mnt/manjaro/boot/efi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于系统的虚拟目录，比如`/dev`和`/sys`,也需要手动绑定，，否则chroot后运行pacman会出错：</span></span><br><span class="line"></span><br><span class="line">sudo mount --<span class="built_in">bind</span> /dev /mnt/manjaro/dev</span><br><span class="line">sudo mount --<span class="built_in">bind</span> /proc /mnt/manjaro/proc</span><br><span class="line">sudo mount --<span class="built_in">bind</span> /sys /mnt/manjaro/sys</span><br></pre></td></tr></table></figure>
<p>在上面操作完成之后，系统文件以及准备好了，下面切换根目录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/manjaro</span><br><span class="line">chroot .</span><br><span class="line">pacman -S linux <span class="comment"># 如果这一步报错，检查自己系统目录是否正确挂载，如果正确挂载则先运行pacman -S archlinux-keyring</span></span><br><span class="line"><span class="comment"># 内核重装完成后继续上次未完成的系统更新</span></span><br><span class="line">pacman -Syu</span><br></pre></td></tr></table></figure>
<p>思考：</p>
<p>对于这种方式应该可以用到其他系统，当系统因为某种原因启动失败，可以通过U盘进行启动系统进行修复。</p>
<p>参考来源：<a href="https://www.cnblogs.com/apocelipes/p/10192882.html" target="_blank" rel="noopener">https://www.cnblogs.com/apocelipes/p/10192882.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/24/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DongxianGu">
      <meta itemprop="description" content="Life,Happy,Code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Summer So Cold">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/24/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">时间复杂度计算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-24 09:03:35 / 修改时间：09:13:38" itemprop="dateCreated datePublished" datetime="2020-03-24T09:03:35+08:00">2020-03-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/03/24/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/03/24/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="时间复杂度计算"><a href="#时间复杂度计算" class="headerlink" title="时间复杂度计算"></a>时间复杂度计算</h1><p>复杂度分析是用于评估算法执行效率的方法。</p>
<p>事后统计法：通过将代码进行运行、监控等得到算法执行事件和占用的内存大小。存在非常大的局限性</p>
<ul>
<li>测试结果依赖测试环境</li>
<li>测试结果受数据规模的影响很大</li>
</ul>
<p><strong>不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法</strong>。这就是<strong>时间、空间复杂度</strong>分析方法。</p>
<p>大 O 复杂度表示法</p>
<p>所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。</p>
<script type="math/tex; mode=display">
T(n)=O(f(n))</script><p>T(n) 我们已经讲过了，它表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。这就是<strong>大 O 时间复杂度表示法</strong>。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是<strong>表示代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。</p>
<p>时间复杂度分析的方法：</p>
<ol>
<li>只关注循环次数最多的一段代码</li>
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/21/Word2Vec%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DongxianGu">
      <meta itemprop="description" content="Life,Happy,Code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Summer So Cold">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/21/Word2Vec%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Word2Vec原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-21 10:33:32" itemprop="dateCreated datePublished" datetime="2020-03-21T10:33:32+08:00">2020-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-03 08:28:56" itemprop="dateModified" datetime="2020-05-03T08:28:56+08:00">2020-05-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NLP/" itemprop="url" rel="index"><span itemprop="name">NLP</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/03/21/Word2Vec%E5%8E%9F%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/03/21/Word2Vec%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h1><blockquote>
<p>word2vec 是 google 在 2013 年推出的一个 NLP 工具，它的特点是将所有的词向量化，这样词与词之间就可以定量的去度量他们之间的关系，挖掘词之间的联系。</p>
<p>因此本文的讲解 word2vec 原理以 Github 上的 <a href="https://github.com/tmikolov/word2vec" target="_blank" rel="noopener">word2vec</a> 代码为准。本文关注于 word2vec 的基础知识。</p>
</blockquote>
<h2 id="词向量基础"><a href="#词向量基础" class="headerlink" title="词向量基础"></a>词向量基础</h2><p>词向量来表示词并不是Word2Vec的首创，很久之前就提出了。最早的词向量相当的冗长，词向量维度大小为整个词汇表的大小，对于每个具体词汇表中词，将对应的位置置为1。这就是One-hot编码表示。</p>
<p>One-hot representation 表示词向量是非常简单的，但存在很多问题。最大的问题就是一般词汇表非常的大，比如百万级别，那么每个词都得用百万维度的向量来表示，这对内存来说简直是个灾难。而且只有一个位置为1,其余为0，表达的效率不高。因此如何将词向量的维度变小？</p>
<p>Distributed representation 就是为了解决 one hot representation的问题而提出的。它的思想就是通过训练，将每个词映射到一个较短的词向量来。所有的词向量就构成了向量空间，进而可以使用统计学的方法来研究词与词之间的关系。但是这个较短的词向量维度多大呢？这个一般需要我们在训练时自己来指定。</p>
<p>通过Distributed Representation表示较短的词向量，就可以很容易来分析词之间的关系。</p>
<p>如果将词的维度降到2维，用下图的词向量表示我们的词的时候，可以发现：</p>
<script type="math/tex; mode=display">
\overrightarrow{King}-\overrightarrow{Man}+\overrightarrow{Woman} = \overrightarrow{Queen}</script><p><img src="/images/word2vec/distribute-representation-demo1.png" alt="distribute-representation-demo1"></p>
<p>可见，只要得到词汇表中所有词对应的词向量，就可以做很多的事情。</p>
<p>但是如何训练得到合适的词向量？常见的方法就是使用神经网络语言模型。</p>
<h2 id="CBOW-amp-Skip-Gram-用于-NNLM-Neural-Network-Language-Model"><a href="#CBOW-amp-Skip-Gram-用于-NNLM-Neural-Network-Language-Model" class="headerlink" title="CBOW &amp; Skip-Gram 用于 NNLM(Neural Network Language Model)"></a>CBOW &amp; Skip-Gram 用于 NNLM(Neural Network Language Model)</h2><p>在word2vec提出之前，以及使用神经网络DNN来训练词向量进而处理词与词之间的关系。一般的方法是一个三层的神经网络结构（当然也可以是多层），分为：输入层、隐藏层和输出层（softmax层）。</p>
<p>这种模型的输入和输出一般采用CBOW(Continuous Bag-of-Words)与Skip-Gram来定义。</p>
<p>CBOW模型</p>
<ul>
<li>输入：特征词的上下文相关的词对应的词向量</li>
<li>输出：特征词的对应词向量</li>
</ul>
<p>比如这样一段话：<code>..an efficent method for learning high qualitu distributed vector...</code>。假设上下文大小取值为4，特定的词是”learning”，也就是我们需要输出词向量，上下文对应的词有8个，前后各4个，这8个词就是模型的输入。</p>
<p><img src="/images/word2vec/CBOW-example1.png" alt="CBOW-example1"></p>
<p>因为CBOW采用的是词袋模型，因此这8个词的地位是相同的，不考虑它们和我们关注的词之间的距离，只要在上下文之内即可。</p>
<p>在上面的例子中，输入是8个词向量，输出是所有词的softmax概率，训练目标是期望训练样本特定词对应的softmax概率最大。</p>
<p>Skip-Gram模型：和CBOW的思路刚好相反：</p>
<ul>
<li>输入：特定的一个词的词向量</li>
<li>输出：特定词对应的上下文词向量。</li>
</ul>
<p>同样以上面的例子，输入是特定词，输出是softmax概率排前8的8个词。</p>
<p>问题：word2vec没有使用DNN模型，为了解决DNN模型处理耗时长。因为词汇表非常大，意味值输出层需要进行softmx计算各个词的输出概率的计算了很大。</p>
<h2 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h2><p>霍夫曼树的建立其实并不难，过程如下：</p>
<p>　　　　输入：权值为(w1,w2,…wn)(w1,w2,…wn)的nn个节点</p>
<p>　　　　输出：对应的霍夫曼树</p>
<p>　　　　1）将(w1,w2,…wn)(w1,w2,…wn)看做是有nn棵树的森林，每个树仅有一个节点。</p>
<p>　　　　2）在森林中选择根节点权值最小的两棵树进行合并，得到一个新的树，这两颗树分布作为新树的左右子树。新树的根节点权重为左右子树的根节点权重之和。</p>
<p>　　　　3） 将之前的根节点权值最小的两棵树从森林删除，并把新树加入森林。</p>
<p>　　　　4）重复步骤 2）和 3）直到森林里只有一棵树为止。</p>
<p>Huffman树的优点？</p>
<p>当得到霍夫曼树后，我们对叶子节点进行霍夫曼编码，权重高的叶子节点越靠近根节点，而权重低的叶子节点则会原理根节点，这就导致这样一个结果：高权重节点编码值较短，低权重节点编码值较长。</p>
<p>确保了树的带权路径最短，也符合信息论。</p>
<p>在word2vec中，约定编码方式和常规不同，约定左子树编码为1,右子树编码为0,同时约定左子树的权重大于右子树的权重。</p>
<h2 id="基于Hierarchical-Softmax-的模型概述"><a href="#基于Hierarchical-Softmax-的模型概述" class="headerlink" title="基于Hierarchical Softmax 的模型概述"></a>基于Hierarchical Softmax 的模型概述</h2><p>word2vec在传统的神经网络词向量语言模型上做了改进：</p>
<ul>
<li>输入层到隐藏层的映射，没有采取神经网络的线性变换加激活函数的方法，而是采用了简单的对所有输入词向量求和并求取平均的方法。比如输入的是三个4维词向量：(1,2,3,4),(9,6,11,8),(5,10,7,12)(1,2,3,4),(9,6,11,8),(5,10,7,12),那么我们word2vec映射后的词向量就是(5,6,7,8)(5,6,7,8)。由于这里是从多个词向量变成了一个词向量。</li>
<li>隐藏层到输出的softmax层的计算量进行了改进，巍峨哦了避免计算所有词的softmax概率，word2vec采用了霍夫曼树来替代隐藏层到输出层的softmax层映射。</li>
</ul>
<p>由于之前要将输出softmax层的概率变成了一颗二叉霍夫曼树，那么我们的概率计算只要沿着树形结构计算就行了。</p>
<p>如图：我们可以沿着根节点一致走到我们的叶子节点的词$w_2$</p>
<p><img src="/images/word2vec/huffman-demo.png" alt="huffman-demo"></p>
<p>类比之前的NNLM，霍夫曼树的内部节点就类似之前的神经网络隐藏层的神经元，其中，根节点的词向量就对应我们投影后的词向量，而所有叶子节点就类似softmax输出层的神经元。叶子节点的个数就是词汇表的大小。</p>
<p>在霍夫曼树中，隐藏层到输出层的softmax映射不是一步完成的，而是沿着霍夫曼树一步步的完成的，因此，这种softmax被称为<code>Hierarchical Softmax</code>。</p>
<p>沿着霍夫曼树具体是如何操作？</p>
<p>在word2vec中，采用了二元logistic regression的方法，规定沿着左子树走，就是负类（霍夫曼编码为1），沿着右子树走，就是正类（霍夫曼树编码0）。判别正类和负类的方法就是使用sigmoid函数，即：</p>
<script type="math/tex; mode=display">
P(+) = \sigma(x_w^T\theta)=\frac{1}{1+e^{-x_w^T\theta}}</script><p>其中$x_w$就是当前内部节点的词向量，而$\theta$就是就是我们需要从训练样本得到的logistic regression的模型参数。</p>
<p>霍夫曼树的好处？</p>
<ul>
<li>由于是二叉树，之前的计算量是$V$，现在变成了$\log_2 V$。</li>
<li>高频词靠近词根，则高频词能够被更快的找到。符合贪心优化的思想。</li>
</ul>
<p>容易得到，被划分为左子树而成为负类的概率为$P(-)=1-P(+)$。在某个内部节点，判断沿左子树还是右子树走的依据就是看$P(-)$,$P(+)$谁的概率大。而控制两者概率大小的因素就是当前节点的<strong>词向量</strong>，另一个是当前节点的模型参数$\theta$。</p>
<p>对于上图的$w_2$，如果它是训练样本的输出，那么我们就期望对于隐藏节点$n(w_2,1)$的$P(-)$概率大，$n(w_2,2)$的$P(-)$概率大，$n(w_2,3)$的$P(+)$概率大。</p>
<h2 id="基于Hierarchical-Softmax-的模型梯度计算"><a href="#基于Hierarchical-Softmax-的模型梯度计算" class="headerlink" title="基于Hierarchical Softmax 的模型梯度计算"></a>基于Hierarchical Softmax 的模型梯度计算</h2><p>通过使用最大似然法来寻找所有节点的词向量和所有内部节点$\theta$。以上述的$w_2$为例，我们希望期望最大化下面的似然函数：</p>
<script type="math/tex; mode=display">
\prod_{i=1}^3P(n(w_2,i))=(1-\frac{1}{1+e^{-x_{w_2}^T\theta_1}})(1-\frac{1}{1+e^{-x_{w_2}^T\theta_2}})\frac{1}{1+e^{-x_{w_2}^T\theta_3}}</script><p>对于所有的训练样本，期望最大化所有样本的似然函数乘积。</p>
<p>为了简化描述，定义输入的词为$w$，其输入层词向量求和平均后的霍夫曼树的根节点词向量为$x_w$，从根节点到$w$所在的叶子节点，包含的节点总数为$l_w$，$w$在霍夫曼树中从根节点开始，经过的第$i$个节点表示为$p_i^w$，对应的霍夫曼编码为$d_i^w \in {0,1}$，其中$i=2,3,\cdots,l_w$。而该节点对应的模型参数表示为$\theta_i^w$，其中$i=1,2,\cdots,l_w-1$，没有$i=l_w$因为模型参数针对霍夫曼树的内部节点。</p>
<p>定义：$w$经过霍夫曼树某个节点$j$的逻辑回归概率为$P(d<em>j^w|x_w,\theta</em>{j-1}^w)$，其表达式为：</p>
<script type="math/tex; mode=display">
P(d_j^w|x_w,\theta_{j-1}^w) =
\begin{cases}
\sigma(x_w^T \theta_{j-1}^w) &d_j^w=0 \\
1- \sigma(x_w^T \theta_{j-1}^w) &d_j^w = 1
\end{cases}</script><p>对于某个目标输出词$w$，其最大似然为：</p>
<script type="math/tex; mode=display">
\prod_{j=2}^{l_w}P(d_j^w|x_w, \theta_{j-1}^w) = \prod_{j=2}^{l_w} [\sigma(x_w^T\theta_{j-1}^w)] ^{1-d_j^w}[1-\sigma(x_w^T\theta_{j-1}^w)]^{d_j^w}</script><p>由于word2vec中，使用SGD，并没有将所有样本的似然乘起来得到真正训练集最大似然，每次仅用一个样本更新，这样可以减少梯度计算量。</p>
<p>对应的对数似然函数$L$为：</p>
<script type="math/tex; mode=display">
L= log \prod_{j=2}^{l_w}P(d_j^w|x_w, \theta_{j-1}^w) = \sum\limits_{j=2}^{l_w} ((1-d_j^w) log [\sigma(x_w^T\theta_{j-1}^w)]  + d_j^w log[1-\sigma(x_w^T\theta_{j-1}^w)])</script><p>要得到模型中$w$的词向量和内部节点的模型参数$\theta$，可以使用梯度上升法。首先我们可以求模型参数$\theta_{j-1}^w$的梯度：</p>
<script type="math/tex; mode=display">
\begin{align} \frac{\partial L}{\partial \theta_{j-1}^w} & = (1-d_j^w)\frac{(\sigma(x_w^T\theta_{j-1}^w)(1-\sigma(x_w^T\theta_{j-1}^w)}{\sigma(x_w^T\theta_{j-1}^w)}x_w - d_j^w \frac{(\sigma(x_w^T\theta_{j-1}^w)(1-\sigma(x_w^T\theta_{j-1}^w)}{1- \sigma(x_w^T\theta_{j-1}^w)}x_w  \\ & =  (1-d_j^w)(1-\sigma(x_w^T\theta_{j-1}^w))x_w -  d_j^w\sigma(x_w^T\theta_{j-1}^w)x_w \\& = (1-d_j^w-\sigma(x_w^T\theta_{j-1}^w))x_w \end{align}</script><p>同样的方法，可以求得$x_w$的梯度表达式：</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial x_w} = \sum\limits_{j=2}^{l_w}(1-d_j^w-\sigma(x_w^T\theta_{j-1}^w))\theta_{j-1}^w</script><h2 id="基于Hierarchical-Softmax的CBOW模型"><a href="#基于Hierarchical-Softmax的CBOW模型" class="headerlink" title="基于Hierarchical Softmax的CBOW模型"></a>基于Hierarchical Softmax的CBOW模型</h2><p>首先定义词向量的维度大小$M$，以及CBOW的上下文大小2c。这样对于训练样本中的每一个词，前面和后面的c个词作为CBOW模型的输入，该词本身作为样本的输出，期望softmax概率最大。</p>
<p>在使用CBOW模型之前，将词汇表建立成一棵霍夫曼树</p>
<p>第一步：从输入层到隐藏层（投影层）:</p>
<script type="math/tex; mode=display">
x_w=\frac{1}{2c}\sum\limits_{i=1}^{2c} x_i</script><p>第二部，通过梯度上升法来更新我们的$\theta_{j-1}^w$和$x_w$。虽然这边的$x_w$是由2c个词向量相加而成，梯度更新完毕后直接用梯度项更新原始的各个$x_i(i=1,2,\cdots,2c)$，即：</p>
<script type="math/tex; mode=display">
\theta_{j-1}^w = \theta_{j-1}^w + \eta  (1-d_j^w-\sigma(x_w^T\theta_{j-1}^w))x_w</script><script type="math/tex; mode=display">
x_i= x_i +\eta  \sum\limits_{j=2}^{l_w}(1-d_j^w-\sigma(x_w^T\theta_{j-1}^w))\theta_{j-1}^w \;(i =1,2..,2c)</script><p>其中$\eta$是梯度上升的步长。</p>
<p>整个算法流程如下：</p>
<p>输入：基于CBOW的语料训练样本，词向量的维度大小$M$，CBOW的上下文大小$2c$,步长$\eta$</p>
<p>输出：霍夫曼树的内部节点模型参数$\theta$，所有的词向量$w$</p>
<ol>
<li><p>基于语料训练样本建立霍夫曼树</p>
</li>
<li><p>随机初始化所有模型参数$\theta$，所有的词向量$w$</p>
</li>
<li><p>进行梯度上升迭代过程，对于训练中的每个样本$(context(w),w)$进行如下步骤：</p>
<ol>
<li><p>$e=0$，计算$x<em>w=\frac{1}{2c}\sum</em>{i=1}^{2c}x_i$</p>
</li>
<li><p>$for\;j=2\;to\;l_w$计算：</p>
<script type="math/tex; mode=display">
\begin{align}
f=\sigma(x_w^T\theta_{j-1}^w) \\
g=(1-d_j^w-f)\eta \\
e = e + g\theta_{j-1}^w \\
\theta_{j-1}^w = \theta_{j-1}^w + gx_w
\end{align}</script></li>
</ol>
</li>
</ol>
<ol>
<li>对于$context(w)$中的每个词向量$x_i$进行更新：<script type="math/tex; mode=display">
x_i=x_i+e</script></li>
</ol>
<ol>
<li>如果梯度收敛，则结束梯度迭代，否则回到步骤3继续迭代。</li>
</ol>
<h2 id="基于Hierarchical-Softmax-的-Skip-Gram模型"><a href="#基于Hierarchical-Softmax-的-Skip-Gram模型" class="headerlink" title="基于Hierarchical Softmax 的 Skip-Gram模型"></a>基于Hierarchical Softmax 的 Skip-Gram模型</h2><p>此时输入为一个词$w$，输出的为$2c$个词向量$context(w)$。</p>
<p>对于训练样本中的每一个词，该词本身作为样本的输入，其前面和后面的$c$个词作为Skip-Gram模型的输出，期望这些词的softmax概率比其他的词大。</p>
<p>首先，将词汇表建立乘一棵霍夫曼树</p>
<p>对于输入层到隐藏层（投影层），由于只有一个词，所以$x_w$就是词$w$对应的词向量。</p>
<p>然后，通过梯度上升法来更新我们的$\theta_{j-1}$和$x_w$。</p>
<p>注意：这里的$x_w$周围有$2c$个词向量，如果我们期望$P(x_i|x_w),i=1,2,\cdots,2c$最大。我们可以注意到由于上下文是相互的，在期望$P(x_i|x_w),i=1,2,\cdots,2c$最大化的同时，反过来我们也期望$P(x_w|x_i),i=1,2,\cdots,2c$最大。那么这两种究竟是那个更好呢？</p>
<p>word2vec使用了后者，这样的做的优点，在一个迭代窗口内，我们不只是更新$x_w$一个词，而是$x_i,i=1,2,\cdots,2c$个词。这样整个迭代会更加均衡。因此，Skip-Gram没有和CBOW一样对输入进行迭代更新，而是对$2c$个输出进行迭代更新。</p>
<p>Hierarchical Softmax的缺点：当训练样本中的一个中心词$w$是一个很生僻的词，那么就需要在霍夫曼树往下走很久了。</p>
<h2 id="基于Negative-Sampling的模型概述"><a href="#基于Negative-Sampling的模型概述" class="headerlink" title="基于Negative Sampling的模型概述"></a>基于Negative Sampling的模型概述</h2><p>Negative Sampling （负采样）</p>
<p>假设有一个训练样本，中心词是$w$，它的周围上下文共有$2c$个词，记为$context(w)$。由于这个中心词$w$，和$context(w)$相关存在，因此它是一个真实的正例。</p>
<p>通过Negative Sampling采样，可以得到neg个和$w$不同的中心词$w_i,i=1,2,\cdots,neg$，这样$context(w)$和$w_i$就组成neg并不真实存在的负例。利用这个正例和neg个负例进行二元logistic regression。得到负采样对应每个词$w_i$对应的模型参数$\theta_i$和每个词的词向量。</p>
<p>两个问题：</p>
<ul>
<li>如何通过一个正例和neg个负例进行二元logistic regression</li>
<li>如何进行负采样</li>
</ul>
<h2 id="基于Negative-Sampling-的模型梯度计算"><a href="#基于Negative-Sampling-的模型梯度计算" class="headerlink" title="基于Negative Sampling 的模型梯度计算"></a>基于Negative Sampling 的模型梯度计算</h2><p>Negative Sampling 也是采用了二元逻辑回归来求解参数。</p>
<p>通过负采样得到neg个负例$(context(w),w_i)i=1,2,\cdots,neg$。</p>
<p>将正例定义为$w_0$。</p>
<p>在期望回归中，正例应该期望满足：</p>
<script type="math/tex; mode=display">
P(context(w_0), w_i) = \sigma(x_{w_0}^T\theta^{w_i}) ,y_i=1, i=0</script><p>负例期望满足：</p>
<script type="math/tex; mode=display">
P(context(w_0), w_i) =1-  \sigma(x_{w_0}^T\theta^{w_i}), y_i = 0, i=1,2,..neg</script><p>因此可以期望最大化下式：</p>
<script type="math/tex; mode=display">
\prod_{i=0}^{neg}P(context(w_0), w_i) = \sigma(x_{w_0}^T\theta^{w_0})\prod_{i=1}^{neg}(1-  \sigma(x_{w_0}^T\theta^{w_i}))</script><p>相应的对数似然函数为：</p>
<script type="math/tex; mode=display">
L = \sum\limits_{i=0}^{neg}y_i log(\sigma(x_{w_0}^T\theta^{w_i})) + (1-y_i) log(1-  \sigma(x_{w_0}^T\theta^{w_i}))</script><p>和Hierarchical Sofrmax类似，采用SGD，这里我们需要求出$x_{w_0},\theta^{w_i},i=0,1,2,\cdots,neg$的梯度。</p>
<p>计算$\theta^{w_i}$的梯度：</p>
<script type="math/tex; mode=display">
\begin{align} \frac{\partial L}{\partial \theta^{w_i} } &= y_i(1-  \sigma(x_{w_0}^T\theta^{w_i}))x_{w_0}-(1-y_i)\sigma(x_{w_0}^T\theta^{w_i})x_{w_0} \\ & = (y_i -\sigma(x_{w_0}^T\theta^{w_i})) x_{w_0} \end{align}</script><p>对应的$x_{w_0}$的梯度：</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial x^{w_0} } = \sum\limits_{i=0}^{neg}(y_i -\sigma(x_{w_0}^T\theta^{w_i}))\theta^{w_i}</script><h2 id="Negative-Sampling负采样方法"><a href="#Negative-Sampling负采样方法" class="headerlink" title="Negative Sampling负采样方法"></a>Negative Sampling负采样方法</h2><p>如果词汇表的大小为$V$，那么将一段长度为1的线段分成$V$份，每份对应词汇表中的一个词。当然每个词对应的线段长度是不一样的，高频词对应的线段长，低频词对应的线段短。每个词$w$的线段长度由下决定：</p>
<script type="math/tex; mode=display">
len(w) = \frac{count(w)}{\sum\limits_{u \in vocab} count(u)}</script><p>在word2vec中，分子分母取了$3/4$次幂:</p>
<script type="math/tex; mode=display">
len(w) = \frac{count(w)^{3/4}}{\sum\limits_{u \in vocab} count(u)^{3/4}}</script><p>采样前，将长度为1的线段划分乘$M$等份，$M&gt;&gt;V$，这样就可以确保每个词对应的线段都会划分成对应的小块。而$M$份中的每一份都会落到某一个词对应的线段上。采样的时候，只需要从$M$个位置中采样出neg个位置，此时采样到的每个位置对应的线段所属的词就是我们的负例词。</p>
<p>word2vec中，$M=10^8$</p>
<h2 id="基于Negative-Sampling-的CBOW模型"><a href="#基于Negative-Sampling-的CBOW模型" class="headerlink" title="基于Negative Sampling 的CBOW模型"></a>基于Negative Sampling 的CBOW模型</h2><p>输入：基于CBOW的语料训练样本，词向量维度大小为$M$，CBOW的上下文大小$2c$，步长为$\eta$，负采样的个数$neg$</p>
<p>输出：词汇表中每个词对应的模型参数$\theta$，所有的词向量$x_w$</p>
<ol>
<li><p>随机初始化所有模型参数$\theta$，所有的词向量$w$</p>
</li>
<li><p>对于每个训练样本$(context(w_0),w_0)$，负采样出neg个负例中心词$w_i,i=1,2,\cdots,neg$</p>
</li>
<li><p>进行梯度上升迭代过程，对于训练集中的每个样本$(context(w<em>0),w_0,w_1,\cdots,w</em>{neg})$做如下处理</p>
<ol>
<li><p>$e=0$，计算$x<em>{w_0}=\frac{1}{2c}\sum\limits</em>{i=1}^{2c}x_i$</p>
</li>
<li><p>$for\;i=0\;to\;neg$，计算：</p>
<script type="math/tex; mode=display">
\begin{align}
f=\sigma(x_{w_0}^T\theta^{w_i})\\
g=(y_i-f)\eta \\
e=e+g\theta^{w_i} \\
\theta^{w_i} = \theta^{w_i} + gx_{w_0}
\end{align}</script></li>
</ol>
</li>
</ol>
<ol>
<li>对于$context(w)$中的每个词向量$x_k$（2c个）进行更新：<script type="math/tex; mode=display">
x_k = x_k +e</script></li>
</ol>
<ol>
<li>如果梯度收敛，则结束迭代，否则回到步骤3继续迭代。</li>
</ol>
<h2 id="基于Negative-Sampling-Skip-Gram模型"><a href="#基于Negative-Sampling-Skip-Gram模型" class="headerlink" title="基于Negative Sampling Skip-Gram模型"></a>基于Negative Sampling Skip-Gram模型</h2><p>输入：基于Skip-Gram的语料训练样本，词向量的维度大小$Mcount$，Skip-Gram的上下文大小$2c$,步长$\eta$， , 负采样的个数neg。</p>
<p>输出：词汇表每个词对应的模型参数$\theta$，所有的词向量$x_w$</p>
<ol>
<li><p>随机初始化所有的模型参数θθ，所有的词向量$w$</p>
</li>
<li><p>对于每个训练样本$(context(w_0),w_0)$，负采样出neg个负例中心词$w_i,i=1,2,…neg$</p>
</li>
<li><p>进行梯度上升迭代过程，对于训练集中的每一个样本$(context(w<em>0),w_0,w_1,…w</em>{neg})$做如下处理：</p>
<ol>
<li><p>$for\;i=1\;to\;2c:$</p>
<ol>
<li><p>$e=0$</p>
</li>
<li><p>$for\;j=0\;to\;neg$，计算：</p>
<script type="math/tex; mode=display">
\begin{align}
f=\sigma(x_{w_{0i}}^T\theta^{w_j})\\
g=(y_j-f)\eta \\
e =e + g\theta^{w_j} \\
\theta^{w_j} = \theta^{w_j} + gx_{w_{0i}}
\end{align}</script></li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>     3. 词向量更新：
        $$
        x_{w_{0i}} = x_{w_{0i}} + e
        $$

　2. 如果梯度收敛，则结束迭代，否则继续步骤3.
</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/18/vue%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DongxianGu">
      <meta itemprop="description" content="Life,Happy,Code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Summer So Cold">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/18/vue%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">vue组件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-18 20:24:11" itemprop="dateCreated datePublished" datetime="2020-03-18T20:24:11+08:00">2020-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-22 16:45:44" itemprop="dateModified" datetime="2020-03-22T16:45:44+08:00">2020-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/03/18/vue%E7%BB%84%E4%BB%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/03/18/vue%E7%BB%84%E4%BB%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vue组件"><a href="#Vue组件" class="headerlink" title="　Vue组件"></a>　Vue组件</h1><h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><h3 id="组件名"><a href="#组件名" class="headerlink" title="组件名"></a>组件名</h3><p>在注册组件的时候，始终需要提供一个名字。</p>
<blockquote>
<p>当直接在DOM中使用一个组件（而不是字符串模板或<a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">单文件组件</a>) 的时候，强烈推荐遵循 <a href="https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name" target="_blank" rel="noopener">W3C 规范</a>中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。</p>
</blockquote>
<p>组件名大小写</p>
<p>定义组件名的两种方式</p>
<ul>
<li><p>kebab-case</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component-name'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>当使用kebab-case定义一个组件时，在引用这个自定义元素时使用kebab-case，比如<code>&lt;my-component-name&gt;</code></p>
</li>
<li><p>PascalCase</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'MyComponentName'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>当使用PascalCase定义组件时，引用这个自定义元素时，两种命名法都可以使用。即<code>&lt;my-component-name&gt;</code>和<code>&lt;MyComponentName&gt;</code>都是可接受的。</p>
<p>注意：直接在DOM中使用时只有kebab-case是有效的。</p>
</li>
</ul>
<h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><p>比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component-name'</span>, &#123;</span><br><span class="line">    <span class="comment">// ...options...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样就是<strong>全局注册</strong>的。也就是在全局注册之后就可以用在任何新创建的Vue Root Instance(<code>new Vue</code>)的模板中。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'component-a'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line">Vue.component(<span class="string">'component-b'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line">Vue.component(<span class="string">'component-c'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">'#app'</span> &#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-a</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-b</span>&gt;</span><span class="tag">&lt;/<span class="name">component-b</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-c</span>&gt;</span><span class="tag">&lt;/<span class="name">component-c</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在所有的子组件中也是如此，也就是说这三个组件内部也是可以互相使用。</p>
<h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>全局注册往往是不合理的。当在类似webpack这样的构建系统，全局注册所有组件意味着即便不在使用某个组件，但它仍然被包含在最终的构建结构中，这就造成JS无谓的增加。</p>
<p>在这些情况下，可以使用一个normal 的 JavaScript对象来定义组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentC = &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>然后在Vue根实例中通过<code>components</code>选项来定义想要使用的组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'component-a'</span>: ComponentA,</span><br><span class="line">    <span class="string">'component-b'</span>: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>对于<code>components</code>对象中的每个属性来说，其属性名就是自定义元素的名字，其属性值就是组件的选项对象。</p>
<p>注意：<strong>局部注册的组件在其子组件中不可使用</strong>。</p>
<p>如果想要在<code>ComponentA</code>在<code>ComponentB</code>中使用，需要这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'component-a'</span>: ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者如果通过Babel和webpack使用ES2015模块，代码应该这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">'./ComponentA.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在 ES2015+ 中，在对象中放一个类似 <code>ComponentA</code> 的变量名其实是 <code>ComponentA: ComponentA</code> 的缩写，即这个变量名同时是：</p>
<ul>
<li>用在模板中的自定义元素的名称</li>
<li>包含了这个组件选项的变量名</li>
</ul>
<h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3><blockquote>
<p>如果你还在阅读，说明你使用了诸如 Babel 和 webpack 的模块系统。在这些情况下，我们推荐创建一个 <code>components</code> 目录，并将每个组件放置在其各自的文件中。</p>
</blockquote>
<ol>
<li><p>在模块系统中局部注册</p>
<p>在局部注册之前导入每个想要使用的组件。例如在一个假设的<code>ComponentB.js</code>或<code>ComponentB.vue</code>文件中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">'./ComponentA'</span></span><br><span class="line"><span class="keyword">import</span> ComponentC <span class="keyword">from</span> <span class="string">'./ComponentC'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA,</span><br><span class="line">    ComponentC</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样 <code>ComponentA</code> 和 <code>ComponentC</code> 都可以在 <code>ComponentB</code> 的模板中使用了。</p>
</li>
<li><p>基础组件的自动化全局注册</p>
<blockquote>
<p>可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为<a href="https://cn.vuejs.org/v2/style-guide/#基础组件名-强烈推荐" target="_blank" rel="noopener">基础组件</a>，它们会在各个组件中被频繁的用到。</p>
</blockquote>
<p>采用上述的局部注册会导致很多组件都会有一个包含基础组件的长列表。这会导致重复代码并且很难管理。</p>
<p>如果使用了webpack（或者在内部使用了webpack的<a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">Vue CLI 3+</a>），那么可以使用<code>require.context</code>来全局注册一些非常通用的基础组件。</p>
<p>下面是一份可以让我们在应用入口文件（比如：<code>src/main.js</code>）中全局导入基础组件的示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> upperFirst <span class="keyword">from</span> <span class="string">'lodash/upperFirst'</span></span><br><span class="line"><span class="keyword">import</span> camelCase <span class="keyword">from</span> <span class="string">'lodash/camelCase'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">  <span class="comment">// 其组件目录的相对路径</span></span><br><span class="line">  <span class="string">'./components'</span>,</span><br><span class="line">  <span class="comment">// 是否查询其子目录</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 匹配基础组件文件名的正则表达式</span></span><br><span class="line">  /Base[A-Z]\w+\.(vue|js)$/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取组件配置</span></span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取组件的 PascalCase 命名</span></span><br><span class="line">  <span class="keyword">const</span> componentName = upperFirst(</span><br><span class="line">    camelCase(</span><br><span class="line">      <span class="comment">// 获取和目录深度无关的文件名</span></span><br><span class="line">      fileName</span><br><span class="line">        .split(<span class="string">'/'</span>)</span><br><span class="line">        .pop()</span><br><span class="line">        .replace(<span class="regexp">/\.\w+$/</span>, <span class="string">''</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册组件</span></span><br><span class="line">  Vue.component(</span><br><span class="line">    componentName,</span><br><span class="line">    <span class="comment">// 如果这个组件选项是通过 `export default` 导出的，</span></span><br><span class="line">    <span class="comment">// 那么就会优先使用 `.default`，</span></span><br><span class="line">    <span class="comment">// 否则回退到使用模块的根。</span></span><br><span class="line">    componentConfig.default || componentConfig</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>全局注册的行为必须在根Vue实例创建之前发生。</p>
<p><a href="https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js" target="_blank" rel="noopener">这里</a>有一个真实项目情景下的示例。</p>
<h2 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h2><h3 id="Prop的大小写-camelCase-versus-kebab-case"><a href="#Prop的大小写-camelCase-versus-kebab-case" class="headerlink" title="Prop的大小写 (camelCase versus kebab-case)"></a>Prop的大小写 (camelCase versus kebab-case)</h3><p>HTML中的attribute名是大小写不敏感的，因此Browers会把所有的大写字符解释为小写字符。</p>
<p>因此，当使用DOM中的模板时，camelCase的prop名需要使用其等价的kebab-case命名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  <span class="comment">// 在 JavaScript 中是 camelCase 的</span></span><br><span class="line">  props: [<span class="string">'postTitle'</span>],</span><br><span class="line">  template: <span class="string">'&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">post-title</span>=<span class="string">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：如果使用字符串模板，就没有这个限制。</p>
<h3 id="Prop类型"><a href="#Prop类型" class="headerlink" title="Prop类型"></a>Prop类型</h3><p>到目前为止，我们只是用字符串数组形式列出prop。</p>
<p>但是，通常需要对每个prop指定值类型，这个时候需要使用对象形式列出prop。这些属性的名称和值分别是prop各自的名称和类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span>,</span><br><span class="line">  isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">  commentIds: <span class="built_in">Array</span>,</span><br><span class="line">  author: <span class="built_in">Object</span>,</span><br><span class="line">  callback: <span class="built_in">Function</span>,</span><br><span class="line">  contactsPromise: <span class="built_in">Promise</span> <span class="comment">// or any other constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户。你会在这个页面接下来的部分看到<a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-验证" target="_blank" rel="noopener">类型检查和其它 prop 验证</a>。</p>
</blockquote>
<h3 id="传送静态或动态Prop"><a href="#传送静态或动态Prop" class="headerlink" title="传送静态或动态Prop"></a>传送静态或动态Prop</h3><p>传递静态值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"My journey with Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以通过<code>v-bind</code>指令来动态传值，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 动态赋予一个变量的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:title</span>=<span class="string">"post.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态赋予一个复杂表达式的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">"post.title + ' by ' + post.author.name"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>传入一个数字</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:likes</span>=<span class="string">"42"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:likes</span>=<span class="string">"post.likes"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>传入一个布尔值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">is-published</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:is-published</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:is-published</span>=<span class="string">"post.isPublished"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>传入一个数组</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:comment-ids</span>=<span class="string">"[234, 266, 273]"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:comment-ids</span>=<span class="string">"post.commentIds"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>传入一个对象</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:author</span>=<span class="string">"&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">    name: 'Veronica',</span></span></span><br><span class="line"><span class="tag"><span class="string">    company: 'Veridian Dynamics'</span></span></span><br><span class="line"><span class="tag"><span class="string">  &#125;"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:author</span>=<span class="string">"post.author"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>传入一个对象所有的属性</p>
<p>如果想要将一个对象的所有属性都作为prop传入，可以使用不带参数的<code>v-bind</code>（取代<code>v-bind:prop-name</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post: &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    title: <span class="string">'My Journey with Vue'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">"post"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​        ===</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:id</span>=<span class="string">"post.id"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">"post.title"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>所有的prop使得父子prop之间形成了一个<strong>单向下行绑定</strong>：父级prop的更新会向下流动到子组件中，但反过来则不行。这样防止了子组件意外改变父级组件的状态，从而导致数据流向难以理解。</p>
<p>另外，每次父级组件发生更新，子组件中所有的prop都会刷新。</p>
<p>这表明不应该在子组件内部改变prop。</p>
<p>下面是两种常见的试图改变一个prop的情况</p>
<ol>
<li><p>prop用来传递初始值；子组件希望将其作为一个本地的prop数据来使用。在这种情况下，最好定一个本地的data属性并将这个prop用作其初始值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        counter: <span class="keyword">this</span>.initialCounter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>prop以一种原始的值传入且需要转换。这种情况，最好使用这个prop值来定义一个计算属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'size'</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">    normalizedSize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：JavaScript中对象和数组是通过引用传入的，所以对数组或对象类型的prop来说，在子组件中改变这个对象或数组会影响父组件的状态。</p>
<h3 id="Prop验证"><a href="#Prop验证" class="headerlink" title="Prop验证"></a>Prop验证</h3><p>组件中的prop可以指定验证请求，如果存在要求没有满足，则Vue会在浏览器的Console警告你。</p>
<p>为了提供对prop的验证，可以为<code>props</code>中的值提供一个带有验证请求的对象，而不是一个字符串数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'danger'</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>注意：prop会在一个组件Instance被创建<strong>之前</strong>进行验证，所以Instance的属性（如<code>data</code>、<code>computed</code>等）无法在<code>default</code>或<code>valiator</code>函数中使用。</p>
<ol>
<li><p>类型检查</p>
<p><code>type</code> 可以是下列原生构造函数中的一个：</p>
<ul>
<li><code>String</code></li>
<li><code>Number</code></li>
<li><code>Boolean</code></li>
<li><code>Array</code></li>
<li><code>Object</code></li>
<li><code>Date</code></li>
<li><code>Function</code></li>
<li><code>Symbol</code></li>
</ul>
<p>另外，<code>type</code>也可以是一个自定义的构造函数，并通过<code>instanceof</code>来进行检查确认。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    author: Person</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>来验证 <code>author</code> prop 的值是否是通过 <code>new Person</code> 创建的。</p>
</li>
</ol>
<h3 id="非Prop的Attribute"><a href="#非Prop的Attribute" class="headerlink" title="非Prop的Attribute"></a>非Prop的Attribute</h3><p>非prop的Attribute是指传向一个组件，但是该组件并没有相应的prop定义的attribute。</p>
<p>显式定义的prop适用于向一个子组件传入信息，然而组件库的author不总能预见组件被用于什么样的场景。</p>
<p>这就是为什么组件可以接受任何的attribute，而这些attribute被添加到这个组件的根元素上。</p>
<blockquote>
<p>例如，想象一下你通过一个 Bootstrap 插件使用了一个第三方的 <code>组件，这个插件需要在其</code> 上用到一个 <code>data-date-picker</code> attribute。我们可以将这个 attribute 添加到你的组件实例上：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bootstrap-date-input</span> <span class="attr">data-date-picker</span>=<span class="string">"activated"</span>&gt;</span><span class="tag">&lt;/<span class="name">bootstrap-date-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后这个 <code>data-date-picker=&quot;activated&quot;</code> attribute 就会自动添加到 <code>&lt;bootstrap-date-input&gt;</code> 的根元素上。</p>
</blockquote>
<ol>
<li><p>替换/合并已有的Attribute</p>
<p>假设<code>&lt;bootstrap-date-input&gt;</code>的模板是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'date'</span> <span class="attr">class</span>=<span class="string">'form-control'</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了给日期选择器定义一个主题，需要添加一个类名：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bootstrap-date-input</span>	</span></span><br><span class="line"><span class="tag">  <span class="attr">data-date-picker</span>=<span class="string">"activated"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"date-picker-theme-dark"</span>     &gt;</span><span class="tag">&lt;/<span class="name">bootstrap-date-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种情况下，我们定义了两个不同的<code>class</code>的值：</p>
<ul>
<li><code>form-control</code>，这是在组件的模板内设置好的</li>
<li><code>date-picker-theme-dark</code>，这是从组件的父级传入的</li>
</ul>
<p>对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 <code>type=&quot;text&quot;</code> 就会替换掉 <code>type=&quot;date&quot;</code> 并把它破坏！庆幸的是，<code>class</code> 和 <code>style</code> attribute 会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：<code>form-control date-picker-theme-dark</code>。</p>
</li>
<li><p>禁用Attribute继承</p>
<p>如果<strong>不</strong>希望组件的根元素继承attribute，则需要在组件的选项中设置<code>inheritAttrs:false</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">    inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这适合配合实例的<code>$attrs</code>属性使用，该属性包含了传递给一个组件的attribute名和attribute值，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  required: <span class="literal">true</span>,</span><br><span class="line">  placeholder: <span class="string">'Enter your username'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了 <code>inheritAttrs: false</code> 和 <code>$attrs</code>，你就可以手动决定这些 attribute 会被赋予哪个元素。在撰写<a href="https://cn.vuejs.org/v2/style-guide/#基础组件名-强烈推荐" target="_blank" rel="noopener">基础组件</a>的时候是常会用到的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-input'</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">'label'</span>, <span class="string">'value'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind="$attrs"</span></span><br><span class="line"><span class="string">        v-bind:value="value"</span></span><br><span class="line"><span class="string">        v-on:input="$emit('input', $event.target.value)"</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意：<code>inheritAttrs:false</code>选项不会影响<code>style</code>和<code>class</code>的绑定。</p>
<p>这个模式允许你在使用基础组件的时候更像是使用原始的 HTML 元素，而不会担心哪个元素是真正的根元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"username"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">required</span></span></span><br><span class="line"><span class="tag">  <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><h3 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a>事件名</h3><p>不同于组件和prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。</p>
<p>如果采用camelCase名字的事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'myEvent'</span>)</span><br></pre></td></tr></table></figure>
<p>则监听这个名字的kebab-case版本是不会有任何效果的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-on:my-event</span>=<span class="string">"doSomething"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不同于组件和prop，事件名不会被用作一个JavaScrip变量名或属性名，所以就没有理由使用camelCase和PascalCase了。并且<code>v-on</code>事件监听器在DOM模板中会被自动转换成全小写（因为HTML是大小写不敏感的），所以<code>v-on:myEvent</code>会变成<code>v-on:myevent</code>而导致<code>myEvent</code>不可能被监听到。</p>
<p>因此，推荐<strong>始终使用kebab-case</strong>的事件名</p>
<h3 id="自定义组件的v-model"><a href="#自定义组件的v-model" class="headerlink" title="自定义组件的v-model"></a>自定义组件的<code>v-model</code></h3><p>一个组件上的<code>v-model</code>会默认利用名为<code>value</code>的prop和名为<code>input</code>的事件，但是单选框、复选框等类型的输入控件可能将<code>value</code>attribute用于<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value" target="_blank" rel="noopener">不同的目的</a>。<code>model</code>选项可以避免这种冲突：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-checkbox'</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">'checked'</span>,</span><br><span class="line">    event: <span class="string">'change'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type="checkbox"</span></span><br><span class="line"><span class="string">      v-bind:checked="checked"</span></span><br><span class="line"><span class="string">      v-on:change="$emit('change', $event.target.checked)"</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在在这个组件上使用<code>v-model</code>的时候：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-checkbox</span> <span class="attr">v-model</span>=<span class="string">"lovingVue"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>lovingVue</code>的值将会传入名为<code>checked</code>的prop。同时当<code>&lt;base-checkbox&gt;</code>触发一个<code>change</code>事件并附带一个新的值的时候，这个<code>lovingVue</code>属性将会被更新。</p>
<p>注意：仍然需要在组件的<code>props</code>选项中声明<code>checked</code>这个prop。</p>
<h3 id="将原生事件绑定到组件"><a href="#将原生事件绑定到组件" class="headerlink" title="将原生事件绑定到组件"></a>将原生事件绑定到组件</h3><p>假设想要在一个组件的根元素上直接监听一个原生事件。</p>
<p>这是时候可以使用<code>v-on</code>的<code>.native</code>修饰符</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">v-on:focus.native</span>=<span class="string">"onFocus"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有的时候这个是有用的。但是在监听一个类似<code>&lt;input&gt;</code>的特定元素时，这不是一个好方法。比如上面所述的<code>&lt;base-input&gt;</code>做了如下重构，所以根元素实际上是一个<code>&lt;lable&gt;</code>元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">  &#123;&#123; label &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind</span>=<span class="string">"$attrs"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:value</span>=<span class="string">"value"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:input</span>=<span class="string">"$emit('input', $event.target.value)"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个时候，父级的<code>.native</code>监听器就会静默失败。不会产生任何错误，但是<code>onFocus</code>处理函数不会如预期执行。</p>
<p>为了解决这种问题，Vue提供了<code>$listeners</code>属性，它是一个对象，包含了作用在这个组件上的所有监听器。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  focus: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  input: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>$listeners</code> 属性，配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 <code>&lt;input&gt;</code> 的你希望它也可以配合 <code>v-model</code> 工作的组件来说，为这些监听器创建一个类似下述 <code>inputListeners</code> 的计算属性通常是非常有用的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-input'</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">'label'</span>, <span class="string">'value'</span>],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    inputListeners: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span></span><br><span class="line">      <span class="comment">// `Object.assign` 将所有的对象合并为一个新对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,</span><br><span class="line">        <span class="comment">// 我们从父级添加所有的监听器</span></span><br><span class="line">        <span class="keyword">this</span>.$listeners,</span><br><span class="line">        <span class="comment">// 然后我们添加自定义监听器，</span></span><br><span class="line">        <span class="comment">// 或覆写一些监听器的行为</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 这里确保组件配合 `v-model` 的工作</span></span><br><span class="line">          input: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            vm.$emit(<span class="string">'input'</span>, event.target.value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind="$attrs"</span></span><br><span class="line"><span class="string">        v-bind:value="value"</span></span><br><span class="line"><span class="string">        v-on="inputListeners"</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注：<code>**Object.assign()**</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br></pre></td></tr></table></figure>
<p>现在 <code>&lt;base-input&gt;</code> 组件是一个<strong>完全透明的包裹器</strong>了，也就是说它可以完全像一个普通的 <code>&lt;input&gt;</code> 元素一样使用了：所有跟它相同的 attribute 和监听器都可以工作。</p>
<h3 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a><code>.sync</code>修饰符</h3><blockquote>
<p>2..3.0+ 增加</p>
</blockquote>
<p>有些情况，需要对一个prop进行“双向绑定”。但是真正的双向绑定会带来维护上的问题。因为子组件可以修改父组件，且父组件和子组件没有明显的改变来源。</p>
<p>所以Vue推荐以<code>update:myPropName</code>的模式触发事件取而代之。例如，在一个包含<code>title</code>prop的组件用，可以使用以下方法表达对其赋新值的意图：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:title'</span>, newTitle)</span><br></pre></td></tr></table></figure>
<p>然后父组件可以监听那个事件并根据需要更新一个本地的数据属性。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">"doc.title"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:update:title</span>=<span class="string">"doc.title = $event"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了方便，Vue为这种模式提供了一个缩写，即<code>.sync</code>修饰符：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind:title.sync</span>=<span class="string">"doc.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> <strong>不能</strong>和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 <code>v-model</code>。</p>
</blockquote>
<p>当用一个对象同时设置多个prop的时候，也可以将这个<code>.sync</code>修饰符和<code>v-bind</code>配合使用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind.sync</span>=<span class="string">"doc"</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样会把 <code>doc</code> 对象中的每一个属性 (如 <code>title</code>) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 <code>v-on</code> 监听器。</p>
<blockquote>
<p>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”{ title: doc.title }”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p>
</blockquote>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><blockquote>
<p>在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 <code>v-slot</code> 指令)。它取代了 <code>slot</code> 和 <code>slot-scope</code> 这两个目前已被废弃但未被移除且仍在<a href="https://cn.vuejs.org/v2/guide/components-slots.html#废弃了的语法" target="_blank" rel="noopener">文档中</a>的 attribute。新语法的由来可查阅这份 <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md" target="_blank" rel="noopener">RFC</a>。</p>
</blockquote>
<h3 id="插槽内容"><a href="#插槽内容" class="headerlink" title="插槽内容"></a>插槽内容</h3><blockquote>
<p>Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" target="_blank" rel="noopener">Web Components 规范草案</a>，将 `` 元素作为承载分发内容的出口。</p>
</blockquote>
<p>通过插槽它允许这个合成组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">"/profile"</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;navigation-link&gt;</code>的模板可能这样写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:href</span>=<span class="string">"url"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"nav-link"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>渲染的时候，<code>&lt;slot&gt;&lt;/slot&gt;</code>将会被替换乘”Your Profile”。插槽内可以包含任何模板代码，包括HTML:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">"/profile"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加一个 Font Awesome 图标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"fa fa-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>甚至其他组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">"/profile"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加一个图标的组件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">font-awesome-icon</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span><span class="tag">&lt;/<span class="name">font-awesome-icon</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果没有包含<code>&lt;slot&gt;</code>元素，则组件标签内的内容会被抛弃。</p>
<h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><p>当想要在一个插槽中使用数据的时候：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">"/profile"</span>&gt;</span></span><br><span class="line">  Logged in as &#123;&#123; user.name &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该插槽和模板的其他地方一样可以访问相同实例属性（也就是相同的“作用域”），但<strong>不能</strong>访问<code>&lt;navigation-link&gt;的作用域。</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">"/profile"</span>&gt;</span></span><br><span class="line">  Clicking here will send you to: &#123;&#123; url &#125;&#125;</span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  这里的 `url` 会是 undefined，因为 "/profile" 是</span></span><br><span class="line"><span class="comment">  _传递给_ &lt;navigation-link&gt; 的而不是</span></span><br><span class="line"><span class="comment">  在 &lt;navigation-link&gt; 组件*内部*定义的。</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注：父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p>
<h3 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h3><p>为一个插槽设置具体的默认（后备）内容是必要的，在没有提供内容的时候渲染。比如在在<code>&lt;submit-button&gt;</code>中</p>
<p>希望绝大多数情况下渲染“Submit”。为了将”Submit”作为后备内容，将它放在<code>&lt;slot&gt;</code>标签内：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><blockquote>
<p>2.6.0 更新。已废弃的使用 <code>slot</code> attribute 的语法在<a href="https://cn.vuejs.org/v2/guide/components-slots.html#废弃了的语法" target="_blank" rel="noopener">这里</a>。</p>
</blockquote>
<p>有时候需要多个插槽，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页头放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把主要内容放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页脚放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于这种情况，<code>&lt;slot&gt;</code>元素有个特殊的attribute：<code>name</code>。这个attribute用来定义额外的插槽：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不带<code>name</code>的<code>&lt;slot&gt;</code>出口带有隐含的名字”defaukt”</p>
<p>向具名插槽提供内容的时候，我们可以在一个<code>&lt;template&gt;</code>元素上使用<code>v-slot</code>指令，并以<code>v-slot</code>的参数形式提供其名称：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样，<code>&lt;template&gt;</code>元素的内容都会被传入相应的插槽中。任何没有包裹在<code>v-slot</code>的<code>&lt;template&gt;</code>被视为默认插槽的内容。</p>
<p>如果想要更具体一点，可以：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><blockquote>
<p>自 2.6.0 起有所更新。已废弃的使用 <code>slot-scope</code> attribute 的语法在<a href="https://cn.vuejs.org/v2/guide/components-slots.html#废弃了的语法" target="_blank" rel="noopener">这里</a>。    </p>
</blockquote>
<p>有时需要让插槽内容访问到子组件的数据是很有用的。</p>
<p>为了让 <code>user</code> 在父级的插槽内容中可用，我们可以将 <code>user</code> 作为 `` 元素的一个 attribute 绑定上去：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>绑定在 <code>` 元素上的 attribute 被称为**插槽 prop**。现在在父级作用域中，我们可以使用带值的</code>v-slot` 来定义我们提供的插槽 prop 的名字：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 <code>slotProps</code>，但你也可以使用任意你喜欢的名字。</p>
<ol>
<li><p>独占默认插槽的缩写语法</p>
<p>，不带参数的 <code>v-slot</code> 被假定对应默认插槽：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意默认插槽的缩写语法<strong>不能</strong>和具名插槽混用，因为它会导致作用域不明确。</p>
<p>出现多个插槽，始终为所有的插槽使用完整的基于<code>&lt;template&gt;</code>的语法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">"otherSlotProps"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解构插槽prop</p>
<p>作用域插槽的内部原理是：将你的插槽内容包括在一个传入单个参数的函数里：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">slotProps</span>)</span>&#123;</span><br><span class="line"> <span class="comment">//插槽内容   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着 <code>v-slot</code> 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。</p>
<p>所以在支持的环境下 (<a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">单文件组件</a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#浏览器兼容" target="_blank" rel="noopener">现代浏览器</a>)，你也可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#解构对象" target="_blank" rel="noopener">ES2015 解构</a>来传入具体的插槽 prop，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"&#123; user &#125;"</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样使得模板更加简介，尤其在插槽提供了多个prop的时候，它们同样提供了将prop重命名的其他可能，比如将<code>user</code>重命名为<code>person</code>:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"&#123; user: person &#125;"</span>&gt;</span></span><br><span class="line">  &#123;&#123; person.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你甚至可以定义后备内容，用于插槽 prop 是 undefined 的情形：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"&#123; user = &#123; firstName: 'Guest' &#125; &#125;"</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h3><p><a href="https://cn.vuejs.org/v2/guide/syntax.html#动态参数" target="_blank" rel="noopener">动态指令参数</a>也可以用在 <code>v-slot</code> 上，来定义动态的插槽名：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[<span class="attr">dynamicSlotName</span>]&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="具名插槽的缩写"><a href="#具名插槽的缩写" class="headerlink" title="具名插槽的缩写"></a>具名插槽的缩写</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="其他示例"><a href="#其他示例" class="headerlink" title="其他示例"></a>其他示例</h3><p><strong>插槽 prop 允许我们将插槽转换为可复用的模板，这些模板可以基于输入的 prop 渲染出不同的内容。</strong>这在设计封装数据逻辑同时允许父级组件自定义部分布局的可复用组件时是最有用的。</p>
<p>例如，我们要实现一个 <code>&lt;todo-list&gt;</code> 组件，它是一个列表且包含布局和过滤逻辑：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"todo in filteredTodos"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:key</span>=<span class="string">"todo.id"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以将每个 todo 作为父级组件的插槽，以此通过父级组件对其进行控制，然后将 <code>todo</code> 作为一个插槽 prop 进行绑定：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"todo in filteredTodos"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:key</span>=<span class="string">"todo.id"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    我们为每个 todo 准备了一个插槽，</span></span><br><span class="line"><span class="comment">    将 `todo` 对象作为一个插槽的 prop 传入。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"todo"</span> <span class="attr">v-bind:todo</span>=<span class="string">"todo"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 后备内容 --&gt;</span></span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在当我们使用 <code>&lt;todo-list&gt;</code> 组件的时候，我们可以选择为 todo 定义一个不一样<code>&lt;template&gt;</code>的作为替代方案，并且可以从子组件获取数据：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">todo-list</span> <span class="attr">v-bind:todos</span>=<span class="string">"todos"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:todo</span>=<span class="string">"&#123; todo &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">"todo.isComplete"</span>&gt;</span>✓<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="动态组件-amp-异步组件"><a href="#动态组件-amp-异步组件" class="headerlink" title="动态组件&amp;异步组件"></a>动态组件&amp;异步组件</h2><h3 id="在动态组件上使用keep-alive"><a href="#在动态组件上使用keep-alive" class="headerlink" title="在动态组件上使用keep-alive"></a>在动态组件上使用<code>keep-alive</code></h3><p>前面在一个多标签的界面使用<code>is</code>attribute来切换不同的组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当在这些组件之间切换时，有时候需要保持这些组件的状态，避免重复渲染导致性能问题</p>
<p>通常重建动态组件是非常有用的，但是，有时候更希望那些标签的组件实例能够在第一次被创建的时候缓存起来，为了解决这个问题，可以用<code>&lt;keep-alive&gt;</code>元素将其动态组件包裹起来：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 失活的组件将会被缓存！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这个 <code>` 要求被切换到的组件都有自己的名字，不论是通过组件的</code>name` 选项还是局部/全局注册。</p>
<h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>在大型的应用中，可能需要将应用分割成一定粒度的代码块，并且只有在需要的时候才从服务器加载一个模块，为了简化，Vue提供了以工厂函数的方式定义组件，这个工厂函数会异步解析组件定义。Vue只有在这个组件需要渲染的时候才会触发工厂函数，并且会把结果缓存起来供未来重渲染。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 向 `resolve` 回调传递组件定义</span></span><br><span class="line">    resolve(&#123;</span><br><span class="line">      template: <span class="string">'&lt;div&gt;I am async!&lt;/div&gt;'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如你所见，这个工厂函数会收到一个 <code>resolve</code> 回调，这个回调函数会在你从服务器得到组件定义的时候被调用。你也可以调用 <code>reject(reason)</code> 来表示加载失败。这里的 <code>setTimeout</code> 是为了演示用的，如何获取组件取决于你自己。一个推荐的做法是将异步组件和 <a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">webpack 的 code-splitting 功能</a>一起配合使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-webpack-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个特殊的 `require` 语法将会告诉 webpack</span></span><br><span class="line">  <span class="comment">// 自动将你的构建代码切割成多个包，这些包</span></span><br><span class="line">  <span class="comment">// 会通过 Ajax 请求加载</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>你也可以在工厂函数中返回一个 <code>Promise</code>，所以把 webpack 2 和 ES2015 语法加在一起，我们可以写成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">'async-webpack-example'</span>,</span><br><span class="line">  <span class="comment">// 这个 `import` 函数会返回一个 `Promise` 对象。</span></span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当使用<a href="https://cn.vuejs.org/v2/guide/components-registration.html#局部注册" target="_blank" rel="noopener">局部注册</a>的时候，你也可以直接提供一个返回 <code>Promise</code> 的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'my-component'</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>处理加载状态</p>
<blockquote>
<p>2.3.0+ 新增</p>
</blockquote>
<p>这里的异步组件工厂函数也可以返回一个如下格式的对象：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComponent = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span></span><br><span class="line">  component: <span class="keyword">import</span>(<span class="string">'./MyComponent.vue'</span>),</span><br><span class="line">  <span class="comment">// 异步组件加载时使用的组件</span></span><br><span class="line">  loading: LoadingComponent,</span><br><span class="line">  <span class="comment">// 加载失败时使用的组件</span></span><br><span class="line">  error: ErrorComponent,</span><br><span class="line">  <span class="comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 如果提供了超时时间且组件加载也超时了，</span></span><br><span class="line">  <span class="comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意如果你希望在 <a href="https://github.com/vuejs/vue-router" target="_blank" rel="noopener">Vue Router</a> 的路由组件中使用上述语法的话，你必须使用 Vue Router 2.4.0+ 版本。</p>
</blockquote>
<h2 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a>处理边界情况</h2><h3 id="访问元素-amp-组件"><a href="#访问元素-amp-组件" class="headerlink" title="访问元素&amp;组件"></a>访问元素&amp;组件</h3><ol>
<li><p>访问根实例</p>
<p>在每个 <code>new Vue</code> 实例的子组件中，其根实例可以通过 <code>$root</code> 属性进行访问。例如，在这个根实例中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue 根实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    foo: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    baz: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>所有的子组件都可以将这个实例作为一个全局 store 来访问或使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取根组件的数据</span></span><br><span class="line"><span class="keyword">this</span>.$root.foo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入根组件的数据</span></span><br><span class="line"><span class="keyword">this</span>.$root.foo = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问根组件的计算属性</span></span><br><span class="line"><span class="keyword">this</span>.$root.bar</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用根组件的方法</span></span><br><span class="line"><span class="keyword">this</span>.$root.baz()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于 demo 或非常小型的有少量组件的应用来说这是很方便的。不过这个模式扩展到中大型应用来说就不然了。因此在绝大多数情况下，我们强烈推荐使用 <a href="https://github.com/vuejs/vuex" target="_blank" rel="noopener">Vuex</a> 来管理应用的状态。</p>
</blockquote>
</li>
<li><p>访问父级组件实例</p>
<p>和 <code>$root</code> 类似，<code>$parent</code> 属性可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">google-map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">google-map-markers</span> <span class="attr">v-bind:places</span>=<span class="string">"iceCreamShops"</span>&gt;</span><span class="tag">&lt;/<span class="name">google-map-markers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">google-map</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个 <code>组件可以定义一个 `map` 属性，所有的子组件都需要访问它。在这种情况下</code> 可能想要通过类似 <code>this.$parent.getMap</code> 的方式访问那个地图，以便为其添加一组标记。你可以在<a href="https://jsfiddle.net/chrisvfritz/ttzutdxh/" target="_blank" rel="noopener">这里</a>查阅这种模式。</p>
<p>请留意，尽管如此，通过这种模式构建出来的那个组件的内部仍然是容易出现问题的。比如，设想一下我们添加一个新的 <code>组件，当</code> 在其内部出现的时候，只会渲染那个区域内的标记：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">google-map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">google-map-region</span> <span class="attr">v-bind:shape</span>=<span class="string">"cityBoundaries"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">google-map-markers</span> <span class="attr">v-bind:places</span>=<span class="string">"iceCreamShops"</span>&gt;</span><span class="tag">&lt;/<span class="name">google-map-markers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">google-map-region</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">google-map</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么在 <code>&lt;google-map-markers&gt;</code> 内部你可能发现自己需要一些类似这样的 hack：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">this</span>.$parent.map || <span class="keyword">this</span>.$parent.$parent.map</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问子组件实例或资源</p>
<p>尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 <code>ref</code> 这个 attribute 为子组件赋予一个 ID 引用。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">ref</span>=<span class="string">"usernameInput"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在在你已经定义了这个 <code>ref</code> 的组件里，你可以使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$refs.usernameInput</span><br></pre></td></tr></table></figure>
<p>来访问这个 <code>&lt;base-input&gt;</code> 实例，以便不时之需。比如程序化地从一个父级组件聚焦这个输入框。在刚才那个例子中，该 <code>&lt;base-input&gt;</code> 组件也可以使用一个类似的 <code>ref</code> 提供对内部这个指定元素的访问，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">"input"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>甚至可以通过其父级组件定义方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// 用来从父级组件聚焦输入框</span></span><br><span class="line">  focus: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs.input.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就允许父级组件通过下面的代码聚焦 <code>&lt;base-input&gt;</code> 里的输入框：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$refs.usernameInput.focus()</span><br></pre></td></tr></table></figure>
<p>当 <code>ref</code> 和 <code>v-for</code> 一起使用的时候，你得到的引用将会是一个包含了对应数据源的这些子组件的数组。</p>
<p>注：<code>$refs</code> 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 <code>$refs</code>。</p>
</li>
<li><p>依赖注入</p>
<p>上面的，所有 <code>&lt;google-map&gt;</code> 的后代都需要访问一个 <code>getMap</code> 方法，以便知道要跟哪个地图进行交互。不幸的是，使用 <code>$parent</code> 属性无法很好的扩展到更深层级的嵌套组件上。这也是依赖注入的用武之地，它用到了两个新的实例选项：<code>provide</code> 和 <code>inject</code></p>
<p><code>provide</code> 选项允许我们指定我们想要<strong>提供</strong>给后代组件的数据/方法。在这个例子中，就是 <code>&lt;google-map&gt;</code> 内部的 <code>getMap</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">provide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getMap: <span class="keyword">this</span>.getMap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在任何后代组件里，我们都可以使用 <code>inject</code> 选项来接收指定的我们想要添加在这个实例上的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inject: [<span class="string">'getMap'</span>]</span><br></pre></td></tr></table></figure>
<p>你可以在<a href="https://jsfiddle.net/chrisvfritz/tdv8dt3s/" target="_blank" rel="noopener">这里</a>看到完整的示例。相比 <code>$parent</code> 来说，这个用法可以让我们在<em>任意</em>后代组件中访问 <code>getMap</code>，而不需要暴露整个 <code>&lt;google-map&gt;</code> 实例。这允许我们更好的持续研发该组件，而不需要担心我们可能会改变/移除一些子组件依赖的东西。同时这些组件之间的接口是始终明确定义的，就和 <code>props</code> 一样。</p>
<p>实际上，你可以把依赖注入看作一部分“大范围有效的 prop”，除了：</p>
<ul>
<li>祖先组件不需要知道哪些后代组件使用它提供的属性</li>
<li>后代组件不需要知道被注入的属性来自哪里</li>
</ul>
</li>
</ol>
<h3 id="程序化的事件侦听器"><a href="#程序化的事件侦听器" class="headerlink" title="程序化的事件侦听器"></a>程序化的事件侦听器</h3><p>现在，你已经知道了 <code>$emit</code> 的用法，它可以被 <code>v-on</code> 侦听，但是 Vue 实例同时在其事件接口中提供了其它的方法。我们可以：</p>
<ul>
<li>通过 <code>$on(eventName, eventHandler)</code> 侦听一个事件</li>
<li>通过 <code>$once(eventName, eventHandler)</code> 一次性侦听一个事件</li>
<li>通过 <code>$off(eventName, eventHandler)</code> 停止侦听一个事件</li>
</ul>
<p>当你需要在一个组件实例上手动侦听事件时，它们是派得上用场的。它们也可以用于代码组织工具。例如，你可能经常看到这种集成一个第三方库的模式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次性将这个日期选择器附加到一个输入框上</span></span><br><span class="line"><span class="comment">// 它会被挂载到 DOM 上。</span></span><br><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Pikaday 是一个第三方日期选择器的库</span></span><br><span class="line">  <span class="keyword">this</span>.picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">    field: <span class="keyword">this</span>.$refs.input,</span><br><span class="line">    format: <span class="string">'YYYY-MM-DD'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 在组件被销毁之前，</span></span><br><span class="line"><span class="comment">// 也销毁这个日期选择器。</span></span><br><span class="line">beforeDestroy: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.picker.destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个潜在的问题：</p>
<ul>
<li>它需要在这个组件实例中保存这个 <code>picker</code>，如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物。</li>
<li>我们的建立代码独立于我们的清理代码，这使得我们比较难于程序化地清理我们建立的所有东西。</li>
</ul>
<p>你应该通过一个程序化的侦听器解决这两个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">    field: <span class="keyword">this</span>.$refs.input,</span><br><span class="line">    format: <span class="string">'YYYY-MM-DD'</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.$once(<span class="string">'hook:beforeDestroy'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    picker.destroy()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了这个策略，我甚至可以让多个输入框元素同时使用不同的 Pikaday，每个新的实例都程序化地在后期清理它自己：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.attachDatepicker(<span class="string">'startDateInput'</span>)</span><br><span class="line">  <span class="keyword">this</span>.attachDatepicker(<span class="string">'endDateInput'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  attachDatepicker: <span class="function"><span class="keyword">function</span> (<span class="params">refName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">      field: <span class="keyword">this</span>.$refs[refName],</span><br><span class="line">      format: <span class="string">'YYYY-MM-DD'</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.$once(<span class="string">'hook:beforeDestroy'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      picker.destroy()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><ol>
<li><p>递归组件</p>
<p>组件是可以在自己的模板中调用自身的，不过只能通过<code>name</code>选项来做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: <span class="string">'unique-name-of-my-component'</span></span><br></pre></td></tr></table></figure>
<p>当你使用 <code>Vue.component</code> 全局注册一个组件时，这个全局的 ID 会自动设置为该组件的 <code>name</code> 选项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'unique-name-of-my-component'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>稍有不慎，递归组件就可能导致无限循环：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: <span class="string">'stack-overflow'</span>,</span><br><span class="line">template: <span class="string">'&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;'</span></span><br></pre></td></tr></table></figure>
<p>类似上述的组件将会导致“max stack size exceeded”错误，所以请确保递归调用是条件性的 (例如使用一个最终会得到 <code>false</code> 的 <code>v-if</code>)。</p>
</li>
<li><p>组件之间的循环引用</p>
<p>假设需要构建一个文件目录树，可能需要一个<code>&lt;tree-folder&gt;</code>组件，模板如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tree-folder-contents</span> <span class="attr">:children</span>=<span class="string">"folder.children"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>还有一个<code>&lt;tree-folder-contents&gt;</code>组件，模板是这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"child in children"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tree-folder</span> <span class="attr">v-if</span>=<span class="string">"child.children"</span> <span class="attr">:folder</span>=<span class="string">"child"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; child.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当你仔细观察的时候，你会发现这些组件在渲染树中互为对方的后代<em>和</em>祖先——一个悖论！当通过 <code>Vue.component</code> 全局注册组件的时候，这个悖论会被自动解开。如果你是这样做的，那么你可以跳过这里。</p>
<p>为了解释这里发生了什么，我们先把两个组件称为 A 和 B。模块系统发现它需要 A，但是首先 A 依赖 B，但是 B 又依赖 A，但是 A 又依赖 B，如此往复。这变成了一个循环，不知道如何不经过其中一个组件而完全解析出另一个组件。为了解决这个问题，我们需要给模块系统一个点，在那里“A <em>反正</em>是需要 B 的，但是我们不需要先解析 B。”</p>
<p>在我们的例子中，把 <code>组件设为了那个点。我们知道那个产生悖论的子组件是</code> 组件，所以我们会等到生命周期钩子 <code>beforeCreate</code> 时去注册它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options.components.TreeFolderContents = <span class="built_in">require</span>(<span class="string">'./tree-folder-contents.vue'</span>).default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，在本地注册组件的时候，你可以使用 webpack 的异步 <code>import</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">  TreeFolderContents: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./tree-folder-contents.vue'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="模板定义的替代品"><a href="#模板定义的替代品" class="headerlink" title="模板定义的替代品"></a>模板定义的替代品</h3><ol>
<li><p>内联模板</p>
<p>当 <code>inline-template</code> 这个特殊的 attribute 出现在一个子组件上时，这个组件将会使用其里面的内容作为模板，而不是将其作为被分发的内容。这使得模板的撰写工作更加灵活。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">inline-template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>These are compiled as the component's own template.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Not parent's transclusion content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>内联模板需要定义在 Vue 所属的 DOM 元素内。</p>
<p>不过，<code>inline-template</code> 会让模板的作用域变得更加难以理解。所以作为最佳实践，请在组件内优先选择 <code>template</code> 选项或 <code>.vue</code> 文件里的一个 ` 元素来定义模板。</p>
</li>
<li><p>X-Template</p>
<p>另一个定义模板的方式是在一个 <code>&lt;script&gt;</code> 元素中，并为其带上 <code>text/x-template</code> 的类型，然后通过一个 id 将模板引用过去。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"hello-world-template"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello hello hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello-world'</span>, &#123;</span><br><span class="line">  template: <span class="string">'#hello-world-template'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>x-template 需要定义在 Vue 所属的 DOM 元素外。</p>
<p>这些可以用于模板特别大的 demo 或极小型的应用，但是其它情况下请避免使用，因为这会将模板和该组件的其它定义分离开。</p>
</li>
</ol>
<h3 id="控制更新"><a href="#控制更新" class="headerlink" title="控制更新"></a>控制更新</h3><p>Vue的响应式系统，它始终知道如何进行更新。</p>
<p>不过还是有一些边界情况，你想要强制更新，尽管表面上看响应式的数据没有发生改变。也有一些情况是你想阻止不必要的更新。</p>
<ol>
<li><p>强制更新</p>
<p>注：如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事。</p>
<p>你可能还没有留意到<a href="https://cn.vuejs.org/v2/guide/list.html#注意事项" target="_blank" rel="noopener">数组</a>或<a href="https://cn.vuejs.org/v2/guide/list.html#对象变更检测注意事项" target="_blank" rel="noopener">对象</a>的变更检测注意事项，或者你可能依赖了一个未被 Vue 的响应式系统追踪的状态。</p>
<p>然而，如果你已经做到了上述的事项仍然发现在极少数的情况下需要手动强制更新，那么你可以通过 <a href="https://cn.vuejs.org/v2/api/#vm-forceUpdate" target="_blank" rel="noopener"><code>$forceUpdate</code></a> 来做这件事。</p>
</li>
<li><p>通过<code>v-once</code>创建低开销的静态组件</p>
<p>当有这样一个组件，组件内包含了大量静态内容。在这种情况下，可以在根元素上添加<code>v-once</code> attribute确保这些内容只计算一次然后缓存起来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'terms-of-service'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div v-once&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Terms of Service&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      ... a lot of static content ...</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)j</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>再说一次，试着不要过度使用这个模式。当你需要渲染大量静态内容时，极少数的情况下它会给你带来便利，除非你非常留意渲染变慢了，不然它完全是没有必要的——再加上它在后期会带来很多困惑。例如，设想另一个开发者并不熟悉 <code>v-once</code> 或漏看了它在模板中，他们可能会花很多个小时去找出模板为什么无法正确更新。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/18/vue%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DongxianGu">
      <meta itemprop="description" content="Life,Happy,Code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Summer So Cold">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/18/vue%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">vue使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-18 09:55:30" itemprop="dateCreated datePublished" datetime="2020-03-18T09:55:30+08:00">2020-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-19 09:41:56" itemprop="dateModified" datetime="2020-03-19T09:41:56+08:00">2020-03-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/03/18/vue%E4%BD%BF%E7%94%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/03/18/vue%E4%BD%BF%E7%94%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vue-js使用"><a href="#Vue-js使用" class="headerlink" title="Vue.js使用"></a>Vue.js使用</h1><script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

<h2 id="Vue-Instance"><a href="#Vue-Instance" class="headerlink" title="Vue Instance"></a>Vue Instance</h2><p>Vue应用都是通过创建一个新的Vue 实例开始的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">//选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Vue应用是通过<code>new Vue</code>创建<strong>根Vue实例</strong>，以及可选的、嵌套的、可复用的组建树组成。</p>
<h3 id="数据和方法"><a href="#数据和方法" class="headerlink" title="数据和方法"></a>数据和方法</h3><p>Vue Instance被创建的时候它将<code>data</code>对象中的所有的属性加入到Vue的<strong>响应式系统</strong>中。当这些属性的值发生改变，视图匹配更新为新的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们的数据对象</span></span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该对象被加入到一个 Vue 实例中</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得这个实例上的属性</span></span><br><span class="line"><span class="comment">// 返回源数据中对应的字段</span></span><br><span class="line">vm.a == data.a <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置属性也会影响到原始数据</span></span><br><span class="line">vm.a = <span class="number">2</span></span><br><span class="line">data.a <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……反之亦然</span></span><br><span class="line">data.a = <span class="number">3</span></span><br><span class="line">vm.a <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>注意：只有当Instance被创建的时就以及存在与<code>data</code>中的属性才是<strong>响应式</strong>的。</p>
<p>其次，当使用<code>Object.freeze()</code>，这也会阻止修改现有的属性，也意味着响应式系统无法trace变化。</p>
<h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><p>因为生命周期钩子的函数的存在，用户可以在不同的阶段添加自己的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a is: '</span> + <span class="keyword">this</span>.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt; "a is: 1"</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/vue/lifecycle.png" alt="lifecycle"></p>
<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><blockquote>
<p>vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p>
<p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p>
<p>如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">直接写渲染 (render) 函数</a>，使用可选的 JSX 语法。</p>
</blockquote>
<h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><ol>
<li><p>文本</p>
<p>最常见的形式是使用”Mustache”语法（双大括号）的文本插值：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span> Message: &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Mustache标签将会被替换为对应数据对象上<code>msg</code>属性的值。当数据对象<code>msg</code>属性发生改变，插值处的内容也会改变。</p>
<p>通过使用<code>v-once</code>指令，可以执行一次插值，当数据改变，插值处内容不会更新。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>这个将不会改变: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原始的HTML</p>
<p>Mustache标签将数据解释乘plain text，而不是HTML代码。</p>
<p>为了输出真正的HTML，需要使用<code>v-html</code>指令。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Using mustache: &#123;&#123;rawHtml&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">"rawHtml"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>span</code>的内容将会被替换乘属性值<code>rawHTML</code>，直接作为HTML——会忽略属性值中的数据绑定，因此不是不能使用<code>v-html</code>来复合局部模板。对于界面，组件作为可重用和可组合的基本单位。</p>
</li>
<li><p>Attribute</p>
<p>Mustache语法无法作用在HTML attribute上，这种情况下应使用<code>v-bind</code>指令：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"dynameicId"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于Bool attribute（只要binding的对象存在就意味这<code>true</code>）<code>v-bind</code>工作略有不同，</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:disabled</span>=<span class="string">"isButtonDisabled"</span>&gt;</span></span><br><span class="line">    Button</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果<code>isButtonDisabled</code>的值为<code>null</code>，<code>undefined</code>或<code>false</code>，则<code>disabled</code> attribute 不会包含在渲染出来的节点元素中。</p>
</li>
<li><p>使用JS表达式</p>
<p>Vue.js提供了完全的JavaScript表达式的支持：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"'list-' + id"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这些表达式会在所属的Vue Instance的数据作用域下作为JavaScript被解析。唯一的限制就是，每个绑定只能包含<strong>单个表达式</strong>，下面的情况都无法使用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是语句，不是表达式 --&gt;</span></span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span></span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>模板表达式是在沙盒中，只能访问到全局变量的一个白名单，比如<code>Math</code>和<code>Date</code>。不应该在模板表达式中来访问用户定义的全局变量。</p>
</li>
</ol>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><blockquote>
<p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute。指令 attribute 的值预期是<strong>单个 JavaScript 表达式</strong> (<code>v-for</code> 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"seen"</span>&gt;</span></span><br><span class="line">    现在你看到我了</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里<code>v-if</code>指令将根据表达式<code>seen</code>的值的真假来插入/移除<code>&lt;p&gt;</code>元素。</p>
<ol>
<li><p>参数</p>
<p>部分指令可以接受一个Parameter，在指令名称后面用冒号表示。比如<code>v-bind</code>指令用于响应式的更新HTML Attribute：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>href</code>就是一个Parameter，<code>v-bind</code>指令将该元素的<code>href</code> attribute和表达式<code>url</code>的值绑定。</p>
<p>另一个例子是<code>v-on</code>指令，该指令被用于监听DOM事件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>动态参数</p>
<blockquote>
<p>2.6.0 增加，可用用方括号扩起来的JavaScript表达式作为一个指令的参数。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributeName</span>]=<span class="string">"url"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中的<code>attributeName</code>被作为一个JavaScript表达式进行动态求值，求得的值作为最终的Parameter来使用。</p>
<p>如果<code>attributeName</code>为<code>href</code>，那么就等价与<code>v-bind:href</code>。</p>
<p>同样，也可以使用动态参数为一个动态事件绑定处理函数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:</span>[<span class="attr">eventName</span>]=<span class="string">"doSomething"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当<code>eventName</code>的值为<code>focus</code>时，等价于<code>v-on：focus</code></p>
<ul>
<li><p>对动态参数的值的约束</p>
<p>动态参数预期求出一个字符串，出现异常值为<code>null</code>。这个特殊的<code>null</code>值表示移除绑定。任何其他非字符串类型的值都会触发一个alert。</p>
</li>
<li><p>对动态参数表达式的约束</p>
<p>动态参数表达式有一些约束，因为某些字符比如空格和引号，对于HTML attribute是无效的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这会触发一个编译警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>['<span class="attr">foo</span>' + <span class="attr">bar</span>]=<span class="string">"value"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>变通的方法是使用没有空格或引号的表达式，或者使用计算属性来替换这种复杂的表达式。</p>
<p>避免使用大写字母来命名键名，因为Brower会将attribute名全部强制转为小写。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。</span></span><br><span class="line"><span class="comment">除非在实例中有一个名为“someattr”的 property，否则代码不会工作。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">someAttr</span>]=<span class="string">"value"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>修饰符</p>
<blockquote>
<p>修饰符 (modifier) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。</p>
</blockquote>
<p>比如<code>.prevent</code>修饰符告诉<code>v-on</code>指令对于触发的事件调用<code>event.preventDefault()</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><blockquote>
<p><code>v-</code> 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，<code>v-</code> 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue 管理所有模板的<a href="https://en.wikipedia.org/wiki/Single-page_application" target="_blank" rel="noopener">单页面应用程序 (SPA - single page application)</a> 时，<code>v-</code> 前缀也变得没那么重要了。因此，Vue 为 <code>v-bind</code> 和 <code>v-on</code> 这两个最常用的指令，提供了特定简写：</p>
</blockquote>
<ol>
<li><p><code>v-bind</code>缩写</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">"url"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>v-on</code>缩写</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">"doSomething"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>模板中使用表达式非常方便，但是只能用于简单计算。如果在模板放入太多逻辑会导致模板过重且难以维护。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因此，对于任何的复杂逻辑，应该使用<strong>计算属性</strong></p>
<ol>
<li><p>基础例子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "&#123;&#123; message &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Original message: “Hello”</p>
<p>Computed reversed message: “olleH”</p>
</li>
</ol>
<p>   这里声明了一个计算属性<code>reverseMessage</code>。我们提供的函数作为属性<code>vm.reverseMessage</code>的getter函数。</p>
   <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(vm.reversedMessage) // =&gt; 'olleH'</span><br><span class="line">vm.message = 'Goodbye'</span><br><span class="line">console.log(vm.reversedMessage) // =&gt; 'eybdooG'</span><br></pre></td></tr></table></figure>
<ol>
<li><p>计算属性缓存 versus 方法</p>
<p>同样，我们也可以在表达式中调用方法达到和计算属性同样的效果。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Reversed message: "&#123;&#123; reversedMessage() &#125;&#125;"</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件中</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实完全相同。但是<strong>计算属性是基于它们的响应式以来进行缓存的</strong>。只要相关的响应式依赖发生改变时它们才会重新求值。</p>
<p>这就意味着只要<code>message</code>没有发生改变，多次访问<code>reverseMessage</code>计算属性就会返回之前的计算结果，而不需要再次执行函数。</p>
<p>这就意味着下面的计算属性不再更新，因为<code>Date.now()</code>不是响应式依赖。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  now: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比较，每次触发渲染时，调用方法<strong>总会</strong>再次执行函数。</p>
</li>
</ol>
<p>   缓存的目的：</p>
<p>   假设有一个性能开销比较大的计算属性A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于A。如果没有缓存，我们将不可避免的多次执行A的getter。如果不需要缓存，请用方法替代。</p>
<ol>
<li><p>计算属性 versus 侦听属性</p>
<p>Vue提供了一种更通用的方式来观察和响应Vue 实例上的数据变动：<strong>侦听属性</strong>。</p>
<p>当一些数据需要随着其他数据变动而变动时，很容易滥用<code>watch</code>。然而，通常更好的做法是使用计算属性而不是<code>watch</code>回调。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span>,</span><br><span class="line">    fullName: <span class="string">'Foo Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = val + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = <span class="keyword">this</span>.firstName + <span class="string">' '</span> + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面的代码过于重复。下面是计算属性的version：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算属性的setter</p>
<p>计算属性默认只有getter，不过有时候也需要一个setter：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>这个时候运行<code>vm.fullName = &#39;John Doe&#39;</code>，setter会被调用，<code>vm.firstName</code>和<code>vm.lastName</code>也会相应的被更新。</p>
</li>
</ol>
<h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p>计算属性在大多数情况下是更合适的，但有时也需要一个自定义的侦听器。</p>
<p>这就是为什么Vue通过<code>watch</code>选项提供了一个更加通用的方法，来响应数据的变化。当需要在<strong>数据变化执行异步或开销较大</strong>的操作时，这个方式是最有用的。</p>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"watch-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"question"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">  el: <span class="string">'#watch-example'</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="actionscript">    question: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">    answer: <span class="string">'I cannot give you an answer until you ask a question!'</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line"><span class="actionscript">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span></span><br><span class="line"><span class="actionscript">    question: <span class="function"><span class="keyword">function</span> <span class="params">(newQuestion, oldQuestion)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.answer = <span class="string">'Waiting for you to stop typing...'</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.debouncedGetAnswer()</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="actionscript">  created: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">this</span>.debouncedGetAnswer = _.debounce(<span class="keyword">this</span>.getAnswer, <span class="number">500</span>)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="actionscript">    getAnswer: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span> (<span class="keyword">this</span>.question.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.answer = <span class="string">'Questions usually contain a question mark. ;-)'</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span></span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.answer = <span class="string">'Thinking...'</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> vm = <span class="keyword">this</span></span></span><br><span class="line"><span class="actionscript">      axios.get(<span class="string">'https://yesno.wtf/api'</span>)</span></span><br><span class="line"><span class="actionscript">        .then(<span class="function"><span class="keyword">function</span> <span class="params">(response)</span> </span>&#123;</span></span><br><span class="line">          vm.answer = _.capitalize(response.data.answer)</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="actionscript">        .catch(<span class="function"><span class="keyword">function</span> <span class="params">(error)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          vm.answer = <span class="string">'Error! Could not reach the API. '</span> + error</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里使用<code>watch</code>允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些是计算属性无法做到的。除了<code>watch</code>选项，还可以使用命令式的<a href="https://cn.vuejs.org/v2/api/#vm-watch" target="_blank" rel="noopener">vm.$watch API</a>。</p>
<h2 id="Class-和-Style-绑定"><a href="#Class-和-Style-绑定" class="headerlink" title="Class 和 Style 绑定"></a>Class 和 Style 绑定</h2><blockquote>
<p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用 <code>v-bind</code> 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</p>
</blockquote>
<h3 id="绑定HTML-Class"><a href="#绑定HTML-Class" class="headerlink" title="绑定HTML Class"></a>绑定HTML Class</h3><ol>
<li><p>对象语法</p>
<p>可以传给 <code>v-bind:class</code>一个对象，以动态的切换class:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive &#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的例子表示<code>active</code>这个class存在与否取决于数据属性<code>isActive</code>的truthiness真值</p>
<p>也可以在对象中传入更多属性来动态的切换多个class。此外，<code>v-class:class</code>指令可以于普通的class属性共存：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"static"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  hasError: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static active"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当isActive或hasError变化时，class列表将会相应的更新。</p>
<p>除了上面的这种方式，也可以将绑定的对象不必内联定义在模板中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'text-danger'</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染结果和上面一样。</p>
<p>此外我们也可以绑定一个计算属性。这是常用且非常强大的方式。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      <span class="string">'text-danger'</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">'fatal'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组语法</p>
<p>可以将一个数组传给<code>v-bind：class</code>来应用一个class列表：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[activeClass,errorClass]"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    activeClass: <span class="string">'active'</span>,</span><br><span class="line">    errorClass: <span class="string">'text-danger'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染结果为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"active text-danger"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以使用三元表达式来根据条件切换列表中的class:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当有多个条件时，上面的写法也比较繁琐。所有在数组语法中也可以使用对象语法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[ &#123; active: isActive&#125; , errorClass]"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在组件上使用</p>
<p>在一个自定义组件上使用<code>class</code>属性时，这些class将被添加到该组件的根元素上面。元素上面已经存在的class不会被覆盖。</p>
<p>例如：声明一个组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>,&#123;</span><br><span class="line">    template: <span class="string">'&lt;p class="foo bar"&gt;Hi&lt;/p&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用的时候添加class:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">class</span>=<span class="string">"baz boo"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"foo bar baz boo"</span>&gt;</span></span><br><span class="line">  Hi  </span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于带数据绑定的class也同样适用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123;active: isActive&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当<code>isActive</code>为真值的时，结果为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"foo bar active"</span>&gt;</span></span><br><span class="line">    Hi</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h3><ol>
<li><p>对象语法</p>
<p><code>v-bind:style</code>的对象语法十分直观——看起来象CSS，但实际上是一个JavaScript对象。CSS属性名可以用驼峰式（camelCase）或者短横线分割（kebab-case）来命名：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px'&#125;"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    activeColor: <span class="string">'red'</span>,</span><br><span class="line">    fontSize: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接绑定到一个样式对象更加清晰：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"styleObject"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    styleObject: &#123;</span><br><span class="line">        color: <span class="string">'red'</span>,</span><br><span class="line">       	fontSize: <span class="string">'13px'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，对象语法常常结合返回对象的<strong>计算属性</strong>使用。</p>
</li>
</ol>
<ol>
<li><p>数组语法</p>
<p><code>v-bind:style</code>的数组语法可以将多个样式对象应用到同一个元素上：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"[baseStyles, overridingStyles]"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自动添加前缀</p>
<p>当<code>v-bind:style</code>使用需要添加<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix" target="_blank" rel="noopener">浏览器引擎前缀</a>的 CSS 属性时，如 <code>transform</code>，Vue.js 会自动侦测并添加相应的前缀。</p>
</li>
<li><p>多重值</p>
<blockquote>
<p>2.3.0+</p>
</blockquote>
<p>可以为<code>style</code>绑定中的属性提供一个包含多个值的数组，常用以提供多个带前缀的值。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex']&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样只会渲染数组中最后一个被浏览器支持的值。</p>
</li>
</ol>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a><code>v-if</code></h3><blockquote>
<p><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"awesome"</span>&gt;</span></span><br><span class="line">    Vue is awesome!</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以使用<code>v-else</code>添加一个“else” 块</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"awesome"</span>&gt;</span></span><br><span class="line">    Vue is awesome!</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    Oh no 😢</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>在<code>&lt;template&gt;</code>元素上使用<code>v-if</code>条件渲染分组</p>
<p><code>v-if</code>作为一个指令，必须将它添加到一个元素上，但是如果想切换多个元素呢？此时可以将一个<code>&lt;template&gt;</code>元素当作不可见的包裹元素，并在上面使用<code>v-if</code>。最终渲染结果将不包含<code>&lt;template&gt;</code>元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>v-else</code></p>
<p>使用<code>v-else</code>指令来表示<code>v-if</code>的“else”块</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"Math.random() &gt; 0.5"</span>&gt;</span></span><br><span class="line">  Now you see me</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Now you don't</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>v-else</code>元素必须紧跟在<code>v-if</code>或<code>v-else-if</code>的元素的后面，否则无法识别。</p>
</li>
<li><p><code>v-else-if</code></p>
<blockquote>
<p>2.1.0 增加</p>
</blockquote>
<p>充当<code>v-if</code>的“else-if”块，可以连续使用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"type === 'A'"</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'B'"</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'C'"</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>类似<code>v-else</code>，<code>v-else-if</code>必须紧跟在<code>v-if</code>或<code>v-else-if</code>的元素的后面。</p>
</li>
<li><p>用<code>key</code>管理可复用的元素</p>
<blockquote>
<p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么上面的代码中切换<code>loginType</code>不会清除用户已有的输入内容。因为两个模板使用了相同的元素，<code>&lt;input&gt;</code>不会被替换掉，只是替换了它的<code>placeholder</code>。</p>
<p>当然，有时候这也不一定符合实际的需求，所以Vue提供了一种方式表明两个元素是完全独立的，不要复用它们。只需要添加一个具有唯一值的<code>key</code>属性即可：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span> <span class="attr">key</span>=<span class="string">"username-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span> <span class="attr">key</span>=<span class="string">"email-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样，每次切换时，输入框都会被重新渲染。但是其中的<code>&lt;label&gt;</code>元素仍然被高效的复用，因为它们没有添加<code>key</code> attribute。</p>
</li>
</ol>
<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><code>v-show</code></h3><p><code>v-show</code>是一个根据条件展示元素的指令。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line">    Hello !</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不同的时<code>v-show</code>的元素始终被渲染和保持在DOM中。<code>v-show</code>只是简单的切换元素的CSS attribute <code>display</code>。</p>
<p><strong>注意</strong>：<code>v-show</code>不支持<code>&lt;template&gt;</code>元素，也不支持<code>v-else</code></p>
<h3 id="v-if-versusv-show"><a href="#v-if-versusv-show" class="headerlink" title="v-if versusv-show"></a><code>v-if</code> versus<code>v-show</code></h3><blockquote>
<p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>
<p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>
<p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p>
</blockquote>
<h3 id="v-if-和-v-for一起使用"><a href="#v-if-和-v-for一起使用" class="headerlink" title="v-if 和 v-for一起使用"></a><code>v-if</code> 和 <code>v-for</code>一起使用</h3><blockquote>
<p><strong>不推荐</strong>同时使用 <code>v-if</code> 和 <code>v-for</code></p>
<p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。请查阅<a href="https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if" target="_blank" rel="noopener">列表渲染指南</a> 以获取详细信息。</p>
</blockquote>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h3 id="用v-for把一个数组对应为一组元素"><a href="#用v-for把一个数组对应为一组元素" class="headerlink" title="用v-for把一个数组对应为一组元素"></a>用<code>v-for</code>把一个数组对应为一组元素</h3><blockquote>
<p>我们可以用 <code>v-for</code> 指令基于一个数组来渲染一个列表。<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的<strong>别名</strong>。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">    	&#123;&#123; item.message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exampel1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   el: <span class="string">"#example-1"</span>,</span><br><span class="line">   data: &#123;</span><br><span class="line">       items: [</span><br><span class="line">           &#123;<span class="attr">message</span>: <span class="string">'Foo'</span>&#125;,</span><br><span class="line">           &#123;<span class="attr">message</span>: <span class="string">'Bar'</span>&#125;</span><br><span class="line">       ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在<code>v-for</code>块中，我们可以访问到所有的父作用域的属性。</p>
<p><code>v-for</code>还支持一个可选的第二个参数，当前项的索引。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span>&gt;</span></span><br><span class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    parentMessage: <span class="string">'Parent'</span>,</span><br><span class="line">    items: [</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Foo'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Bar'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>of</code>替换<code>in</code> 作为分隔符，更加接近JavaScript迭代器的语法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item of items"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="在v-for里使用对象"><a href="#在v-for里使用对象" class="headerlink" title="在v-for里使用对象"></a>在<code>v-for</code>里使用对象</h3><p>使用<code>v-for</code>来遍历对象的属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"v-for-obj"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"value in object"</span>&gt;</span></span><br><span class="line">    	&#123;&#123; value &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#v-for-obj"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        object: &#123;</span><br><span class="line">            title: <span class="string">'How to do lists in Vue'</span>,</span><br><span class="line">            author: <span class="string">'Jane Doe'</span>,</span><br><span class="line">            publishedAt: <span class="string">'2016-04-10'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>也可以提供第二个参数为property名称，键名：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value, name) in object"</span>&gt;</span></span><br><span class="line">    &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>还可以使用第三个参数作为索引：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value, name, index) in object"</span>&gt;</span></span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：在遍历对象，会按照Object.keys()的结果遍历，不能保证结果在不同的JS引擎下是一致的。</p>
<h3 id="维护状态"><a href="#维护状态" class="headerlink" title="维护状态"></a>维护状态</h3><blockquote>
<p>当 Vue 正在更新使用 <code>v-for</code> 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 <code>track-by=&quot;$index&quot;</code>。</p>
</blockquote>
<p>这个默认的模式是高效的，但是<strong>只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</strong>。</p>
<p>为了让Vue能够跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一的<code>key</code> attribute。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code> attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p>
<p>因为它是 Vue 识别节点的一个通用机制，<code>key</code> 并不仅与 <code>v-for</code> 特别关联。后面我们将在指南中看到，它还具有其它用途。</p>
</blockquote>
<p>注意：不要使用对象或数组之类的非基本类型值作为<code>v-for</code>的<code>key</code>。尽可能使用字符串或数值类型的值。</p>
<p><a href="https://cn.vuejs.org/v2/api/#key" target="_blank" rel="noopener"><code>key</code> 的 API 文档</a>。</p>
<h3 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h3><ol>
<li><p>变异方法 （mutation method）</p>
<p>Vue对侦听的数组的变异方法进行了包裹，所以数组的变异方法也会触发视图更新。被包裹的方法包括：</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
</li>
<li><p>替换数组</p>
<blockquote>
<p> 变异方法：会改变了调用这些方法的元素数组。</p>
</blockquote>
<p>非变异方法，例如<code>filter()</code>、<code>concate()</code>、<code>slice()</code>。它们不会改变原始数组，而<strong>总是返回一个新的数组</strong>。</p>
<p>当使用非变异方法时，可以用新数组替换旧数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example.items = example.items.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item.message.match(<span class="regexp">/Foo/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项</p>
<p>Vue无法检测以下数组的变动：</p>
<ol>
<li>当你使用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>当你修改数组的长度时，例如<code>vm.items.length = newLength</code></li>
</ol>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">     data: &#123;</span><br><span class="line">         items: [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items[<span class="number">1</span>] = <span class="string">'x'</span> <span class="comment">//不是响应式的</span></span><br><span class="line">vm.items.length = <span class="number">2</span> <span class="comment">//不是响应式的</span></span><br></pre></td></tr></table></figure>
<p>为了解决第一种问题，Vue提供了两种方法实现了<code>vm.items[indexOfItem] = newValue</code>相同的效果，并且也可以在响应式系统中触发状态更新：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem,  newValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure>
<p>你也可以使用 <a href="https://cn.vuejs.org/v2/api/#vm-set" target="_blank" rel="noopener"><code>vm.$set</code></a> 实例方法，该方法是全局方法 <code>Vue.set</code> 的一个别名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$<span class="keyword">set</span>(vm.items, indexOfItem, newValue)</span><br></pre></td></tr></table></figure>
<p>为了解决第二类问题，你可以使用 <code>splice</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="对象变更检测注意事项"><a href="#对象变更检测注意事项" class="headerlink" title="对象变更检测注意事项"></a>对象变更检测注意事项</h3><p>Vue无法检测对象属性的添加和删除</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// `vm.a` 现在是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.b = <span class="number">2</span></span><br><span class="line"><span class="comment">// `vm.b` 不是响应式的</span></span><br></pre></td></tr></table></figure>
<p>对于已经创建的实例，Vue不允许动态的添加根级别的响应式属性，但是可以使用<code>Vue.set(object, propertyName, value)</code> 方法向嵌套对象添加响应式属性。例如，对于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userProfile: &#123;</span><br><span class="line">      name: <span class="string">'Anika'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.userProfile, <span class="string">'age'</span>, <span class="number">27</span>)</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$<span class="keyword">set</span>(vm.userProfile, 'age', 27)</span><br></pre></td></tr></table></figure>
<p>有时候需要为已有对象赋值多个新属性，比如使用<code>Object.assign()</code>或<code>_.extend()</code>。你应该用两个对象的属性创建一个新的对象。如果想要添加新的响应式属性，不能像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(vm.userProfile,&#123;</span><br><span class="line">    age: <span class="number">27</span>,</span><br><span class="line">    favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>而应该这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.userProfile = <span class="built_in">Object</span>.assign(&#123;&#125;, vm.userProfile, &#123;</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="显示过滤-排序后的结果"><a href="#显示过滤-排序后的结果" class="headerlink" title="显示过滤/排序后的结果"></a>显示过滤/排序后的结果</h3><p>当想要显示一个数组经过过滤或排序后的版本，而不实际改变或重置原始数据。这种情况下，可以创建一个计算属性，来返回过滤或排序的数组。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in evenNumbers"</span>&gt;</span> &#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    number: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">    evenNumbers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当计算属性不合适的情况下，可以使用一个方法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in even(numbers)"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  numbers: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  even: <span class="function"><span class="keyword">function</span> (<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="v-for使用值范围"><a href="#v-for使用值范围" class="headerlink" title="v-for使用值范围"></a><code>v-for</code>使用值范围</h3><p><code>v-for</code>可以接受整数。这种情况下表示，它会把模板重复对应次数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"n in 10"</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-template-gt-中使用v-for"><a href="#lt-template-gt-中使用v-for" class="headerlink" title="&lt;template&gt;中使用v-for"></a><code>&lt;template&gt;</code>中使用<code>v-for</code></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"divider"</span> <span class="attr">role</span>=<span class="string">"presentation"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="v-for和v-if一起使用"><a href="#v-for和v-if一起使用" class="headerlink" title="v-for和v-if一起使用"></a><code>v-for</code>和<code>v-if</code>一起使用</h3><p>注意：不推荐</p>
<p>当它们处于同一节点，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中。当你只想为<em>部分</em>项渲染节点时，这种优先级的机制会十分有用，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span> <span class="attr">v-if</span>=<span class="string">"!todo.isComplete"</span>&gt;</span></span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码将只渲染未完成的 todo。</p>
<p>而如果你的目的是有条件地跳过循环的执行，那么可以将 <code>v-if</code> 置于外层元素 (或 <a href="https://cn.vuejs.org/v2/guide/conditional.html#在-lt-template-gt-中配合-v-if-条件渲染一整组" target="_blank" rel="noopener">`</a>)上。如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">"todos.length"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No todos left!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="在组件上使用v-for"><a href="#在组件上使用v-for" class="headerlink" title="在组件上使用v-for"></a>在组件上使用<code>v-for</code></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.2.0+ 的版本里，当在组件上使用 <code>v-for</code> 时，<code>key</code> 现在是必须的。</p>
</blockquote>
<p>然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 prop：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-for&#x3D;&quot;(item, index) in items&quot;</span><br><span class="line">  v-bind:item&#x3D;&quot;item&quot;</span><br><span class="line">  v-bind:index&#x3D;&quot;index&quot;</span><br><span class="line">  v-bind:key&#x3D;&quot;item.id&quot;</span><br><span class="line">&gt;&lt;&#x2F;my-component&gt;</span><br></pre></td></tr></table></figure>
<p>不自动将 <code>item</code> 注入到组件里的原因是，这会使得组件与 <code>v-for</code> 的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"todo-list-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"addNewTodo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"new-todo"</span>&gt;</span>Add a todo<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-model</span>=<span class="string">"newTodoText"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">"new-todo"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">placeholder</span>=<span class="string">"E.g. Feed the cat"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">      <span class="attr">is</span>=<span class="string">"todo-item"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">"(todo, index) in todos"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:key</span>=<span class="string">"todo.id"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:title</span>=<span class="string">"todo.title"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-on:remove</span>=<span class="string">"todos.splice(index, 1)"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这里的 <code>is=&quot;todo-item&quot;</code> 属性。这种做法在使用 DOM 模板时是十分必要的，因为在 <code>元素内只有</code> 元素会被看作有效内容。这样做实现的效果与 `` 相同，但是可以避开一些潜在的浏览器解析错误。查看 <a href="https://cn.vuejs.org/v2/guide/components.html#解析-DOM-模板时的注意事项" target="_blank" rel="noopener">DOM 模板解析说明</a> 来了解更多信息。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">  template: <span class="string">'\</span></span><br><span class="line"><span class="string">    &lt;li&gt;\</span></span><br><span class="line"><span class="string">      &#123;&#123; title &#125;&#125;\</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="$emit(\'remove\')"&gt;Remove&lt;/button&gt;\</span></span><br><span class="line"><span class="string">    &lt;/li&gt;\</span></span><br><span class="line"><span class="string">  '</span>,</span><br><span class="line">  props: [<span class="string">'title'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#todo-list-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    newTodoText: <span class="string">''</span>,</span><br><span class="line">    todos: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        title: <span class="string">'Do the dishes'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        title: <span class="string">'Take out the trash'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">3</span>,</span><br><span class="line">        title: <span class="string">'Mow the lawn'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    nextTodoId: <span class="number">4</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addNewTodo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.todos.push(&#123;</span><br><span class="line">        id: <span class="keyword">this</span>.nextTodoId++,</span><br><span class="line">        title: <span class="keyword">this</span>.newTodoText</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.newTodoText = <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><p><code>v-on</code>指令监听DOM事件，并在触发时运行JavaScript代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"counter += 1"</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h3><p>大部分事件处理的逻辑是相当复杂的，所以直接将JavaScript代码写在<code>v-on</code>指令中是不可行的。因此<code>v-on</code>还可以接受一个需要调用的方法名称。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- `greet` 是在下面定义的方法名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"greet"</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: <span class="string">'Vue.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 在 `methods` 对象中定义方法</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    greet: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 在方法里指向当前 Vue 实例</span></span><br><span class="line">      alert(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>)</span><br><span class="line">      <span class="comment">// `event` 是原生 DOM 事件</span></span><br><span class="line">      <span class="keyword">if</span> (event) &#123;</span><br><span class="line">        alert(event.target.tagName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用 JavaScript 直接调用方法</span></span><br><span class="line">example2.greet() <span class="comment">// =&gt; 'Hello Vue.js!'</span></span><br></pre></td></tr></table></figure>
<h3 id="内联处理器中的方法"><a href="#内联处理器中的方法" class="headerlink" title="内联处理器中的方法"></a>内联处理器中的方法</h3><p>除了直接绑定到一个方法，也可以在内联JavaScript语句中调用方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('hi')"</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('what')"</span>&gt;</span>Say what<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-3'</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">      alert(message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>有时也需要在内联语句处理器中访问原始的DOM事件，可以用特殊变量<code>$event</code>把它传入方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"warn('Form cannot be submitted yet.', $event)"</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  warn: <span class="function"><span class="keyword">function</span> (<span class="params">message, event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 现在我们可以访问原生事件对象</span></span><br><span class="line">    <span class="keyword">if</span> (event) &#123;</span><br><span class="line">      event.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line">    alert(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。</p>
<p>为了解决这个问题，Vue.js为<code>v-on</code>提供了<strong>事件修饰符</strong>。</p>
<p>修饰符是由点开头的指令后缀来表示的。</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.capture</code></li>
<li><code>.self</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：使用修饰符，顺序很重要；相同的代码会以同样的顺序产生。因此因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p>
<blockquote>
<p>2.1.4 增加</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不像其它只能对原生的 DOM 事件起作用的修饰符，<code>.once</code> 修饰符还能被用到自定义的<a href="https://cn.vuejs.org/v2/guide/components-custom-events.html" target="_blank" rel="noopener">组件事件</a>上。</p>
<blockquote>
<p>2.3.0 增加</p>
</blockquote>
<p>Vue 还对应 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters" target="_blank" rel="noopener"><code>addEventListener</code> 中的 <code>passive</code> 选项</a>提供了 <code>.passive</code> 修饰符。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">"onScroll"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个 <code>.passive</code> 修饰符尤其能够提升移动端的性能。</p>
<blockquote>
<p>注意：不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用，因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，<code>.passive</code> 会告诉浏览器你<em>不</em>想阻止事件的默认行为。</p>
</blockquote>
<h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><p>Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以直接将 <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values" target="_blank" rel="noopener"><code>KeyboardEvent.key</code></a> 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.page-down</span>=<span class="string">"onPageDown"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，处理函数只会在 <code>$event.key</code> 等于 <code>PageDown</code> 时被调用。</p>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (捕获“删除”和“退格”键)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<p>你还可以通过全局 <code>config.keyCodes</code> 对象<a href="https://cn.vuejs.org/v2/api/#keyCodes" target="_blank" rel="noopener">自定义按键修饰符别名</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用 `v-on:keyup.f1`</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">112</span></span><br></pre></td></tr></table></figure>
<h3 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h3><blockquote>
<p>2.1.0 增加</p>
</blockquote>
<p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.67</span>=<span class="string">"clear"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意修饰键与常规按键不同，在和 <code>keyup</code> 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 <code>ctrl</code> 的情况下释放其它按键，才能触发 <code>keyup.ctrl</code>。而单单释放 <code>ctrl</code> 也不会触发事件。如果你想要这样的行为，请为 <code>ctrl</code> 换用 <code>keyCode</code>：<code>keyup.17</code>。</p>
</blockquote>
<p><code>.exact</code>修饰符</p>
<blockquote>
<p>2.5.0 增加</p>
<p> 修饰符允许你控制由精确的系统修饰符组合触发的事件</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl.exact</span>=<span class="string">"onCtrlClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.exact</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>鼠标按钮修饰符</p>
<blockquote>
<p>2.2.0 新增</p>
</blockquote>
<ul>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li><code>.middle</code></li>
</ul>
<p>这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p>
<h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><blockquote>
<p>你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 <code>v-model</code> 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p>
</blockquote>
<p><code>v-model</code>会忽略所有表单元素的<code>value</code>、<code>checked</code>、<code>selected</code> attribute的初始值，而是将Vue Instance的数据作为数据来源。应该通过<code>data</code>选项来声明初始值。</p>
<p><code>v-model</code> 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 <code>value</code> 属性和 <code>input</code> 事件；</li>
<li>checkbox 和 radio 使用 <code>checked</code> 属性和 <code>change</code> 事件；</li>
<li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li>
</ul>
<ol>
<li><p>文本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Message is : &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多行文本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Multiline message is:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"white-space: pre-line;"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"add multiple lines"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在文本区域插值 (<code>&lt;textare&gt;&lt;textarea&gt;</code>) 并不会生效，应用 <code>v-model</code> 来代替。</p>
</li>
<li><p>复选框</p>
<p>单个复选框，绑定到布尔值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checked"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"checkbox"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>多个复选框，绑定到同一个数组：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'example-3'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"jack"</span> <span class="attr">value</span>=<span class="string">"Jack"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"jack"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"john"</span> <span class="attr">value</span>=<span class="string">"John"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"john"</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"mike"</span> <span class="attr">value</span>=<span class="string">"Mike"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"mike"</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-3'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    checkedNames: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>单选按钮</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"One"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"Two"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-4'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    picked: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>选择框</p>
<p>单选时：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'...'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>多选时：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-6"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span> <span class="attr">multiple</span> <span class="attr">style</span>=<span class="string">"width: 50px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-6'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>用<code>v-for</code>渲染的动态选项</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">"option in options"</span> <span class="attr">v-bind:value</span>=<span class="string">"option.value"</span>&gt;</span></span><br><span class="line">    &#123;&#123; option.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'...'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: <span class="string">'A'</span>,</span><br><span class="line">    options: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'One'</span>, <span class="attr">value</span>: <span class="string">'A'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'Two'</span>, <span class="attr">value</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'Three'</span>, <span class="attr">value</span>: <span class="string">'C'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h3><p>对于单选按钮，复选框和选择框的选项，<code>v-model</code>绑定的值通常是静态的字符串（复选框也可以是布尔值）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当选中时，`picked` 为字符串 "a" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span> <span class="attr">value</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- `toggle` 为 true 或 false --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"toggle"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当选中第一个选项时，`selected` 为字符串 "abc" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"abc"</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有时候想把值绑定到Vue Instance的一个动态属性上，这个时候可以用<code>v-bind</code>实现，并且这个属性的值可以不是字符串</p>
<ol>
<li><p>复选框</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"checkbox"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"toggle"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">true-value</span>=<span class="string">"yes"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">false-value</span>=<span class="string">"no"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line">vm.toggle === <span class="string">'yes'</span></span><br><span class="line"><span class="comment">// 当没有选中时</span></span><br><span class="line">vm.toggle === <span class="string">'no'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的 <code>true-value</code> 和 <code>false-value</code> attribute 并不会影响输入控件的 <code>value</code> attribute，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(比如“yes”或“no”)，请换用单选按钮。</p>
</blockquote>
</li>
<li><p>单选按钮</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">v-model</span>=<span class="string">"pick"</span> <span class="attr">v-bind:value</span>=<span class="string">"a"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当选中时</span></span><br><span class="line">vm.pick === vm.a</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>选择框的选项</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内联对象字面量 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-bind:value</span>=<span class="string">"&#123; number: 123 &#125;"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line"><span class="keyword">typeof</span> vm.selected <span class="comment">// =&gt; 'object'</span></span><br><span class="line">vm.selected.number <span class="comment">// =&gt; 123</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ol>
<li><p><code>.lazy</code></p>
<p>默认情况下，<code>v-model</code>在每次<code>input</code>事件触发后将输入框的值与数据进行同步。</p>
<p>可以通过添加<code>lazy</code>修饰符，从而转变为使用<code>change</code>事件进行同步：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">"msg"</span> &gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>.number</code></p>
<p>如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"number"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>即使在<code>type=&#39;number&#39;</code>时，HTML输入元素的值还是返回字符串。如果这个值无法被<code>parseFloat()</code>解析，则会返回原始的值。</p>
</li>
<li><p><code>.trim</code></p>
<p>自动过滤用户输入的首尾空白符</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">"msg"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="在组件上使用v-model"><a href="#在组件上使用v-model" class="headerlink" title="在组件上使用v-model"></a>在组件上使用<code>v-model</code></h3><blockquote>
<p>HTML 原生的输入元素类型并不总能满足需求。幸好，Vue 的组件系统允许你创建具有完全自定义行为且可复用的输入组件。这些输入组件甚至可以和 <code>v-model</code> 一起使用！要了解更多，请参阅组件指南中的<a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#自定义组件的-v-model" target="_blank" rel="noopener">自定义输入组件</a>。</p>
</blockquote>
<h2 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h2><h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 button-counter 的新组件</span></span><br><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 <code>`。我们可以在一个通过</code>new Vue` 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"components-demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">'#components-demo'</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>组件是可复用的Vue实例，所以它和<code>new Vue</code>接受相同的选项，例如<code>data</code>、<code>computed</code>、<code>watch</code>、<code>method</code>以及生命周期钩子等。唯一的例外是项<code>el</code>这样根实例特有的选项。</p>
<h3 id="组件的复用"><a href="#组件的复用" class="headerlink" title="组件的复用"></a>组件的复用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"components-demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当点击按钮后，每个组件各自独立维护它的<code>count</code>，因为每用一次组件，就会有一个它的新<strong>实例</strong>被创建</p>
<ol>
<li><p><code>data</code>必须是一个函数</p>
<p>组件的<code>data</code>选项和根实例不一样，必须是一个函数，因此每个是列可以维护一份被返回对象的独立的拷贝。</p>
<p>如果Vue没有这条规则，点击一个按钮可能影响所有组件实例</p>
</li>
</ol>
<h3 id="组件的组织"><a href="#组件的组织" class="headerlink" title="组件的组织"></a>组件的组织</h3><p>通常，一个Application会一颗嵌套的组件树的形式来组织：</p>
<p><img src="/images/vue/components.png" alt="components"></p>
<p>例如：可能有页头 、侧边栏、内容区等组件，每个组件又包含了其他的像导航链接、博文之类的组件。</p>
<p>为了能够在模板中使用，这些组件必须先注册以便Vue能够识别。</p>
<p>两种组件的注册类型：<strong>全局注册</strong>和<strong>局部注册</strong></p>
<p>全局注册</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component-name'</span>, &#123;</span><br><span class="line">  <span class="comment">// ... options ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>全局注册的组件可以用在其被注册之后的任何新创建的Vue根实例，也包括其组件树中的所有子组件的模板中。</p>
<h3 id="通过Prop向子组件传递数据"><a href="#通过Prop向子组件传递数据" class="headerlink" title="　通过Prop向子组件传递数据"></a>　通过Prop向子组件传递数据</h3><p>Prop是在组件上注册的一些自定义attribute。当一个值传递给一个prop attribute的时候，它就变成了那个组件实例的一个属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>,&#123;</span><br><span class="line">    props: [<span class="string">'title'</span>],</span><br><span class="line">    template: <span class="string">'&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>一个组件默认可以拥有任意数量的prop，任何值都可以传递给任何prop。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"My journey with Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"Blogging with Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"Why Vue is so fun"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在一个典型的应用中，可能在<code>data</code>里有一个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#blog-post-demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    posts: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">'My journey with Vue'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">'Blogging with Vue'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">'Why Vue is so fun'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"post in posts"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">"post.id"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">"post.title"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面所示，我们可以用<code>v-bind</code>来动态传递prop。</p>
<h3 id="单个根元素"><a href="#单个根元素" class="headerlink" title="单个根元素"></a>单个根元素</h3><p>当构建组件时，模板内通常包含多个内容：</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">    &#123;&#123;title&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是如果模板像上面这样写，Vue会提出错误，<code>every component must have a single root element</code>。我们需要将模板的内容包裹在一个复元素内，来修复这个问题，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blog-post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当组件变得越来月复杂的时候，为每个相关的信息定义一个prop会变得很麻烦。</p>
<p>这个时候需要对组件进行重构，将它变成接受一个单独的prop</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"post in posts"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">"post.id"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:post</span>=<span class="string">"post"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'post'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="blog-post"&gt;</span></span><br><span class="line"><span class="string">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-html="post.content"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的示例使用了JavaScript的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener">模板字符串</a>来让多行的模板更易读。它们在 IE 下并没有被支持，所以如果你需要在不 (经过 Babel 或 TypeScript 之类的工具) 编译的情况下支持 IE，请使用<a href="https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/" target="_blank" rel="noopener">折行转义字符</a>取而代之。</p>
</blockquote>
<h3 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h3><p>在上面定义的组件中，可能存在它的一些功能和父级组件进行沟通。</p>
<p>例如：引入一个辅助功能来放大部分内容字体，同时其他部分保持默认的字号。</p>
<p>在其父组件中，通过添加一个<code>postFontSize</code>数据属性来支持这个功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#blog-posts-events-demo"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        post: [<span class="comment">/* ...*/</span>],</span><br><span class="line">        postFontSize: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个属性可以在模板中用来控制文字的字号</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"blog-posts-events-demo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123;fontSize: postFontSize + 'em'&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">      		<span class="attr">v-for</span>=<span class="string">"post in posts"</span></span></span><br><span class="line"><span class="tag">      		<span class="attr">v-bind:key</span>=<span class="string">"post.id"</span></span></span><br><span class="line"><span class="tag">      		<span class="attr">v-bind:post</span>=<span class="string">"post"</span></span></span><br><span class="line"><span class="tag">    	&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在子组件添加按钮来放大字号：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'post'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="blog-post"&gt;</span></span><br><span class="line"><span class="string">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">      &lt;button&gt;</span></span><br><span class="line"><span class="string">        Enlarge text</span></span><br><span class="line"><span class="string">      &lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-html="post.content"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个时候按钮不会做任何事。</p>
<p>需要当点击按钮后告诉父级组件放大所有文本。</p>
<p>Vue实例提供了一个自定义事件系统来解决，让父级组件能够像处理原生DOM一样通过<code>v-on</code>来监听子组件实例的任意事件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag"> <span class="attr">...</span></span></span><br><span class="line"><span class="tag"> <span class="attr">v-on:enlarge-text</span>=<span class="string">"postFontSize += 0.1"</span></span></span><br><span class="line"><span class="tag">           &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同时子组件可以通过调用内建的<code>$emit</code>方法并传入事件名称来触发一个事件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"$emit('enlarge-text')"</span>&gt;</span></span><br><span class="line">    Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有了这个 <code>v-on:enlarge-text=&quot;postFontSize += 0.1&quot;</code> 监听器，父级组件就会接收该事件并更新 <code>postFontSize</code> 的值。</p>
<ol>
<li><p>使用事件抛出一个值</p>
<p>有时候用一个事件来抛出一个特定的值是有用的。</p>
<p>例如：想要让组件决定它的文本要放大多少。</p>
<p>可以使用<code>$emit</code>的第二个参数来提供这个值：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"$emit('enlarge-text', 0.1)"</span>&gt;</span></span><br><span class="line">    Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在父级组件监听这个事件的时候，可以通过<code>$event</code>来访问这个被抛出的值：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">"postFontSize+= $event"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者，如果父级组件采用事件处理方法来处理：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">"onEnlargeText"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么这个值作为第一个参数传入这个方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    onEnlargeText: <span class="function"><span class="keyword">function</span>(<span class="params">enlargeAmount</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.postFontSize += enlargeAmount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>在组件上使用<code>v-model</code></p>
<p>自定义事件也可以用于创建支持<code>v-model</code>的自定义输入组件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"searchText"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">"searchText"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">v-on:input</span>=<span class="string">"searchText = $event.target.value"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当在组件上使用时，<code>v-model</code>则会这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">"searchText"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">"searchText = $event"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了让它正常工作，这个组件内的<code>&lt;input&gt;</code>必须：</p>
<ul>
<li>将其 <code>value</code> attribute 绑定到一个名叫 <code>value</code> 的 prop 上</li>
<li>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>input</code> 事件抛出</li>
</ul>
<p>写成代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'custom-input'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'value'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      v-bind:value="value"</span></span><br><span class="line"><span class="string">      v-on:input="$emit('input', $event.target.value)"</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在<code>v-model</code>就可以在组件上运行起来：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">"searchText"</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="通过插槽分发内容"><a href="#通过插槽分发内容" class="headerlink" title="通过插槽分发内容"></a>通过插槽分发内容</h3><p>和HTML元素一样，我们也可能需要向一个组件传递内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alert-box</span>&gt;</span></span><br><span class="line">Something bad happened.</span><br><span class="line"><span class="tag">&lt;/<span class="name">alert-box</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Vue通过定义<code>&lt;slot&gt;</code>元素可以实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'alert-box'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="demo-alert-box"&gt;</span></span><br><span class="line"><span class="string">      &lt;strong&gt;Error!&lt;/strong&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>只需要在需要的地方加入插槽就行了。</p>
<h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>有的时候，在不同的组件之间进行动态切换是非常有用的，比如一个多标签的界面。</p>
<p>可以通过Vue的<code>&lt;component&gt;</code>元素加一个特殊的<code>is</code> attribute来实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>currentTabComponent</code> 可以包括</p>
<ul>
<li>已注册组件的名字，或</li>
<li>一个组件的选项对象</li>
</ul>
<p>你可以在<a href="https://jsfiddle.net/chrisvfritz/o3nycadu/" target="_blank" rel="noopener">这里</a>查阅并体验完整的代码，或在<a href="https://jsfiddle.net/chrisvfritz/b2qj69o1/" target="_blank" rel="noopener">这个版本</a>了解绑定组件选项对象，而不是已注册组件名的示例。</p>
<p>注意：<code>is</code>这个属性可以用于常规的HTML元素，但这些元素也将被视为组件。这意味着所有的attribute都会作为DOM attribute被绑定。</p>
<h3 id="解析DOM模板时的注意事项"><a href="#解析DOM模板时的注意事项" class="headerlink" title="解析DOM模板时的注意事项"></a>解析DOM模板时的注意事项</h3><p>有些HTML元素，比如<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;select&gt;</code>，对于那些元素可以出现在内部是有严格限制的。而有些元素只能出现在某些特定元素的内部，比如<code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code>、<code>&lt;option&gt;</code></p>
<p>这就会导致一些问题：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">blog-post-row</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个自定义组件会被作为无效的内容提升到外部，并导致最终渲染结果出错。</p>
<p>而<code>is</code> attribute提供了一种变通方法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"blog-post-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：<strong>当我们从以下来源使用模板的话，这个限制是不存在的</strong></p>
<ul>
<li>字符串 (例如：<code>template: &#39;...&#39;</code>)</li>
<li><a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">单文件组件 (<code>.vue</code>)</a></li>
<li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/14/ELMo%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DongxianGu">
      <meta itemprop="description" content="Life,Happy,Code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Summer So Cold">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/ELMo%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">ELMo算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-14 20:48:19" itemprop="dateCreated datePublished" datetime="2020-03-14T20:48:19+08:00">2020-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-24 09:20:54" itemprop="dateModified" datetime="2020-03-24T09:20:54+08:00">2020-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NLP/" itemprop="url" rel="index"><span itemprop="name">NLP</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/03/14/ELMo%E7%AE%97%E6%B3%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/03/14/ELMo%E7%AE%97%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ELMo算法"><a href="#ELMo算法" class="headerlink" title="ELMo算法"></a>ELMo算法</h1><p>ELMo,(Embeddings from Language Models)</p>
<p><a href="https://arxiv.org/pdf/1802.05365.pdf" target="_blank" rel="noopener">Paper</a></p>
<p>Paper的author认为对词语进行表征应该兼顾的问题：</p>
<ul>
<li>词语在语义和语法上用法的特点</li>
<li>随着语言环境的变化，用法也能够改变。</li>
</ul>
<p>这种算法的特点：每个词语的表征是整个输入语句的函数。</p>
<p>通过在大语料上以language model（$p(text)$）为目标来训练Bidirectional LSTM模型，再利用LSTM产生词语的表征。</p>
<p>在下游的NLP任务中，一般使用下游任务的Corpus（ignore label）对language model进行 微调，这种做法相当于到domain transfer，然后利用label的信息进行监督学习。</p>
<p>ELMo对词语的表征是“深”的，它们是BiLSTM中所有层的内部表征的函数。因此可以产生丰富的词语特征。</p>
<p>高层的LSTM的status可以捕捉到词语语义和语境相关的特征，因此可以来进行语义消歧，而底层的LSTM可以捕捉到语法方面的特征，可以做词性标注。将这两个结合起来，可以在下游的NLP Task中获得优势。</p>
<h2 id="Bidirectional-language-model"><a href="#Bidirectional-language-model" class="headerlink" title="　Bidirectional language model"></a>　Bidirectional language model</h2><p>ELMo从意思上是从语言模型中得到的嵌入。具体而言就是 双向语言模型</p>
<script type="math/tex; mode=display">
\begin{align}
& forward\;LM: \quad p(t_1,t_2,\cdots,t_N) = \prod_{k=1}^N p(t_k|t_1,t_2,\cdots,t_k-1) \\ 
& backward\;LM: \quad p(t_1,t_2,\cdots,t_N) = \prod_{k=1}^N p(t_k|t_{k+1},t_{k+2},\cdots,t_N)
\end{align}</script><p>其中$t$表示各种token。</p>
<p>对语言模型通常使用多层LSTM进行建模，ELMo的语言模型采用这种方式，使用叠加的双向LSTM来表示。</p>
<p>假设，输入的符号记为  $\mathbf{x}<em>k^{LM}$ （通过token embedding 或 a CNN over characters生成），然后将它输入到$L$ layers of LSTMs。每个位置$k$，每一层的LSTM都产生对应的<code>context-dependent</code>的表征$\vec{h}</em>{k,j}^{LM}，where\;j=1,2,\cdots,L$。这里的$j$表示第几层上的表征。顶层的LSTM的输出表示为$\vec{h}<em>{k,L}^{LM}$，最后使用Softmax归一化来预测下一个token $t</em>{k+1}$。对于<code>backward LSTMs</code>，给定$(t<em>{k+1},\cdots,t_N)$，每一层$j$产生表示$\overleftarrow{h}</em>{k,j}^{LM}，where\;j=1,2,\cdots,L$。</p>
<p>biLM将forward 和 backward 的LM集合起来。目标函数就是最大化前向和反向的对数似然函数。</p>
<script type="math/tex; mode=display">
\sum_{k=1}^N [\log p(t_k|t_1,\cdots,t_{k-1};\Theta_x,\overrightarrow{\Theta}_{LSTM},\Theta_s) + \log p(t_k|t+1,\cdots,t_{N};\Theta_x,\overleftarrow{\Theta}_{LSTM},\Theta_s)]</script><p>其中$\Theta_x$作为token表征，$\Theta_s$表示Softmax layer。</p>
<h2 id="ELMo"><a href="#ELMo" class="headerlink" title="ELMo"></a>ELMo</h2><p>在biLM中，ELMo的任务是将中间层进行特定的组合。</p>
<p>对于每个token $t_k$，$L-layer$的biLM需要计算出$2L+1$个表示</p>
<script type="math/tex; mode=display">
\begin{align}
R_k &= \{\mathbf{x}_k^{LM},\overrightarrow{h}_{k,j}^{LM},\overleftarrow{h}_{k,j}^{LM}|j=1,\cdots,L\} \\
& = \{h_{k,j}^{LM}|j=0,\cdots,L\}
\end{align}</script><p>其中$h<em>{k,0}^{LM}$是token layer，$h</em>{k,j}^{LM} = [\overrightarrow{h}<em>{k,j}^{LM},\overleftarrow{h}</em>{k,j}^{LM}]$对应每一个biLSTM layer。</p>
<p>对于下游的模型，ELMo 将$R$中的所有层合成一个单个向量，$\mathbf{ELMo}<em>k = E(R_k;\Theta_e)$。在TageLM和CoVe中只是简单的选择了高层的表示$E(R_k)=h</em>{k,L}^{LM}$。</p>
<p>通常，ELMo根据具体任务计算出所有层的权重：</p>
<script type="math/tex; mode=display">
\mathbf{ELMo}_k^{task} = E(R_k;\Theta^{task}) = \gamma^{task} \sum_{j=0}^L s_j^{task} h_{k,j}^{LM}</script><p>其中，$s^{task}$是softmax标准化的权重，$\gamma^{task}$是一个标量，使得任务模型能够放缩整个ELMo向量。</p>
<h2 id="Using-biLMs-for-supervised-NLP-task"><a href="#Using-biLMs-for-supervised-NLP-task" class="headerlink" title="Using biLMs for supervised NLP task"></a>Using biLMs for supervised NLP task</h2><p>给定一个预训练的biLM和对应NLP任务的监督学习模型。使用biLM来改善任务模型是一个简单的过程。只需要运行biLM然后记录下每个词的所有layer 表征。然后让任务模型学习所有表征的线性组合。</p>
<p>首先考虑没有使用biLM最低层的监督学习模型，大部分NLP监督模型在最底层使用通用的架构，能够以一般的方式增加ELMo到模型中去。</p>
<p>给定符号序列$(t_1,\cdots,t_N)$，使用预训练的词嵌入来对每个位置token构造上下文独立的符号表示$\mathbf{x}_k$。然后，这个模型将会产生上下文敏感的表示$\mathbf{h}_k$。</p>
<p>增加ELMo到监督模型中，我们首先需要冻结biLM的权重参数，然后将$\mathbf{x}_k$和$\mathbf{ELMo}_k^{task}$连接起来，将ELMo的增强后表征$[\mathbf{x}_k;\mathbf{ELMo}_k^{task}]$输入到任务的网络中。</p>
<p>作者发现，通过增加一定的Dropout到ELMo和通过$\lambda ||\mathbf{w}||_2^2$到loss正则化ELMo的权重。</p>
<blockquote>
<p>This imposes an inductive bias on the ELMo weights to<br>stay close to an average of all biLM layers.</p>
</blockquote>
<h2 id="Pre-trained-bidirectional-language-model-architecture"><a href="#Pre-trained-bidirectional-language-model-architecture" class="headerlink" title="Pre-trained bidirectional language model architecture"></a>Pre-trained bidirectional language model architecture</h2><p>特点：</p>
<ul>
<li>支持双向联合训练</li>
<li>在LSTM layers之间增加了 residual connection</li>
</ul>
<p>最终，模型使用了4096 units L=2的 biLSTM，512-D的投影以及第一层到第二层使用residual connention。上下文不敏感表示使用 2048 character n-gram Conv filters。一个线性映射层将它下降到512-D的表示。</p>
<p>结果，biLM为每个输入符号提供了三层表示。和传统词嵌入只提供一层的表示相反。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/11/Nodejs%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DongxianGu">
      <meta itemprop="description" content="Life,Happy,Code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Summer So Cold">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/11/Nodejs%E5%88%9D%E6%8E%A2/" class="post-title-link" itemprop="url">Nodejs初探</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-11 09:39:01" itemprop="dateCreated datePublished" datetime="2020-03-11T09:39:01+08:00">2020-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-09 11:02:04" itemprop="dateModified" datetime="2020-04-09T11:02:04+08:00">2020-04-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/03/11/Nodejs%E5%88%9D%E6%8E%A2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/03/11/Nodejs%E5%88%9D%E6%8E%A2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Nodejs初探"><a href="#Nodejs初探" class="headerlink" title="Nodejs初探"></a>Nodejs初探</h1><h2 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h2><blockquote>
<p>Node.js的所有的异步<strong>I/O</strong>操作在完成后会发送一个事件到事件队列。</p>
</blockquote>
<p>events模块只提供了一个对象：events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 events 模块</span></span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="comment">// 创建 eventEmitter 对象</span></span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//event.js 文件</span></span><br><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter; </span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> EventEmitter(); </span><br><span class="line">event.on(<span class="string">'some_event'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'some_event 事件触发'</span>); </span><br><span class="line">&#125;); </span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    event.emit(<span class="string">'some_event'</span>); </span><br><span class="line">&#125;, <span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//event.js 文件</span></span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>); </span><br><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.EventEmitter(); </span><br><span class="line">emitter.on(<span class="string">'someEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listener1'</span>, arg1, arg2); </span><br><span class="line">&#125;); </span><br><span class="line">emitter.on(<span class="string">'someEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listener2'</span>, arg1, arg2); </span><br><span class="line">&#125;); </span><br><span class="line">emitter.emit(<span class="string">'someEvent'</span>, <span class="string">'arg1 参数'</span>, <span class="string">'arg2 参数'</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #1</span></span><br><span class="line"><span class="keyword">var</span> listener1 = <span class="function"><span class="keyword">function</span> <span class="title">listener1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'监听器 listener1 执行。'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #2</span></span><br><span class="line"><span class="keyword">var</span> listener2 = <span class="function"><span class="keyword">function</span> <span class="title">listener2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'监听器 listener2 执行。'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，处理函数为 listener1 </span></span><br><span class="line">eventEmitter.addListener(<span class="string">'connection'</span>, listener1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，处理函数为 listener2</span></span><br><span class="line">eventEmitter.on(<span class="string">'connection'</span>, listener2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> eventListeners = eventEmitter.listenerCount(<span class="string">'connection'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(eventListeners + <span class="string">" 个监听器监听连接事件。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 connection 事件 </span></span><br><span class="line">eventEmitter.emit(<span class="string">'connection'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除监绑定的 listener1 函数</span></span><br><span class="line">eventEmitter.removeListener(<span class="string">'connection'</span>, listener1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"listener1 不再受监听。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发连接事件</span></span><br><span class="line">eventEmitter.emit(<span class="string">'connection'</span>);</span><br><span class="line"></span><br><span class="line">eventListeners = eventEmitter.listenerCount(<span class="string">'connection'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(eventListeners + <span class="string">" 个监听器监听连接事件。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕。"</span>);</span><br></pre></td></tr></table></figure>
<p>error事件</p>
<p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p>
<p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p>
<p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>); </span><br><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.EventEmitter(); </span><br><span class="line">emitter.emit(<span class="string">'error'</span>);</span><br></pre></td></tr></table></figure>
<p>大多数情况并不会直接使用EventEmitter，而是通过继承实现，比如fs、net、http，只要支持事件响应的核心模块都是它的子类。</p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><blockquote>
<p>Buffer类，用于创建专门存放二进制数据的缓存区</p>
</blockquote>
<ol>
<li><p>字符编码</p>
<p>Buffer 实例用于表示编码字符的序列，比如 UTF-8,UCS2,Base64等等。可以通过编码，将Buffer实例和普通的JS字符串相互转换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = Buffer.from(<span class="string">'runoob'</span>, <span class="string">'ascii'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 72756e6f6f62</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.toString(<span class="string">'hex'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 cnVub29i</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.toString(<span class="string">'base64'</span>));</span><br></pre></td></tr></table></figure>
<p>当前Node.js支持的编码包括</p>
<ul>
<li><strong>ascii</strong> - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</li>
<li><strong>utf8</strong> - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</li>
<li><strong>utf16le</strong> - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</li>
<li><strong>ucs2</strong> - <strong>utf16le</strong> 的别名。</li>
<li><strong>base64</strong> - Base64 编码。</li>
<li><strong>latin1</strong> - 一种把 <strong>Buffer</strong> 编码成一字节编码的字符串的方式。</li>
<li><strong>binary</strong> - <strong>latin1</strong> 的别名。</li>
<li><strong>hex</strong> - 将每个字节编码为两个十六进制字符。</li>
</ul>
</li>
<li><p>创建Buffer实例</p>
<ul>
<li><strong>Buffer.alloc(size[, fill[, encoding]])：</strong> 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</li>
<li><strong>Buffer.allocUnsafe(size)：</strong> 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</li>
<li><strong>Buffer.allocUnsafeSlow(size)</strong></li>
<li><strong>Buffer.from(array)：</strong> 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）</li>
<li><strong>Buffer.from(arrayBuffer[, byteOffset[, length]])：</strong> 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</li>
<li><strong>Buffer.from(buffer)：</strong> 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</li>
<li><strong>Buffer.from(string[, encoding])：</strong> 返回一个被 string 的值初始化的新的 Buffer 实例</li>
</ul>
</li>
<li><p>写入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.write(string[, offset[, length]][, encoding])</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>string</strong> - 写入缓冲区的字符串。</li>
<li><strong>offset</strong> - 缓冲区开始写入的索引值，默认为 0 。</li>
<li><strong>length</strong> - 写入的字节数，默认为 buffer.length</li>
<li><strong>encoding</strong> - 使用的编码。默认为 ‘utf8’ 。</li>
</ul>
</li>
<li><p>读取</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.toString([encoding[, start[, end]]])</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>encoding</strong> - 使用的编码。默认为 ‘utf8’ 。</li>
<li><strong>start</strong> - 指定开始读取的索引位置，默认为 0。</li>
<li><strong>end</strong> - 结束位置，默认为缓冲区的末尾。</li>
</ul>
</li>
<li><p>转换为JSON对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.toJSON()</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = Buffer.from([<span class="number">0x1</span>, <span class="number">0x2</span>, <span class="number">0x3</span>, <span class="number">0x4</span>, <span class="number">0x5</span>]);</span><br><span class="line"><span class="keyword">const</span> json = <span class="built_in">JSON</span>.stringify(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: &#123;"type":"Buffer","data":[1,2,3,4,5]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(json);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">JSON</span>.parse(json, (key, value) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> value &amp;&amp; value.type === <span class="string">'Buffer'</span> ?</span><br><span class="line">    Buffer.from(value.data) :</span><br><span class="line">    value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: &lt;Buffer 01 02 03 04 05&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(copy);</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.concat(list[, totalLength])</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>list</strong> - 用于合并的 Buffer 对象数组列表。</li>
<li><strong>totalLength</strong> - 指定合并后Buffer对象的总长度。</li>
</ul>
</li>
<li><p>比较</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer1 = Buffer.from(<span class="string">'ABC'</span>);</span><br><span class="line"><span class="keyword">var</span> buffer2 = Buffer.from(<span class="string">'ABCD'</span>);</span><br><span class="line"><span class="keyword">var</span> result = buffer1.compare(buffer2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(buffer1 + <span class="string">" 在 "</span> + buffer2 + <span class="string">"之前"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(buffer1 + <span class="string">" 与 "</span> + buffer2 + <span class="string">"相同"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(buffer1 + <span class="string">" 在 "</span> + buffer2 + <span class="string">"之后"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf1 = Buffer.from(<span class="string">'abcdefghijkl'</span>);</span><br><span class="line"><span class="keyword">var</span> buf2 = Buffer.from(<span class="string">'RUNOOB'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将 buf2 插入到 buf1 指定位置上</span></span><br><span class="line">buf2.copy(buf1, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buf1.toString());</span><br></pre></td></tr></table></figure>
</li>
<li><p>裁剪</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.slice([start[, end]])</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer1 = Buffer.from(<span class="string">'runoob'</span>);</span><br><span class="line"><span class="comment">// 剪切缓冲区</span></span><br><span class="line"><span class="keyword">var</span> buffer2 = buffer1.slice(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"buffer2 content: "</span> + buffer2.toString());</span><br></pre></td></tr></table></figure>
</li>
<li><p>长度gg</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = Buffer.from(<span class="string">'www.runoob.com'</span>);</span><br><span class="line"><span class="comment">//  缓冲区长度</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"buffer length: "</span> + buffer.length);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><blockquote>
<p>Stream是一个抽象接口，Node中的很多对象实现了这个接口，比如http发起的请求对象，stdout等等。</p>
</blockquote>
<p>Stream一共包括四种类型：</p>
<ul>
<li>Readable</li>
<li>Writeable</li>
<li>Duplex 可读可写操作</li>
<li>Transform 操作被写入的数据，然后读出结果</li>
</ul>
<p>Stream对象都是EventEmitter的实例。包括的事件有</p>
<ul>
<li><strong>data</strong> - 当有数据可读时触发。</li>
<li><strong>end</strong> - 没有更多的数据可读时触发。</li>
<li><strong>error</strong> - 在接收和写入过程中发生错误时触发。</li>
<li><strong>finish</strong> - 所有数据已被写入到底层系统时触发。</li>
</ul>
<ol>
<li><p>从流中读取数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可读流</span></span><br><span class="line"><span class="keyword">var</span> readerStream = fs.createReadStream(<span class="string">'input.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置编码为 utf8。</span></span><br><span class="line">readerStream.setEncoding(<span class="string">'UTF8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理流事件 --&gt; data, end, and error</span></span><br><span class="line">readerStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">   data += chunk;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readerStream.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readerStream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(err.stack);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>写入流</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">'菜鸟教程官网地址：www.runoob.com'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可以写入的流，写入到文件 output.txt 中</span></span><br><span class="line"><span class="keyword">var</span> writerStream = fs.createWriteStream(<span class="string">'output.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 utf8 编码写入数据</span></span><br><span class="line">writerStream.write(data,<span class="string">'UTF8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记文件末尾</span></span><br><span class="line">writerStream.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理流事件 --&gt; data, end, and error</span></span><br><span class="line">writerStream.on(<span class="string">'finish'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"写入完成。"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">writerStream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(err.stack);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>管道流</p>
<blockquote>
<p>管道提供了输出流到输入流的机制，用于从一个流获取数据传递到另一个流中</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可读流</span></span><br><span class="line"><span class="keyword">var</span> readerStream = fs.createReadStream(<span class="string">'input.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可写流</span></span><br><span class="line"><span class="keyword">var</span> writerStream = fs.createWriteStream(<span class="string">'output.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道读写操作</span></span><br><span class="line"><span class="comment">// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中</span></span><br><span class="line">readerStream.pipe(writerStream);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>链式流</p>
<p>压缩文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 input.txt 文件为 input.txt.gz</span></span><br><span class="line">fs.createReadStream(<span class="string">'input.txt'</span>)</span><br><span class="line">  .pipe(zlib.createGzip())</span><br><span class="line">  .pipe(fs.createWriteStream(<span class="string">'input.txt.gz'</span>));</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"文件压缩完成。"</span>);</span><br></pre></td></tr></table></figure>
<p>解压文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解压 input.txt.gz 文件为 input.txt</span></span><br><span class="line">fs.createReadStream(<span class="string">'input.txt.gz'</span>)</span><br><span class="line">  .pipe(zlib.createGunzip())</span><br><span class="line">  .pipe(fs.createWriteStream(<span class="string">'input.txt'</span>));</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"文件解压完成。"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h2><blockquote>
<p>为了Node.js的文件可以互相使用，通过提供模块来实现。</p>
<p>模块是Node.js Application的基本组成部分。文件和模块是一对一的。</p>
<p>一个Node.js文件就是一个模块，遮盖文件可以是JavaScript代码、JSON或编译过的C/C++扩展</p>
</blockquote>
<ol>
<li><p>创建模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="built_in">require</span>(<span class="string">'./hello'</span>);</span><br><span class="line">hello.world();</span><br></pre></td></tr></table></figure>
<p><code>require(&#39;./hello&#39;)</code>引入了当前目录下的<code>hello.js</code>文件，node.js默认后缀是js。</p>
<p>Node.js提供了<code>export</code>和<code>require</code>两个对象</p>
<ul>
<li><code>export</code>:模块公开的接口</li>
<li><code>require</code>:从外部获取模块的接口，即获取模块的<code>export</code>对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.world = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以直接访问<code>hello.js</code>中<code>export</code>对象的成员函数了。</p>
<p>有时候需要将一个对象封装到模块中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.js </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> name; </span><br><span class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123; </span><br><span class="line">        name = thyName; </span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name); </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">module</span>.exports = Hello;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Hello = <span class="built_in">require</span>(<span class="string">'./hello'</span>); </span><br><span class="line">hello = <span class="keyword">new</span> Hello(); </span><br><span class="line">hello.setName(<span class="string">'BYVoid'</span>); </span><br><span class="line">hello.sayHello();</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块的查找策略</p>
<p>require方法中的文件查找策略：</p>
<p>Node.js中存在四种模块：原生模块和三种文件模块。加载的过程如下。</p>
<p><img src="/images/nodejs/nodejs-require.jpg" alt="nodejs-require"></p>
</li>
</ol>
<p>优先级：文件模块缓存区 &gt;&gt; 原生模块 &gt;&gt; 文件模块</p>
<p>当文件模块缓存和原生模块都不满足的话，Node.js就会解析require传入的参数，从文件系统中加载实际的文件。</p>
<p>require参数</p>
<ul>
<li>http、fs、path等，原生模块</li>
<li>./mod or ../mod，相对路径的文件模块</li>
<li>/pathtomodule/mod，绝对路径的文件模块</li>
<li>mod，非原生模块的文件模块</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在JavaScript中，一个函数可以作为参数传递，在Node.js中也是类似的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">someFunction, value</span>) </span>&#123;</span><br><span class="line">  someFunction(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execute(say, <span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure>
<p>匿名函数，将函数作为变量传递，可以定义和传递，不需要事先定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">someFunction, value</span>) </span>&#123;</span><br><span class="line">  someFunction(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execute(<span class="function"><span class="keyword">function</span>(<span class="params">word</span>)</span>&#123; <span class="built_in">console</span>.log(word) &#125;, <span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure>
<p>http模块中的函数传递</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;).listen(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由需要请求的URL和其他的GET和POST等等的参数，然后由路由决定执行代码，因此，需要检查HTTP请求，从中提取出这些信息。</p>
<p>在http模块中，所有的数据都包含在<code>request</code>对象中。该对象作为onRequest()回调函数的第一个参数传递，但是为了解析数据，还需要url和querystring模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                   url.parse(string).query</span><br><span class="line">                                           |</span><br><span class="line">           url.parse(string).pathname      |</span><br><span class="line">                       |                   |</span><br><span class="line">                       |                   |</span><br><span class="line">                     ------ -------------------</span><br><span class="line">http:&#x2F;&#x2F;localhost:8888&#x2F;start?foo&#x3D;bar&amp;hello&#x3D;world</span><br><span class="line">                                ---       -----</span><br><span class="line">                                 |          |</span><br><span class="line">                                 |          |</span><br><span class="line">              querystring.parse(queryString)[&quot;foo&quot;]    |</span><br><span class="line">                                            |</span><br><span class="line">                         querystring.parse(queryString)[&quot;hello&quot;]</span><br></pre></td></tr></table></figure>
<p>server.js文件代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</span><br><span class="line"> </span><br><span class="line">    route(pathname);</span><br><span class="line"> </span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">    response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<p>router.js文件代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure>
<p>index.js 代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">"./server"</span>);</span><br><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">"./router"</span>);</span><br><span class="line"> </span><br><span class="line">server.start(router.route);</span><br></pre></td></tr></table></figure>
<h2 id="全局对象"><a href="#全局对象" class="headerlink" title="　全局对象"></a>　全局对象</h2><blockquote>
<p>全局对象本身及其属性可以在程序的任何地方访问。</p>
<p>Node.js中的全局对象是<strong>global</strong>，所有的全局变量都是global对象的属性。</p>
<p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p>
</blockquote>
<ol>
<li><p>全局对象和全局变量</p>
<p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：</p>
<ul>
<li>在最外层定义的变量；</li>
<li>全局对象的属性；</li>
<li>隐式定义的变量（未定义直接赋值的变量）。</li>
</ul>
</li>
<li><p><strong>__filename</strong>：当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。</p>
</li>
<li><p><strong>__dirname</strong> 表示当前执行脚本所在的目录。</p>
</li>
<li><p><strong>setTimeout(cb, ms)</strong> 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。</p>
</li>
<li><p><strong>clearTimeout( t )</strong> 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 <strong>t</strong> 是通过 setTimeout() 函数创建的定时器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log( <span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两秒后执行以上函数</span></span><br><span class="line"><span class="keyword">var</span> t = setTimeout(printHello, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除定时器</span></span><br><span class="line">clearTimeout(t);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>setInterval(cb, ms)</strong> 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log( <span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两秒后执行以上函数</span></span><br><span class="line">setInterval(printHello, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>console 用于提供控制台标准输出</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>console.log([data][, …])</strong> 向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>console.info([data][, …])</strong> 该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>console.error([data][, …])</strong> 输出错误消息的。控制台在出现错误时会显示是红色的叉子。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>console.warn([data][, …])</strong> 输出警告消息。控制台出现有黄色的惊叹号。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>console.dir(obj[, options])</strong> 用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>console.time(label)</strong> 输出时间，表示计时开始。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>console.timeEnd(label)</strong> 结束时间，表示计时结束。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>console.trace(message[, …])</strong> 当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace 就行了。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>console.assert(value[, message][, …])</strong> 用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>process 是一个全局变量，即 global 对象的属性。</p>
<p>它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">事件 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>exit</strong> 当进程准备退出时触发。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>beforeExit</strong> 当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>uncaughtException</strong> 当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>Signal 事件</strong> 当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下代码永远不会执行</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"该代码不会执行"</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'退出码为:'</span>, code);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行结束"</span>);</span><br></pre></td></tr></table></figure>
<p>退出状态码如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">名称 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>Uncaught Fatal Exception</strong> 有未捕获异常，并且没有被域或 uncaughtException 处理函数处理。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>Unused</strong> 保留</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>Internal JavaScript Parse Error</strong> JavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>Internal JavaScript Evaluation Failure</strong> JavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>Fatal Error</strong> V8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>Non-function Internal Exception Handler</strong> 未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>Internal Exception Handler Run-Time Failure</strong> 未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 process.on(‘uncaughtException’) 或 domain.on(‘error’) 抛出了异常。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>Unused</strong> 保留</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>Invalid Argument</strong> 可能是给了未知的参数，或者给的参数没有值。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><strong>Internal JavaScript Run-Time Failure</strong> JavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><strong>Invalid Debug Argument</strong> 设置了参数—debug 和/或 —debug-brk，但是选择了错误端口。</td>
</tr>
<tr>
<td style="text-align:left">128</td>
<td style="text-align:left"><strong>Signal Exits</strong> 如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。</td>
</tr>
</tbody>
</table>
</div>
<p>Process 提供了很多有用的属性，便于我们更好的控制系统的交互：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号.</th>
<th style="text-align:left">属性 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>stdout</strong> 标准输出流。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>stderr</strong> 标准错误流。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>stdin</strong> 标准输入流。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>argv</strong> argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>execPath</strong> 返回执行当前脚本的 Node 二进制文件的绝对路径。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>execArgv</strong> 返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>env</strong> 返回一个对象，成员为当前 shell 的环境变量</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>exitCode</strong> 进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>version</strong> Node 的版本，比如v0.10.18。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><strong>versions</strong> 一个属性，包含了 node 的版本和依赖.</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><strong>config</strong> 一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 “config.gypi” 文件相同。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><strong>pid</strong> 当前进程的进程号。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><strong>title</strong> 进程名，默认值为”node”，可以自定义该值。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><strong>arch</strong> 当前 CPU 的架构：’arm’、’ia32’ 或者 ‘x64’。</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><strong>platform</strong> 运行程序所在的平台系统 ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ 或 ‘win32’</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><strong>mainModule</strong> require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出到终端</span></span><br><span class="line">process.stdout.write(<span class="string">"Hello World!"</span> + <span class="string">"\n"</span>);</span><br><span class="line"><span class="comment">// 通过参数读取</span></span><br><span class="line">process.argv.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, array</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(index + <span class="string">': '</span> + val);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 获取执行路径</span></span><br><span class="line"><span class="built_in">console</span>.log(process.execPath);</span><br><span class="line"><span class="comment">// 平台信息</span></span><br><span class="line"><span class="built_in">console</span>.log(process.platform);</span><br></pre></td></tr></table></figure>
<p>Process 提供了很多有用的方法，便于我们更好的控制系统的交互：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>abort()</strong> 这将导致 node 触发 abort 事件。会让 node 退出并生成一个核心文件。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>chdir(directory)</strong> 改变当前工作进程的目录，如果操作失败抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>cwd()</strong> 返回当前进程的工作目录</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>exit([code])</strong> 使用指定的 code 结束进程。如果忽略，将会使用 code 0。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>getgid()</strong> 获取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字 id，而不是名字。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>setgid(id)</strong> 设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>getuid()</strong> 获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>setuid(id)</strong> 设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>getgroups()</strong> 返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><strong>setgroups(groups)</strong> 设置进程的群组 ID。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><strong>initgroups(user, extra_group)</strong> 读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><strong>kill(pid[, signal])</strong> 发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 ‘SIGINT’ 或 ‘SIGHUP’。如果忽略，信号会是 ‘SIGTERM’。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><strong>memoryUsage()</strong> 返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><strong>nextTick(callback)</strong> 一旦当前事件循环结束，调用回调函数。</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><strong>umask([mask])</strong> 设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><strong>uptime()</strong> 返回 Node 已经运行的秒数。</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left"><strong>hrtime()</strong> 返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。 你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出当前目录</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'当前目录: '</span> + process.cwd());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出当前版本</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'当前版本: '</span> + process.version);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出内存使用情况</span></span><br><span class="line"><span class="built_in">console</span>.log(process.memoryUsage());</span><br></pre></td></tr></table></figure>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心 JavaScript 的功能 过于精简的不足。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li><p>util.callbackify</p>
<p><strong>util.callbackify(original)</strong> 将 <code>async</code> 异步函数（或者一个返回值为 <code>Promise</code> 的函数）转换成遵循异常优先的<strong>回调风格</strong>的函数，例如将 <code>(err, value) =&gt; ...</code> 回调作为最后一个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> callbackFunction = util.callbackify(fn);</span><br><span class="line"></span><br><span class="line">callbackFunction(<span class="function">(<span class="params">err, ret</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(ret);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>回调函数是异步执行的，并且有异常堆栈错误跟踪。如果回调函数抛出一个异常，进程就会触发<code>uncaughtException</code>,如果没有被捕获，进程就会推出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> callbackFunction = util.callbackify(fn);</span><br><span class="line"></span><br><span class="line">callbackFunction(<span class="function">(<span class="params">err, ret</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 当 Promise 被以 `null` 拒绝时，它被包装为 Error 并且原始值存储在 `reason` 中。</span></span><br><span class="line">  err &amp;&amp; err.hasOwnProperty(<span class="string">'reason'</span>) &amp;&amp; err.reason === <span class="literal">null</span>;  <span class="comment">// true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>util.inherits</p>
<p><strong>util.inherits(constructor, superConstructor)</strong> 是一个实现对象间原型继承的函数。</p>
<p>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有提供对象继承的语言级别特性，而是通过原型复制来实现的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'base'</span>; </span><br><span class="line">    <span class="keyword">this</span>.base = <span class="number">1991</span>; </span><br><span class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name); </span><br><span class="line">    &#125;; </span><br><span class="line">&#125; </span><br><span class="line">Base.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'sub'</span>; </span><br><span class="line">&#125; </span><br><span class="line">util.inherits(Sub, Base); </span><br><span class="line"><span class="keyword">var</span> objBase = <span class="keyword">new</span> Base(); </span><br><span class="line">objBase.showName(); </span><br><span class="line">objBase.sayHello(); </span><br><span class="line"><span class="built_in">console</span>.log(objBase); </span><br><span class="line"><span class="keyword">var</span> objSub = <span class="keyword">new</span> Sub(); </span><br><span class="line">objSub.showName(); </span><br><span class="line"><span class="comment">//objSub.sayHello(); </span></span><br><span class="line"><span class="built_in">console</span>.log(objSub);</span><br></pre></td></tr></table></figure>
</li>
<li><p>util.inspect</p>
<p><strong>util.inspect(object,[showHidden],[depth],[colors])</strong> 是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'byvoid'</span>; </span><br><span class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name; </span><br><span class="line">    &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(util.inspect(obj)); </span><br><span class="line"><span class="built_in">console</span>.log(util.inspect(obj, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>util.isArray(obj)</p>
<p>如果给定的参数 “object” 是一个数组返回 true，否则返回 false。</p>
</li>
<li><p>util.isRegExp(object)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line">util.isRegExp(<span class="regexp">/some regexp/</span>)</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">util.isRegExp(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'another regexp'</span>))</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">util.isRegExp(&#123;&#125;)</span><br><span class="line">  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>util.isDate(obj)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line">util.isDate(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">util.isDate(<span class="built_in">Date</span>())</span><br><span class="line">  <span class="comment">// false (without 'new' returns a String)</span></span><br><span class="line">util.isDate(&#123;&#125;)</span><br><span class="line">  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><blockquote>
<p>Node.js提供了一组类似UNIX/POSIX标准的文件操作API。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>异步和同步</p>
<p>fs模块中的方法均提供了同步和异步version。</p>
<p>异步的方法函数的最后一个参数为回调函数，回调函数的第一个参数包含了错误信息</p>
<p>异步的方法性能更高，速度更快，没有阻塞。</p>
</li>
<li><p>打开文件</p>
<p>fs.open(path, flags[, mode], callback)</p>
<ul>
<li><strong>path</strong> - 文件的路径。</li>
<li><strong>flags</strong> - 文件打开的行为。具体值详见下文。</li>
<li><strong>mode</strong> - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。</li>
<li><strong>callback</strong> - 回调函数，带有两个参数如：callback(err, fd)。</li>
</ul>
<p>| Flag | 描述                                                   |<br>| :—- | :——————————————————————————- |<br>| r    | 以读取模式打开文件。如果文件不存在抛出异常。           |<br>| r+   | 以读写模式打开文件。如果文件不存在抛出异常。           |<br>| rs   | 以同步的方式读取文件。                                 |<br>| rs+  | 以同步的方式读取和写入文件。                           |<br>| w    | 以写入模式打开文件，如果文件不存在则创建。             |<br>| wx   | 类似 ‘w’，但是如果文件路径存在，则文件写入失败。       |<br>| w+   | 以读写模式打开文件，如果文件不存在则创建。             |<br>| wx+  | 类似 ‘w+’， 但是如果文件路径存在，则文件读写失败。     |<br>| a    | 以追加模式打开文件，如果文件不存在则创建。             |<br>| ax   | 类似 ‘a’， 但是如果文件路径存在，则文件追加失败。      |<br>| a+   | 以读取追加模式打开文件，如果文件不存在则创建。         |<br>| ax+  | 类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。 |</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步打开文件</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备打开文件！"</span>);</span><br><span class="line">fs.open(<span class="string">'input.txt'</span>, <span class="string">'r+'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"文件打开成功！"</span>);     </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取文件信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.stat(path, callback)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，带有两个参数如：(err, stats), <strong>stats</strong> 是 fs.Stats 对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备打开文件！"</span>);</span><br><span class="line">fs.stat(<span class="string">'input.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(stats);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"读取文件信息成功！"</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 检测文件类型</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"是否为文件(isFile) ? "</span> + stats.isFile());</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"是否为目录(isDirectory) ? "</span> + stats.isDirectory());    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>| 方法                      | 描述                                                         |<br>| :———————————— | :—————————————————————————————- |<br>| stats.isFile()            | 如果是文件返回 true，否则返回 false。                        |<br>| stats.isDirectory()       | 如果是目录返回 true，否则返回 false。                        |<br>| stats.isBlockDevice()     | 如果是块设备返回 true，否则返回 false。                      |<br>| stats.isCharacterDevice() | 如果是字符设备返回 true，否则返回 false。                    |<br>| stats.isSymbolicLink()    | 如果是软链接返回 true，否则返回 false。                      |<br>| stats.isFIFO()            | 如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。 |<br>| stats.isSocket()          | 如果是 Socket 返回 true，否则返回 false。                    |</p>
</li>
<li><p>写入文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(file, data[, options], callback)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>file</strong> - 文件名或文件描述符。</li>
<li><strong>data</strong> - 要写入文件的数据，可以是 String(字符串) 或 Buffer(缓冲) 对象。</li>
<li><strong>options</strong> - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 ‘w’</li>
<li><strong>callback</strong> - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备写入文件"</span>);</span><br><span class="line">fs.writeFile(<span class="string">'input.txt'</span>, <span class="string">'我是通 过fs.writeFile 写入文件的内容'</span>,  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"数据写入成功！"</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"--------我是分割线-------------"</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"读取写入的数据！"</span>);</span><br><span class="line">   fs.readFile(<span class="string">'input.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"异步读取文件数据: "</span> + data.toString());</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.read(fd, buffer, offset, length, position, callback)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>fd</strong> - 通过 fs.open() 方法返回的文件描述符。</li>
<li><strong>buffer</strong> - 数据写入的缓冲区。</li>
<li><strong>offset</strong> - 缓冲区写入的写入偏移量。</li>
<li><strong>length</strong> - 要从文件中读取的字节数。</li>
<li><strong>position</strong> - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。</li>
<li><strong>callback</strong> - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer.alloc(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备打开已存在的文件！"</span>);</span><br><span class="line">fs.open(<span class="string">'input.txt'</span>, <span class="string">'r+'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"文件打开成功！"</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"准备读取文件："</span>);</span><br><span class="line">   fs.read(fd, buf, <span class="number">0</span>, buf.length, <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, bytes</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err)&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(bytes + <span class="string">"  字节被读取"</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 仅输出读取的字节</span></span><br><span class="line">      <span class="keyword">if</span>(bytes &gt; <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(buf.slice(<span class="number">0</span>, bytes).toString());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.close(fd, callback)</span><br></pre></td></tr></table></figure>
<p>参数使用说明如下：</p>
<ul>
<li><strong>fd</strong> - 通过 fs.open() 方法返回的文件描述符。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer.alloc(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备打开文件！"</span>);</span><br><span class="line">fs.open(<span class="string">'input.txt'</span>, <span class="string">'r+'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"文件打开成功！"</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"准备读取文件！"</span>);</span><br><span class="line">   fs.read(fd, buf, <span class="number">0</span>, buf.length, <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, bytes</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err)&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 仅输出读取的字节</span></span><br><span class="line">      <span class="keyword">if</span>(bytes &gt; <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(buf.slice(<span class="number">0</span>, bytes).toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 关闭文件</span></span><br><span class="line">      fs.close(fd, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (err)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">         &#125; </span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"文件关闭成功"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>截取文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.ftruncate(fd, len, callback)</span><br></pre></td></tr></table></figure>
<p>参数使用说明如下：</p>
<ul>
<li><strong>fd</strong> - 通过 fs.open() 方法返回的文件描述符。</li>
<li><strong>len</strong> - 文件内容截取的长度。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer.alloc(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备打开文件！"</span>);</span><br><span class="line">fs.open(<span class="string">'input.txt'</span>, <span class="string">'r+'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"文件打开成功！"</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"截取10字节内的文件内容，超出部分将被去除。"</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 截取文件</span></span><br><span class="line">   fs.ftruncate(fd, <span class="number">10</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err)&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"文件截取成功。"</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"读取相同的文件"</span>); </span><br><span class="line">      fs.read(fd, buf, <span class="number">0</span>, buf.length, <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, bytes</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (err)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 仅输出读取的字节</span></span><br><span class="line">         <span class="keyword">if</span>(bytes &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(buf.slice(<span class="number">0</span>, bytes).toString());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 关闭文件</span></span><br><span class="line">         fs.close(fd, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err)&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(err);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"文件关闭成功！"</span>);</span><br><span class="line">         &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.unlink(path, callback)</span><br></pre></td></tr></table></figure>
<p>参数使用说明如下：</p>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备删除文件！"</span>);</span><br><span class="line">fs.unlink(<span class="string">'input.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"文件删除成功！"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建目录</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.mkdir(path[, options], callback)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li>options 参数可以是：<ul>
<li><strong>recursive</strong> - 是否以递归的方式创建目录，默认为 false。</li>
<li><strong>mode</strong> - 设置目录权限，默认为 0777。</li>
</ul>
</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.mkdir(<span class="string">'/tmp/a/apple'</span>, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取目录</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readdir(path, callback)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"查看 /tmp 目录"</span>);</span><br><span class="line">fs.readdir(<span class="string">"/tmp/"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   files.forEach( <span class="function"><span class="keyword">function</span> (<span class="params">file</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log( file );</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除目录</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.rmdir(path, callback)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="comment">// 执行前创建一个空的 /tmp/test 目录</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备删除目录 /tmp/test"</span>);</span><br><span class="line">fs.rmdir(<span class="string">"/tmp/test"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"读取 /tmp 目录"</span>);</span><br><span class="line">   fs.readdir(<span class="string">"/tmp/"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">      &#125;</span><br><span class="line">      files.forEach( <span class="function"><span class="keyword">function</span> (<span class="params">file</span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log( file );</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>fs.rename(oldPath, newPath, callback)</strong> 异步 rename().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>fs.ftruncate(fd, len, callback)</strong> 异步 ftruncate().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>fs.ftruncateSync(fd, len)</strong> 同步 ftruncate()</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>fs.truncate(path, len, callback)</strong> 异步 truncate().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>fs.truncateSync(path, len)</strong> 同步 truncate()</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>fs.chown(path, uid, gid, callback)</strong> 异步 chown().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>fs.chownSync(path, uid, gid)</strong> 同步 chown()</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>fs.fchown(fd, uid, gid, callback)</strong> 异步 fchown().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>fs.fchownSync(fd, uid, gid)</strong> 同步 fchown()</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><strong>fs.lchown(path, uid, gid, callback)</strong> 异步 lchown().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><strong>fs.lchownSync(path, uid, gid)</strong> 同步 lchown()</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><strong>fs.chmod(path, mode, callback)</strong> 异步 chmod().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><strong>fs.chmodSync(path, mode)</strong> 同步 chmod().</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><strong>fs.fchmod(fd, mode, callback)</strong> 异步 fchmod().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><strong>fs.fchmodSync(fd, mode)</strong> 同步 fchmod().</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><strong>fs.lchmod(path, mode, callback)</strong> 异步 lchmod().回调函数没有参数，但可能抛出异常。Only available on Mac OS X.</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left"><strong>fs.lchmodSync(path, mode)</strong> 同步 lchmod().</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left"><strong>fs.stat(path, callback)</strong> 异步 stat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left"><strong>fs.lstat(path, callback)</strong> 异步 lstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left"><strong>fs.fstat(fd, callback)</strong> 异步 fstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</td>
</tr>
<tr>
<td style="text-align:left">21</td>
<td style="text-align:left"><strong>fs.statSync(path)</strong> 同步 stat(). 返回 fs.Stats 的实例。</td>
</tr>
<tr>
<td style="text-align:left">22</td>
<td style="text-align:left"><strong>fs.lstatSync(path)</strong> 同步 lstat(). 返回 fs.Stats 的实例。</td>
</tr>
<tr>
<td style="text-align:left">23</td>
<td style="text-align:left"><strong>fs.fstatSync(fd)</strong> 同步 fstat(). 返回 fs.Stats 的实例。</td>
</tr>
<tr>
<td style="text-align:left">24</td>
<td style="text-align:left"><strong>fs.link(srcpath, dstpath, callback)</strong> 异步 link().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">25</td>
<td style="text-align:left"><strong>fs.linkSync(srcpath, dstpath)</strong> 同步 link().</td>
</tr>
<tr>
<td style="text-align:left">26</td>
<td style="text-align:left"><strong>fs.symlink(srcpath, dstpath[, type], callback)</strong> 异步 symlink().回调函数没有参数，但可能抛出异常。 type 参数可以设置为 ‘dir’, ‘file’, 或 ‘junction’ (默认为 ‘file’) 。</td>
</tr>
<tr>
<td style="text-align:left">27</td>
<td style="text-align:left"><strong>fs.symlinkSync(srcpath, dstpath[, type])</strong> 同步 symlink().</td>
</tr>
<tr>
<td style="text-align:left">28</td>
<td style="text-align:left"><strong>fs.readlink(path, callback)</strong> 异步 readlink(). 回调函数有两个参数 err, linkString。</td>
</tr>
<tr>
<td style="text-align:left">29</td>
<td style="text-align:left"><strong>fs.realpath(path[, cache], callback)</strong> 异步 realpath(). 回调函数有两个参数 err, resolvedPath。</td>
</tr>
<tr>
<td style="text-align:left">30</td>
<td style="text-align:left"><strong>fs.realpathSync(path[, cache])</strong> 同步 realpath()。返回绝对路径。</td>
</tr>
<tr>
<td style="text-align:left">31</td>
<td style="text-align:left"><strong>fs.unlink(path, callback)</strong> 异步 unlink().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">32</td>
<td style="text-align:left"><strong>fs.unlinkSync(path)</strong> 同步 unlink().</td>
</tr>
<tr>
<td style="text-align:left">33</td>
<td style="text-align:left"><strong>fs.rmdir(path, callback)</strong> 异步 rmdir().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">34</td>
<td style="text-align:left"><strong>fs.rmdirSync(path)</strong> 同步 rmdir().</td>
</tr>
<tr>
<td style="text-align:left">35</td>
<td style="text-align:left"><strong>fs.mkdir(path[, mode], callback)</strong> S异步 mkdir(2).回调函数没有参数，但可能抛出异常。 访问权限默认为 0777。</td>
</tr>
<tr>
<td style="text-align:left">36</td>
<td style="text-align:left"><strong>fs.mkdirSync(path[, mode])</strong> 同步 mkdir().</td>
</tr>
<tr>
<td style="text-align:left">37</td>
<td style="text-align:left"><strong>fs.readdir(path, callback)</strong> 异步 readdir(3). 读取目录的内容。</td>
</tr>
<tr>
<td style="text-align:left">38</td>
<td style="text-align:left"><strong>fs.readdirSync(path)</strong> 同步 readdir().返回文件数组列表。</td>
</tr>
<tr>
<td style="text-align:left">39</td>
<td style="text-align:left"><strong>fs.close(fd, callback)</strong> 异步 close().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">40</td>
<td style="text-align:left"><strong>fs.closeSync(fd)</strong> 同步 close().</td>
</tr>
<tr>
<td style="text-align:left">41</td>
<td style="text-align:left"><strong>fs.open(path, flags[, mode], callback)</strong> 异步打开文件。</td>
</tr>
<tr>
<td style="text-align:left">42</td>
<td style="text-align:left"><strong>fs.openSync(path, flags[, mode])</strong> 同步 version of fs.open().</td>
</tr>
<tr>
<td style="text-align:left">43</td>
<td style="text-align:left"><strong>fs.utimes(path, atime, mtime, callback)</strong></td>
</tr>
<tr>
<td style="text-align:left">44</td>
<td style="text-align:left"><strong>fs.utimesSync(path, atime, mtime)</strong> 修改文件时间戳，文件通过指定的文件路径。</td>
</tr>
<tr>
<td style="text-align:left">45</td>
<td style="text-align:left"><strong>fs.futimes(fd, atime, mtime, callback)</strong></td>
</tr>
<tr>
<td style="text-align:left">46</td>
<td style="text-align:left"><strong>fs.futimesSync(fd, atime, mtime)</strong> 修改文件时间戳，通过文件描述符指定。</td>
</tr>
<tr>
<td style="text-align:left">47</td>
<td style="text-align:left"><strong>fs.fsync(fd, callback)</strong> 异步 fsync.回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">48</td>
<td style="text-align:left"><strong>fs.fsyncSync(fd)</strong> 同步 fsync.</td>
</tr>
<tr>
<td style="text-align:left">49</td>
<td style="text-align:left"><strong>fs.write(fd, buffer, offset, length[, position], callback)</strong> 将缓冲区内容写入到通过文件描述符指定的文件。</td>
</tr>
<tr>
<td style="text-align:left">50</td>
<td style="text-align:left"><strong>fs.write(fd, data[, position[, encoding]], callback)</strong> 通过文件描述符 fd 写入文件内容。</td>
</tr>
<tr>
<td style="text-align:left">51</td>
<td style="text-align:left"><strong>fs.writeSync(fd, buffer, offset, length[, position])</strong> 同步版的 fs.write()。</td>
</tr>
<tr>
<td style="text-align:left">52</td>
<td style="text-align:left"><strong>fs.writeSync(fd, data[, position[, encoding]])</strong> 同步版的 fs.write().</td>
</tr>
<tr>
<td style="text-align:left">53</td>
<td style="text-align:left"><strong>fs.read(fd, buffer, offset, length, position, callback)</strong> 通过文件描述符 fd 读取文件内容。</td>
</tr>
<tr>
<td style="text-align:left">54</td>
<td style="text-align:left"><strong>fs.readSync(fd, buffer, offset, length, position)</strong> 同步版的 fs.read.</td>
</tr>
<tr>
<td style="text-align:left">55</td>
<td style="text-align:left"><strong>fs.readFile(filename[, options], callback)</strong> 异步读取文件内容。</td>
</tr>
<tr>
<td style="text-align:left">56</td>
<td style="text-align:left"><strong>fs.readFileSync(filename[, options])</strong></td>
</tr>
<tr>
<td style="text-align:left">57</td>
<td style="text-align:left"><strong>fs.writeFile(filename, data[, options], callback)</strong> 异步写入文件内容。</td>
</tr>
<tr>
<td style="text-align:left">58</td>
<td style="text-align:left"><strong>fs.writeFileSync(filename, data[, options])</strong> 同步版的 fs.writeFile。</td>
</tr>
<tr>
<td style="text-align:left">59</td>
<td style="text-align:left"><strong>fs.appendFile(filename, data[, options], callback)</strong> 异步追加文件内容。</td>
</tr>
<tr>
<td style="text-align:left">60</td>
<td style="text-align:left"><strong>fs.appendFileSync(filename, data[, options])</strong> The 同步 version of fs.appendFile.</td>
</tr>
<tr>
<td style="text-align:left">61</td>
<td style="text-align:left"><strong>fs.watchFile(filename[, options], listener)</strong> 查看文件的修改。</td>
</tr>
<tr>
<td style="text-align:left">62</td>
<td style="text-align:left"><strong>fs.unwatchFile(filename[, listener])</strong> 停止查看 filename 的修改。</td>
</tr>
<tr>
<td style="text-align:left">63</td>
<td style="text-align:left"><strong>fs.watch(filename[, options][, listener])</strong> 查看 filename 的修改，filename 可以是文件或目录。返回 fs.FSWatcher 对象。</td>
</tr>
<tr>
<td style="text-align:left">64</td>
<td style="text-align:left"><strong>fs.exists(path, callback)</strong> 检测给定的路径是否存在。</td>
</tr>
<tr>
<td style="text-align:left">65</td>
<td style="text-align:left"><strong>fs.existsSync(path)</strong> 同步版的 fs.exists.</td>
</tr>
<tr>
<td style="text-align:left">66</td>
<td style="text-align:left"><strong>fs.access(path[, mode], callback)</strong> 测试指定路径用户权限。</td>
</tr>
<tr>
<td style="text-align:left">67</td>
<td style="text-align:left"><strong>fs.accessSync(path[, mode])</strong> 同步版的 fs.access。</td>
</tr>
<tr>
<td style="text-align:left">68</td>
<td style="text-align:left"><strong>fs.createReadStream(path[, options])</strong> 返回ReadStream 对象。</td>
</tr>
<tr>
<td style="text-align:left">69</td>
<td style="text-align:left"><strong>fs.createWriteStream(path[, options])</strong> 返回 WriteStream 对象。</td>
</tr>
<tr>
<td style="text-align:left">70</td>
<td style="text-align:left"><strong>fs.symlink(srcpath, dstpath[, type], callback)</strong> 异步 symlink().回调函数没有参数，但可能抛出异常。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="GET-POST请求"><a href="#GET-POST请求" class="headerlink" title="　GET/POST请求"></a>　GET/POST请求</h2><ol>
<li><p>获取GET请求内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain; charset=utf-8'</span>&#125;);</span><br><span class="line">    res.end(util.inspect(url.parse(req.url, <span class="literal">true</span>)));</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取url参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 解析 url 参数</span></span><br><span class="line">    <span class="keyword">var</span> params = url.parse(req.url, <span class="literal">true</span>).query;</span><br><span class="line">    res.write(<span class="string">"网站名："</span> + params.name);</span><br><span class="line">    res.write(<span class="string">"\n"</span>);</span><br><span class="line">    res.write(<span class="string">"网站 URL："</span> + params.url);</span><br><span class="line">    res.end();</span><br><span class="line"> </span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取POST请求内容</p>
<p>POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。</p>
<p>比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所以 node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 定义了一个post变量，用于暂存请求体的信息</span></span><br><span class="line">    <span class="keyword">var</span> post = <span class="string">''</span>;     </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中</span></span><br><span class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;    </span><br><span class="line">        post += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。</span></span><br><span class="line">    req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">        post = querystring.parse(post);</span><br><span class="line">        res.end(util.inspect(post));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> postHTML = </span><br><span class="line">  <span class="string">'&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程 Node.js 实例&lt;/title&gt;&lt;/head&gt;'</span> +</span><br><span class="line">  <span class="string">'&lt;body&gt;'</span> +</span><br><span class="line">  <span class="string">'&lt;form method="post"&gt;'</span> +</span><br><span class="line">  <span class="string">'网站名： &lt;input name="name"&gt;&lt;br&gt;'</span> +</span><br><span class="line">  <span class="string">'网站 URL： &lt;input name="url"&gt;&lt;br&gt;'</span> +</span><br><span class="line">  <span class="string">'&lt;input type="submit"&gt;'</span> +</span><br><span class="line">  <span class="string">'&lt;/form&gt;'</span> +</span><br><span class="line">  <span class="string">'&lt;/body&gt;&lt;/html&gt;'</span>;</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> body = <span class="string">""</span>;</span><br><span class="line">  req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    body += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    body = querystring.parse(body);</span><br><span class="line">    <span class="comment">// 设置响应头部信息及编码</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html; charset=utf8'</span>&#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(body.name &amp;&amp; body.url) &#123; <span class="comment">// 输出提交的数据</span></span><br><span class="line">        res.write(<span class="string">"网站名："</span> + body.name);</span><br><span class="line">        res.write(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        res.write(<span class="string">"网站 URL："</span> + body.url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 输出表单</span></span><br><span class="line">        res.write(postHTML);</span><br><span class="line">    &#125;</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工具模块"><a href="#工具模块" class="headerlink" title="工具模块"></a>工具模块</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">模块名 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.runoob.com/nodejs/nodejs-os-module.html" target="_blank" rel="noopener"><strong>OS 模块</strong></a> 提供基本的系统操作函数。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.runoob.com/nodejs/nodejs-path-module.html" target="_blank" rel="noopener"><strong>Path 模块</strong></a> 提供了处理和转换文件路径的工具。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.runoob.com/nodejs/nodejs-net-module.html" target="_blank" rel="noopener"><strong>Net 模块</strong></a> 用于底层的网络通信。提供了服务端和客户端的的操作。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.runoob.com/nodejs/nodejs-dns-module.html" target="_blank" rel="noopener"><strong>DNS 模块</strong></a> 用于解析域名。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.runoob.com/nodejs/nodejs-domain-module.html" target="_blank" rel="noopener"><strong>Domain 模块</strong></a> 简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a>Web模块</h2><p><img src="/images/nodejs/web_architecture.jpg" alt="web_architecture"></p>
<ul>
<li><strong>Client</strong> - 客户端，一般指浏览器，浏览器可以通过 HTTP 协议向服务器请求数据。</li>
<li><strong>Server</strong> - 服务端，一般指 Web 服务器，可以接收客户端请求，并向客户端发送响应数据。</li>
<li><strong>Business</strong> - 业务层， 通过 Web 服务器处理应用程序，如与数据库交互，逻辑运算，调用外部程序等。</li>
<li><strong>Data</strong> - 数据层，一般由数据库组成。</li>
</ul>
<ol>
<li><p>创建服务器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line">http.createServer( <span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;  </span><br><span class="line">   <span class="comment">// 解析请求，包括文件名</span></span><br><span class="line">   <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 输出请求的文件名</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 从文件系统中读取请求的文件内容</span></span><br><span class="line">   fs.readFile(pathname.substr(<span class="number">1</span>), <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(err);</span><br><span class="line">         <span class="comment">// HTTP 状态码: 404 : NOT FOUND</span></span><br><span class="line">         <span class="comment">// Content Type: text/html</span></span><br><span class="line">         response.writeHead(<span class="number">404</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>&#125;);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;             </span><br><span class="line">         <span class="comment">// HTTP 状态码: 200 : OK</span></span><br><span class="line">         <span class="comment">// Content Type: text/html</span></span><br><span class="line">         response.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>&#125;);    </span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 响应文件内容</span></span><br><span class="line">         response.write(data.toString());        </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  发送响应数据</span></span><br><span class="line">      response.end();</span><br><span class="line">   &#125;);   </span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 控制台会输出以下信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:8080/'</span>);</span><br></pre></td></tr></table></figure>
<p>在同一目录下创建index.html文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建客户端</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 用于请求的选项</span></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">   host: <span class="string">'localhost'</span>,</span><br><span class="line">   port: <span class="string">'8080'</span>,</span><br><span class="line">   path: <span class="string">'/index.html'</span>  </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 处理响应的回调函数</span></span><br><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 不断更新数据</span></span><br><span class="line">   <span class="keyword">var</span> body = <span class="string">''</span>;</span><br><span class="line">   response.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      body += data;</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   response.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 数据接收完成</span></span><br><span class="line">      <span class="built_in">console</span>.log(body);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向服务端发送请求</span></span><br><span class="line"><span class="keyword">var</span> req = http.request(options, callback);</span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Express框架"><a href="#Express框架" class="headerlink" title="Express框架"></a>Express框架</h2><blockquote>
<p>Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。</p>
</blockquote>
<p>使用 Express 可以快速地搭建一个完整功能的网站。</p>
<p>Express 框架核心特性：</p>
<ul>
<li>可以设置中间件来响应 HTTP 请求。</li>
<li>定义了路由表用于执行不同的 HTTP 请求动作。</li>
<li>可以通过向模板传递参数来动态渲染 HTML 页面。</li>
</ul>
<p>安装 Express 并将其保存到依赖列表中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cnpm install express --save</span></span><br></pre></td></tr></table></figure>
<p>以上命令会将 Express 框架安装在当前目录的 <strong>node_modules</strong> 目录中， <strong>node_modules</strong> 目录下会自动创建 express 目录。以下几个重要的模块是需要与 express 框架一起安装的：</p>
<ul>
<li><strong>body-parser</strong> - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。</li>
<li><strong>cookie-parser</strong> - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。</li>
<li><strong>multer</strong> - node.js 中间件，用于处理 enctype=”multipart/form-data”（设置表单的MIME编码）的表单数据。</li>
</ul>
<h3 id="Express框架实例"><a href="#Express框架实例" class="headerlink" title="Express框架实例"></a>Express框架实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//express_demo.js 文件</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.send(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8081</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> host = server.address().address</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h3><p>Express 应用使用回调函数的参数： <strong>request</strong> 和 <strong>response</strong> 对象来处理请求和响应的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// --</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>Request 对象</strong> - request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有：</p>
<ol>
<li>req.app：当callback为外部文件时，用req.app访问express的实例</li>
<li>req.baseUrl：获取路由当前安装的URL路径</li>
<li>req.body / req.cookies：获得「请求主体」/ Cookies</li>
<li>req.fresh / req.stale：判断请求是否还「新鲜」</li>
<li>req.hostname / req.ip：获取主机名和IP地址</li>
<li>req.originalUrl：获取原始请求URL</li>
<li>req.params：获取路由的parameters</li>
<li>req.path：获取请求路径</li>
<li>req.protocol：获取协议类型</li>
<li>req.query：获取URL的查询参数串</li>
<li>req.route：获取当前匹配的路由</li>
<li>req.subdomains：获取子域名</li>
<li>req.accepts()：检查可接受的请求的文档类型</li>
<li>req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第一个可接受字符编码</li>
<li>req.get()：获取指定的HTTP请求头</li>
<li>req.is()：判断请求头Content-Type的MIME类型</li>
</ol>
<p><strong>Response 对象</strong> - response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：</p>
<ol>
<li>res.app：同req.app一样</li>
<li>res.append()：追加指定HTTP头</li>
<li>res.set()在res.append()后将重置之前设置的头</li>
<li>res.cookie(name，value [，option])：设置Cookie</li>
<li>opition: domain / expires / httpOnly / maxAge / path / secure / signed</li>
<li>res.clearCookie()：清除Cookie</li>
<li>res.download()：传送指定路径的文件</li>
<li>res.get()：返回指定的HTTP头</li>
<li>res.json()：传送JSON响应</li>
<li>res.jsonp()：传送JSONP响应</li>
<li>res.location()：只设置响应的Location HTTP头，不设置状态码或者close response</li>
<li>res.redirect()：设置响应的Location HTTP头，并且设置状态码302</li>
<li>res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的页面，这样就不会自动输出了。</li>
<li>res.send()：传送HTTP响应</li>
<li>res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Type</li>
<li>res.set()：设置HTTP头，传入object可以一次设置多个头</li>
<li>res.status()：设置HTTP状态码</li>
<li>res.type()：设置Content-Type的MIME类型</li>
</ol>
<h3 id="路由-1"><a href="#路由-1" class="headerlink" title="路由"></a>路由</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  主页输出 "Hello World"</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"主页 GET 请求"</span>);</span><br><span class="line">   res.send(<span class="string">'Hello GET'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//  POST 请求</span></span><br><span class="line">app.post(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"主页 POST 请求"</span>);</span><br><span class="line">   res.send(<span class="string">'Hello POST'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  /del_user 页面响应</span></span><br><span class="line">app.get(<span class="string">'/del_user'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"/del_user 响应 DELETE 请求"</span>);</span><br><span class="line">   res.send(<span class="string">'删除页面'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  /list_user 页面 GET 请求</span></span><br><span class="line">app.get(<span class="string">'/list_user'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"/list_user GET 请求"</span>);</span><br><span class="line">   res.send(<span class="string">'用户列表页面'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 对页面 abcd, abxcd, ab123cd, 等响应 GET 请求</span></span><br><span class="line">app.get(<span class="string">'/ab*cd'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;   </span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"/ab*cd GET 请求"</span>);</span><br><span class="line">   res.send(<span class="string">'正则匹配'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8081</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> host = server.address().address</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><p>Express 提供了内置的中间件 <strong>express.static</strong> 来设置静态文件如：图片， CSS, JavaScript 等。</p>
<p>你可以使用 <strong>express.static</strong> 中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript 文件放在 public 目录下，你可以这么写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/public'</span>, express.static(<span class="string">'public'</span>));</span><br></pre></td></tr></table></figure>
<h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/process_get'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出 JSON 格式</span></span><br><span class="line">   <span class="keyword">var</span> response = &#123;</span><br><span class="line">       <span class="string">"first_name"</span>:req.query.first_name, <span class="comment">//获取提交的GET参数</span></span><br><span class="line">       <span class="string">"last_name"</span>:req.query.last_name</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="built_in">console</span>.log(response);</span><br><span class="line">   res.end(<span class="built_in">JSON</span>.stringify(response));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/process_post'</span>, urlencodedParser, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出 JSON 格式</span></span><br><span class="line">   <span class="keyword">var</span> response = &#123;</span><br><span class="line">       <span class="string">"first_name"</span>:req.body.first_name,</span><br><span class="line">       <span class="string">"last_name"</span>:req.body.last_name</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="built_in">console</span>.log(response);</span><br><span class="line">   res.end(<span class="built_in">JSON</span>.stringify(response));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>以下我们创建一个用于上传文件的表单，使用 POST 方法，表单 enctype 属性设置为 multipart/form-data。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">var</span> multer  = <span class="built_in">require</span>(<span class="string">'multer'</span>);</span><br><span class="line"> </span><br><span class="line">app.use(<span class="string">'/public'</span>, express.static(<span class="string">'public'</span>));</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">app.use(multer(&#123; <span class="attr">dest</span>: <span class="string">'/tmp/'</span>&#125;).array(<span class="string">'image'</span>));</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/index.htm'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.sendFile( __dirname + <span class="string">"/"</span> + <span class="string">"index.htm"</span> );</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">app.post(<span class="string">'/file_upload'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">console</span>.log(req.files[<span class="number">0</span>]);  <span class="comment">// 上传的文件信息</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">var</span> des_file = __dirname + <span class="string">"/"</span> + req.files[<span class="number">0</span>].originalname;</span><br><span class="line">   fs.readFile( req.files[<span class="number">0</span>].path, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        fs.writeFile(des_file, data, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>( err )&#123;</span><br><span class="line">              <span class="built_in">console</span>.log( err );</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               response = &#123;</span><br><span class="line">                   message:<span class="string">'File uploaded successfully'</span>, </span><br><span class="line">                   filename:req.files[<span class="number">0</span>].originalname</span><br><span class="line">              &#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">console</span>.log( response );</span><br><span class="line">          res.end( <span class="built_in">JSON</span>.stringify( response ) );</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8081</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> host = server.address().address</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Cookie-管理"><a href="#Cookie-管理" class="headerlink" title="Cookie 管理"></a>Cookie 管理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express_cookie.js 文件</span></span><br><span class="line"><span class="keyword">var</span> express      = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>)</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line">app.use(cookieParser())</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Cookies: "</span> + util.inspect(req.cookies));</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">app.listen(<span class="number">8081</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>Express官网： <a href="http://expressjs.com/" target="_blank" rel="noopener">http://expressjs.com/</a></li>
<li>Express4.x API 中文版： <a href="https://www.runoob.com/w3cnote/express-4-x-api.html" target="_blank" rel="noopener">Express4.x API Chinese</a></li>
<li>Express4.x API：<a href="http://expressjs.com/zh-cn/4x/api.html" target="_blank" rel="noopener">http://expressjs.com/zh-cn/4x/api.html</a></li>
</ul>
<h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><blockquote>
<p>REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。</p>
<p>表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML（标准通用标记语言下的一个子集）以及HTML（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。REST 通常使用 JSON 数据格式。</p>
</blockquote>
<h3 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h3><p>以下为 REST 基本架构的四个方法：</p>
<ul>
<li><strong>GET</strong> - 用于获取数据。</li>
<li><strong>PUT</strong> - 用于更新或添加数据。</li>
<li><strong>DELETE</strong> - 用于删除数据。</li>
<li><strong>POST</strong> - 用于添加数据。</li>
</ul>
<h3 id="RESTful-Web-Services"><a href="#RESTful-Web-Services" class="headerlink" title="RESTful Web Services"></a>RESTful Web Services</h3><p>Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。</p>
<p>基于 REST 架构的 Web Services 即是 RESTful。</p>
<p>由于轻量级以及通过 HTTP 直接传输数据的特性，Web 服务的 RESTful 方法已经成为最常见的替代方法。可以使用各种语言（比如 Java 程序、Perl、Ruby、Python、PHP 和 Javascript[包括 Ajax]）实现客户端。</p>
<p>RESTful Web 服务通常可以通过自动客户端或代表用户的应用程序访问。但是，这种服务的简便性让用户能够与之直接交互，使用它们的 Web 浏览器构建一个 GET URL 并读取返回的内容。</p>
<p>更多介绍，可以查看：<a href="https://www.runoob.com/w3cnote/restful-architecture.html" target="_blank" rel="noopener">RESTful 架构详解</a></p>
<h3 id="创建RESTful"><a href="#创建RESTful" class="headerlink" title="创建RESTful"></a>创建RESTful</h3><p>首先，创建一个 json 数据资源文件 users.json，内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"user1"</span> : &#123;</span><br><span class="line">      <span class="attr">"name"</span> : <span class="string">"mahesh"</span>,</span><br><span class="line">      <span class="attr">"password"</span> : <span class="string">"password1"</span>,</span><br><span class="line">      <span class="attr">"profession"</span> : <span class="string">"teacher"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="number">1</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"user2"</span> : &#123;</span><br><span class="line">      <span class="attr">"name"</span> : <span class="string">"suresh"</span>,</span><br><span class="line">      <span class="attr">"password"</span> : <span class="string">"password2"</span>,</span><br><span class="line">      <span class="attr">"profession"</span> : <span class="string">"librarian"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="number">2</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"user3"</span> : &#123;</span><br><span class="line">      <span class="attr">"name"</span> : <span class="string">"ramesh"</span>,</span><br><span class="line">      <span class="attr">"password"</span> : <span class="string">"password3"</span>,</span><br><span class="line">      <span class="attr">"profession"</span> : <span class="string">"clerk"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="number">3</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于以上数据，我们创建以下 RESTful API：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">URI</th>
<th style="text-align:left">HTTP 方法</th>
<th style="text-align:left">发送内容</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">listUsers</td>
<td style="text-align:left">GET</td>
<td style="text-align:left">空</td>
<td style="text-align:left">显示所有用户列表</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">addUser</td>
<td style="text-align:left">POST</td>
<td style="text-align:left">JSON 字符串</td>
<td style="text-align:left">添加新用户</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">deleteUser</td>
<td style="text-align:left">DELETE</td>
<td style="text-align:left">JSON 字符串</td>
<td style="text-align:left">删除用户</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">:id</td>
<td style="text-align:left">GET</td>
<td style="text-align:left">空</td>
<td style="text-align:left">显示用户详细信息</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/listUsers'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   fs.readFile( __dirname + <span class="string">"/"</span> + <span class="string">"users.json"</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log( data );</span><br><span class="line">       res.end( data );</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加的新用户数据</span></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">   <span class="string">"user4"</span> : &#123;</span><br><span class="line">      <span class="string">"name"</span> : <span class="string">"mohit"</span>,</span><br><span class="line">      <span class="string">"password"</span> : <span class="string">"password4"</span>,</span><br><span class="line">      <span class="string">"profession"</span> : <span class="string">"teacher"</span>,</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">4</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/addUser'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 读取已存在的数据</span></span><br><span class="line">   fs.readFile( __dirname + <span class="string">"/"</span> + <span class="string">"users.json"</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">       data = <span class="built_in">JSON</span>.parse( data );</span><br><span class="line">       data[<span class="string">"user4"</span>] = user[<span class="string">"user4"</span>];</span><br><span class="line">       <span class="built_in">console</span>.log( data );</span><br><span class="line">       res.end( <span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/:id'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 首先我们读取已存在的用户</span></span><br><span class="line">   fs.readFile( __dirname + <span class="string">"/"</span> + <span class="string">"users.json"</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">       data = <span class="built_in">JSON</span>.parse( data );</span><br><span class="line">       <span class="keyword">var</span> user = data[<span class="string">"user"</span> + req.params.id] </span><br><span class="line">       <span class="built_in">console</span>.log( user );</span><br><span class="line">       res.end( <span class="built_in">JSON</span>.stringify(user));</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/deleteUser'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// First read existing users.</span></span><br><span class="line">   fs.readFile( __dirname + <span class="string">"/"</span> + <span class="string">"users.json"</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">       data = <span class="built_in">JSON</span>.parse( data );</span><br><span class="line">       <span class="keyword">delete</span> data[<span class="string">"user"</span> + id];</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">console</span>.log( data );</span><br><span class="line">       res.end( <span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><blockquote>
<p>我们都知道 Node.js 是以单线程的模式运行的，但它使用的是事件驱动来处理并发，这样有助于我们在多核 cpu 的系统上创建多个子进程，从而提高性能。</p>
<p>每个子进程总是带有三个流对象：child.stdin, child.stdout 和child.stderr。他们可能会共享父进程的 stdio 流，或者也可以是独立的被导流的流对象。</p>
</blockquote>
<p>Node 提供了 child_process 模块来创建子进程，方法有：</p>
<ul>
<li><strong>exec</strong> - child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。</li>
<li><strong>spawn</strong> - child_process.spawn 使用指定的命令行参数创建新进程。</li>
<li><strong>fork</strong> - child_process.fork 是 spawn()的特殊形式，用于在子进程中运行的模块，如 fork(‘./son.js’) 相当于 spawn(‘node’, [‘./son.js’]) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child_process.exec(command[, options], callback)</span><br></pre></td></tr></table></figure>
<p><strong>command：</strong> 字符串， 将要运行的命令，参数使用空格隔开</p>
<p><strong>options ：对象，可以是：</strong></p>
<ul>
<li>cwd ，字符串，子进程的当前工作目录</li>
<li>env，对象 环境变量键值对</li>
<li>encoding ，字符串，字符编码（默认： ‘utf8’）</li>
<li>shell ，字符串，将要执行命令的 Shell（默认: 在 UNIX 中为<code>/bin/sh</code>， 在 Windows 中为<code>cmd.exe</code>， Shell 应当能识别 <code>-c</code>开关在 UNIX 中，或 <code>/s /c</code> 在 Windows 中。 在Windows 中，命令行解析应当能兼容<code>cmd.exe</code>）</li>
<li>timeout，数字，超时时间（默认： 0）</li>
<li>maxBuffer，数字， 在 stdout 或 stderr 中允许存在的最大缓冲（二进制），如果超出那么子进程将会被杀死 （默认: 200*1024）</li>
<li>killSignal ，字符串，结束信号（默认：’SIGTERM’）</li>
<li>uid，数字，设置用户进程的 ID</li>
<li>gid，数字，设置进程组的 ID</li>
</ul>
<p><strong>callback ：</strong>回调函数，包含三个参数error, stdout 和 stderr。</p>
<p>exec() 方法返回最大的缓冲区，并等待进程结束，一次性返回缓冲区的内容。</p>
<p>support.js 文件代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"进程 "</span> + process.argv[<span class="number">2</span>] + <span class="string">" 执行。"</span> );</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> workerProcess = child_process.exec(<span class="string">'node support.js '</span>+i, <span class="function"><span class="keyword">function</span> (<span class="params">error, stdout, stderr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error.stack);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Error code: '</span>+error.code);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Signal received: '</span>+error.signal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'stdout: '</span> + stdout);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'stderr: '</span> + stderr);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    workerProcess.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'子进程已退出，退出码 '</span>+code);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child_process.spawn(command[, args][, options])</span><br></pre></td></tr></table></figure>
<p>参数说明如下：</p>
<p><strong>command：</strong> 将要运行的命令</p>
<p><strong>args：</strong> Array 字符串参数数组</p>
<p><strong>options Object</strong></p>
<ul>
<li>cwd String 子进程的当前工作目录</li>
<li>env Object 环境变量键值对</li>
<li>stdio Array|String 子进程的 stdio 配置</li>
<li>detached Boolean 这个子进程将会变成进程组的领导</li>
<li>uid Number 设置用户进程的 ID</li>
<li>gid Number 设置进程组的 ID</li>
</ul>
<p>spawn() 方法返回流 (stdout &amp; stderr)，在进程返回大量数据时使用。进程一旦开始执行时 spawn() 就开始接收响应。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">var</span> workerProcess = child_process.spawn(<span class="string">'node'</span>, [<span class="string">'support.js'</span>, i]);</span><br><span class="line"> </span><br><span class="line">   workerProcess.stdout.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'stdout: '</span> + data);</span><br><span class="line">   &#125;);</span><br><span class="line"> </span><br><span class="line">   workerProcess.stderr.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'stderr: '</span> + data);</span><br><span class="line">   &#125;);</span><br><span class="line"> </span><br><span class="line">   workerProcess.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'子进程已退出，退出码 '</span>+code);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child_process.fork(modulePath[, args][, options])</span><br></pre></td></tr></table></figure>
<p>参数说明如下：</p>
<p><strong>modulePath</strong>： String，将要在子进程中运行的模块</p>
<p><strong>args</strong>： Array 字符串参数数组</p>
<p><strong>options</strong>：Object</p>
<ul>
<li>cwd String 子进程的当前工作目录</li>
<li>env Object 环境变量键值对</li>
<li>execPath String 创建子进程的可执行文件</li>
<li>execArgv Array 子进程的可执行文件的字符串参数数组（默认： process.execArgv）</li>
<li>silent Boolean 如果为<code>true</code>，子进程的<code>stdin</code>，<code>stdout</code>和<code>stderr</code>将会被关联至父进程，否则，它们将会从父进程中继承。（默认为：<code>false</code>）</li>
<li>uid Number 设置用户进程的 ID</li>
<li>gid Number 设置进程组的 ID</li>
</ul>
<p>返回的对象除了拥有ChildProcess实例的所有方法，还有一个内建的通信信道。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">var</span> worker_process = child_process.fork(<span class="string">"support.js"</span>, [i]);    </span><br><span class="line"> </span><br><span class="line">   worker_process.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'子进程已退出，退出码 '</span> + code);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cnpm install mysql</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql      = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"><span class="keyword">var</span> connection = mysql.createConnection(&#123;</span><br><span class="line">  host     : <span class="string">'localhost'</span>,</span><br><span class="line">  user     : <span class="string">'root'</span>,</span><br><span class="line">  password : <span class="string">'123456'</span>,</span><br><span class="line">  database : <span class="string">'test'</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">connection.connect();</span><br><span class="line"> </span><br><span class="line">connection.query(<span class="string">'SELECT 1 + 1 AS solution'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The solution is: '</span>, results[<span class="number">0</span>].solution);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">host</td>
<td style="text-align:left">主机地址 （默认：localhost）</td>
</tr>
<tr>
<td style="text-align:left">user</td>
<td style="text-align:left">用户名</td>
</tr>
<tr>
<td style="text-align:left">password</td>
<td style="text-align:left">密码</td>
</tr>
<tr>
<td style="text-align:left">port</td>
<td style="text-align:left">端口号 （默认：3306）</td>
</tr>
<tr>
<td style="text-align:left">database</td>
<td style="text-align:left">数据库名</td>
</tr>
<tr>
<td style="text-align:left">charset</td>
<td style="text-align:left">连接字符集（默认：’UTF8_GENERAL_CI’，注意字符集的字母都要大写）</td>
</tr>
<tr>
<td style="text-align:left">localAddress</td>
<td style="text-align:left">此IP用于TCP连接（可选）</td>
</tr>
<tr>
<td style="text-align:left">socketPath</td>
<td style="text-align:left">连接到unix域路径，当使用 host 和 port 时会被忽略</td>
</tr>
<tr>
<td style="text-align:left">timezone</td>
<td style="text-align:left">时区（默认：’local’）</td>
</tr>
<tr>
<td style="text-align:left">connectTimeout</td>
<td style="text-align:left">连接超时（默认：不限制；单位：毫秒）</td>
</tr>
<tr>
<td style="text-align:left">stringifyObjects</td>
<td style="text-align:left">是否序列化对象</td>
</tr>
<tr>
<td style="text-align:left">typeCast</td>
<td style="text-align:left">是否将列值转化为本地JavaScript类型值 （默认：true）</td>
</tr>
<tr>
<td style="text-align:left">queryFormat</td>
<td style="text-align:left">自定义query语句格式化方法</td>
</tr>
<tr>
<td style="text-align:left">supportBigNumbers</td>
<td style="text-align:left">数据库支持bigint或decimal类型列时，需要设此option为true （默认：false）</td>
</tr>
<tr>
<td style="text-align:left">bigNumberStrings</td>
<td style="text-align:left">supportBigNumbers和bigNumberStrings启用 强制bigint或decimal列以JavaScript字符串类型返回（默认：false）</td>
</tr>
<tr>
<td style="text-align:left">dateStrings</td>
<td style="text-align:left">强制timestamp,datetime,data类型以字符串类型返回，而不是JavaScript Date类型（默认：false）</td>
</tr>
<tr>
<td style="text-align:left">debug</td>
<td style="text-align:left">开启调试（默认：false）</td>
</tr>
<tr>
<td style="text-align:left">multipleStatements</td>
<td style="text-align:left">是否许一个query中有多个MySQL语句 （默认：false）</td>
</tr>
<tr>
<td style="text-align:left">flags</td>
<td style="text-align:left">用于修改连接标志</td>
</tr>
<tr>
<td style="text-align:left">ssl</td>
<td style="text-align:left">使用ssl参数（与crypto.createCredenitals参数格式一至）或一个包含ssl配置文件名称的字符串，目前只捆绑Amazon RDS的配置文件</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql  = <span class="built_in">require</span>(<span class="string">'mysql'</span>);  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> connection = mysql.createConnection(&#123;     </span><br><span class="line">  host     : <span class="string">'localhost'</span>,       </span><br><span class="line">  user     : <span class="string">'root'</span>,              </span><br><span class="line">  password : <span class="string">'123456'</span>,       </span><br><span class="line">  port: <span class="string">'3306'</span>,                   </span><br><span class="line">  database: <span class="string">'test'</span> </span><br><span class="line">&#125;); </span><br><span class="line"> </span><br><span class="line">connection.connect();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span>  sql = <span class="string">'SELECT * FROM websites'</span>;</span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">connection.query(sql,<span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'[SELECT ERROR] - '</span>,err.message);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'--------------------------SELECT----------------------------'</span>);</span><br><span class="line">       <span class="built_in">console</span>.log(result);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'------------------------------------------------------------\n\n'</span>);  </span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span>  addSql = <span class="string">'INSERT INTO websites(Id,name,url,alexa,country) VALUES(0,?,?,?,?)'</span>;</span><br><span class="line"><span class="keyword">var</span>  addSqlParams = [<span class="string">'12'</span>, <span class="string">'fas'</span>,<span class="string">'23453'</span>, <span class="string">'CN'</span>];</span><br><span class="line"><span class="comment">//增</span></span><br><span class="line">connection.query(addSql,addSqlParams,<span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'[INSERT ERROR] - '</span>,err.message);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">        &#125;        </span><br><span class="line"> </span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'--------------------------INSERT----------------------------'</span>);</span><br><span class="line">       <span class="comment">//console.log('INSERT ID:',result.insertId);        </span></span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'INSERT ID:'</span>,result);        </span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'-----------------------------------------------------------------\n\n'</span>);  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> modSql = <span class="string">'UPDATE websites SET name = ?,url = ? WHERE Id = ?'</span>;</span><br><span class="line"><span class="keyword">var</span> modSqlParams = [<span class="string">'菜鸟移动站'</span>, <span class="string">'https://m.runoob.com'</span>,<span class="number">6</span>];</span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">connection.query(modSql,modSqlParams,<span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(err)&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'[UPDATE ERROR] - '</span>,err.message);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">   &#125;        </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'--------------------------UPDATE----------------------------'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'UPDATE affectedRows'</span>,result.affectedRows);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'-----------------------------------------------------------------\n\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> delSql = <span class="string">'DELETE FROM websites where id=6'</span>;</span><br><span class="line"><span class="comment">//删</span></span><br><span class="line">connection.query(delSql,<span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'[DELETE ERROR] - '</span>,err.message);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;        </span><br><span class="line"> </span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'--------------------------DELETE----------------------------'</span>);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'DELETE affectedRows'</span>,result.affectedRows);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'-----------------------------------------------------------------\n\n'</span>);  </span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install mongodb</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'mongodb://localhost:27017/runoob'</span>;</span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据库已创建'</span>);</span><br><span class="line">    <span class="keyword">var</span> dbase = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    dbase.createCollection(<span class="string">'site'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"创建集合!"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> myobj = &#123; <span class="attr">name</span>: <span class="string">"菜鸟教程"</span>, <span class="attr">url</span>: <span class="string">"www.runoob"</span> &#125;;</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).insertOne(myobj, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"文档插入成功"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> myobj =  [</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'菜鸟工具'</span>, <span class="attr">url</span>: <span class="string">'https://c.runoob.com'</span>, <span class="attr">type</span>: <span class="string">'cn'</span>&#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'Google'</span>, <span class="attr">url</span>: <span class="string">'https://www.google.com'</span>, <span class="attr">type</span>: <span class="string">'en'</span>&#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'Facebook'</span>, <span class="attr">url</span>: <span class="string">'https://www.google.com'</span>, <span class="attr">type</span>: <span class="string">'en'</span>&#125;</span><br><span class="line">       ];</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).insertMany(myobj, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"插入的文档数量为: "</span> + res.insertedCount);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>). find(&#123;&#125;).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123; <span class="comment">// 返回集合中所有数据</span></span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">     <span class="keyword">var</span> whereStr = &#123;<span class="string">"name"</span>:<span class="string">'菜鸟教程'</span>&#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).find(whereStr).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> whereStr = &#123;<span class="string">"name"</span>:<span class="string">'菜鸟教程'</span>&#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">    <span class="keyword">var</span> updateStr = &#123;<span class="attr">$set</span>: &#123; <span class="string">"url"</span> : <span class="string">"https://www.runoob.com"</span> &#125;&#125;;</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).updateOne(whereStr, updateStr, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"文档更新成功"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> whereStr = &#123;<span class="string">"type"</span>:<span class="string">'en'</span>&#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">    <span class="keyword">var</span> updateStr = &#123;<span class="attr">$set</span>: &#123; <span class="string">"url"</span> : <span class="string">"https://www.runoob.com"</span> &#125;&#125;;</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).updateMany(whereStr, updateStr, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">         <span class="built_in">console</span>.log(res.result.nModified + <span class="string">" 条文档被更新"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> whereStr = &#123;<span class="string">"name"</span>:<span class="string">'菜鸟教程'</span>&#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).deleteOne(whereStr, <span class="function"><span class="keyword">function</span>(<span class="params">err, obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"文档删除成功"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> whereStr = &#123; <span class="attr">type</span>: <span class="string">"en"</span> &#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).deleteMany(whereStr, <span class="function"><span class="keyword">function</span>(<span class="params">err, obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(obj.result.n + <span class="string">" 条文档被删除"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> mysort = &#123; <span class="attr">type</span>: <span class="number">1</span> &#125;;</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).find().sort(mysort).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).find().limit(<span class="number">2</span>).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).find().skip(<span class="number">2</span>).limit(<span class="number">2</span>).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">  dbo.collection(<span class="string">'orders'</span>).aggregate([</span><br><span class="line">    &#123; <span class="attr">$lookup</span>:</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">from</span>: <span class="string">'products'</span>,            <span class="comment">// 右集合</span></span><br><span class="line">         localField: <span class="string">'product_id'</span>,    <span class="comment">// 左集合 join 字段</span></span><br><span class="line">         foreignField: <span class="string">'_id'</span>,         <span class="comment">// 右集合 join 字段</span></span><br><span class="line">         <span class="keyword">as</span>: <span class="string">'orderdetails'</span>           <span class="comment">// 新生成字段（类型array）</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    ]).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">    db.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="comment">// 删除 test 集合</span></span><br><span class="line">    dbo.collection(<span class="string">"test"</span>).drop(<span class="function"><span class="keyword">function</span>(<span class="params">err, delOK</span>) </span>&#123;  <span class="comment">// 执行成功 delOK 返回 true，否则返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="keyword">if</span> (delOK) <span class="built_in">console</span>.log(<span class="string">"集合已删除"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/05/Self-Attention/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DongxianGu">
      <meta itemprop="description" content="Life,Happy,Code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Summer So Cold">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/05/Self-Attention/" class="post-title-link" itemprop="url">Self-Attention</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-05 22:29:37" itemprop="dateCreated datePublished" datetime="2020-03-05T22:29:37+08:00">2020-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-12 18:51:11" itemprop="dateModified" datetime="2020-03-12T18:51:11+08:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/03/05/Self-Attention/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/03/05/Self-Attention/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Self-Attention详解"><a href="#Self-Attention详解" class="headerlink" title="　Self-Attention详解"></a>　Self-Attention详解</h1><p><a href="https://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">https://jalammar.github.io/illustrated-transformer/</a></p>
<p><img src="/images/Self-Attention/v2-32eb6aa9e23b79784ed1ca22d3f9abf9_720w.jpg" alt="v2-32eb6aa9e23b79784ed1ca22d3f9abf9_720w"></p>
<p>对于 Self-Attention，其中<code>Q(query),K(key),V(value)</code>三个矩阵都来源同一个输入，首先需要计算<code>Q</code>和<code>K</code>之间的点乘，然后除以一个标准尺度$\sqrt{d_k}$，它是query和key向量的维度。再试用Softmax将结果归一化为概率分布，然后在乘以矩阵$V$就得到权重和的表示，整个过程可以表示成：</p>
<script type="math/tex; mode=display">
Attention(Q,K,V) = softmax(\frac{QK^T}{\sqrt{d_k}})V</script><p><img src="/images/Self-Attention/v2-f64cbdcf1d883ede36b26067e34f4e3e_720w.jpg" alt="v2-f64cbdcf1d883ede36b26067e34f4e3e_720w"></p>
<p>假如需要翻译词组 <code>Thinking Machines</code> ，其中<code>Thinking</code>的输入嵌入向量用$x_1$表示，<code>Machines</code>的嵌入向量用$x_2$表示。</p>
<p>当处理<code>Thinking</code>这个词，需要计算句中所有词和它的Attention Score，将词作为搜索的query，和句子中所有词的key来匹配，看看相关度多高。使用$q_1$代表<code>Thinking</code>的query vector，$k_1,k_2$分别表示<code>Thinking,Machines</code>对应的key vector，计算<code>Thinking</code>的Attention Score，只需要计算$q_1$和$k_1,k_2$的点乘。同理计算<code>Machines</code>的Attention Score计算$q_2$和$k2_1,k_2$的点乘。然后再进行放缩，和softmax归一化。</p>
<p><img src="/images/Self-Attention/v2-03d0a60b60a0a28f52ed903c76bb9a22_720w.jpg" alt="v2-03d0a60b60a0a28f52ed903c76bb9a22_720w"></p>
<p>显然当前的单词与自身的Attention score 一般最大。其他单词和当前单词的重要程度有相应分数。然后再将Attention Score和value vector相乘，得到加权后的向量。</p>
<p><img src="/images/Self-Attention/v2-087b831f622f83e4529c1bbf646530f0_720w.jpg" alt="v2-087b831f622f83e4529c1bbf646530f0_720w"></p>
<p>如果将输入的所有向量合并成矩阵形式，则其中的query、key、value向量也可并称矩阵形式表示。</p>
<p><img src="/images/Self-Attention/v2-eea2dcbfa49df9fb799ef8e6997260bf_720w.jpg" alt="v2-eea2dcbfa49df9fb799ef8e6997260bf_720w"></p>
<p>其中，$W^Q,W^K,W^V$是我们模型训练过程中学习到的合适参数。</p>
<p><img src="/images/Self-Attention/v2-752c1c91e1b4dbca1b64f59a7e026b9b_720w.jpg" alt="v2-752c1c91e1b4dbca1b64f59a7e026b9b_720w"></p>
<p>Multi-head就是使用多个Q，K，V，然后将得到的多个$Z$拼接起来，在乘以矩阵$W^o$来计算出layer的输出。</p>
<p>对于encoder就是利用这些基本单元叠加，其中key，query，value来自前一层的输出，所以encoder中的每个位置都可以关注到之前一层中encoder的所有位置。</p>
<p>对于decoder，由两个和encoder不同的地方</p>
<ul>
<li>第一级的 Masked Multi-head，其中的key，query，value均来自前一层的decoder的输出，但是加入了Mask操作，即只能关注到前面已经翻译过了的输出的词语，没有的翻译的无法知道。</li>
<li>第二级的 Multi-head Attention 的输入来自前一级和encoder的输出：query来自前一级的decoder，key和value来自encoder的输出，这样decoder的每个每个位置可以关注到输入序列的情况。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/05/Neural-Network-Primer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DongxianGu">
      <meta itemprop="description" content="Life,Happy,Code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Summer So Cold">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/05/Neural-Network-Primer/" class="post-title-link" itemprop="url">Neural-Network-Primer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-05 10:46:38" itemprop="dateCreated datePublished" datetime="2020-03-05T10:46:38+08:00">2020-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-12 18:34:54" itemprop="dateModified" datetime="2020-03-12T18:34:54+08:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/03/05/Neural-Network-Primer/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/03/05/Neural-Network-Primer/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="神经网络基础"><a href="#神经网络基础" class="headerlink" title="神经网络基础"></a>神经网络基础</h1><p><strong>NLP:</strong> the Yoav Goldberg’s, 2016 <a href="https://www.jair.org/media/4992/live-4992-9623-jair.pdf" target="_blank" rel="noopener">A Primer on Neural Network Models for Natural Language Processing </a> 2016 a Primer on Neural Network Models for Natural Language Processing</p>
<p>具有梯度下降的<code>RNN</code>入门</p>
<ul>
<li><a href="https://www.youtube.com/embed/aircAruvnKk" target="_blank" rel="noopener">https://www.youtube.com/embed/aircAruvnKk</a></li>
<li><a href="https://www.youtube.com/embed/IHZwWFHWa-w" target="_blank" rel="noopener">https://www.youtube.com/embed/IHZwWFHWa-w</a></li>
<li><a href="https://www.youtube.com/embed/Ilg3gGewQ5U" target="_blank" rel="noopener">https://www.youtube.com/embed/Ilg3gGewQ5U</a></li>
<li><a href="https://www.youtube.com/embed/tIeHLnjs5U8" target="_blank" rel="noopener">https://www.youtube.com/embed/tIeHLnjs5U8</a></li>
<li><a href="https://www.youtube.com/embed/ILsA4nyG7I0" target="_blank" rel="noopener">https://www.youtube.com/embed/ILsA4nyG7I0</a></li>
</ul>
<p>CNN：Convolutional Neural Networks</p>
<ul>
<li><a href="https://www.youtube.com/embed/FmpDIaiMIeA" target="_blank" rel="noopener">https://www.youtube.com/embed/FmpDIaiMIeA</a></li>
</ul>
<h2 id="激活函数-Activation-Functions"><a href="#激活函数-Activation-Functions" class="headerlink" title="激活函数 Activation Functions"></a>激活函数 Activation Functions</h2><p>激活函数由两种类型：饱和和非饱和。</p>
<p>饱和意味这这个函数会挤压输入</p>
<ul>
<li><p>$f$是不饱和的 </p>
<script type="math/tex; mode=display">\Leftrightarrow\; (|\lim_{z\rightarrow - \infty} f(z)|= +\rightarrow) \lor (|\lim_{z\rightarrow + \infty} f(z)|= +\infty)</script></li>
<li><p>并且如果$f$不是不饱和的那他就是饱和的</p>
</li>
</ul>
<h2 id="RNN-和-Feedforward-Neural-Nets（FNN）"><a href="#RNN-和-Feedforward-Neural-Nets（FNN）" class="headerlink" title="RNN 和　Feedforward Neural Nets（FNN）"></a>RNN 和　Feedforward Neural Nets（FNN）</h2><p><code>RNN</code>通过增加了对过去事件的内部表示在<code>FNN</code>的基础上得到了很大的改善。由于<code>RNN</code>能够很好的处理序列任务，因此以<code>RNN</code>为基础的深度学习在<code>seq2seq</code>上是非常成功的。应该注意到的是<code>RNN</code>是图灵完全的，并且有能够模拟任何程序的能力。</p>
<blockquote>
<p>如果说训练普通的神经网络是在优化误差函数，那么训练循环神经网络就是在优化程序。</p>
</blockquote>
<p><code>RNN</code>因此也可以学习任何可测量的<code>s2s</code>映射到任意精度。所以，能够在手写识别，文本生成和语言模型上得到很好的结果。<code>RNN</code>中，过去事件的信息的可用性非常重要。当缺少输出序列长度的预先知识的情况下，问题就产生了。因为训练目标必须和输入对齐，而标准的<code>RNN</code>只是简单的将输入映射到输出。此外，它还没有将过去输出的信息考虑在内。一种解决方式是使用两个<code>RNN</code>进行结构的预测：第一个建模输入输出依赖（转录）和第二个建模输出-输出依赖（预测）。这种方式每个输出依赖全部的输入序列和前面所有的输出。</p>
<p><code>RNN</code>的另一个限制是内部状态的大小。可以从<code>Neural Machine Translation NMT</code>的<code>encoder-decoder</code>架构中看到这一点。这里的encoder当更新内部状态的时候逐word的获取全部的输入序列。而decoder将它decode成其他语言。</p>
<h2 id="Encoder-Decoder-Scheme"><a href="#Encoder-Decoder-Scheme" class="headerlink" title="　Encoder-Decoder Scheme"></a>　Encoder-Decoder Scheme</h2><p><code>Seq2Seq modeling</code> 等价与 基于<code>encoder-decoder</code>架构的<code>RNN</code>。下面图将这种方式展开成$M$个<code>encoder steps</code> 和 $N$ 个 <code>decoder steps</code>，和隐藏状态 <code>h</code></p>
<p><img src="/images/Neural_Network_Primer/EncoderDecoder_MC.png" alt="EncoderDecoder_MC"></p>
<center>图1：Encoder-Decoder 架构：encoder将输入句子转换成一个 “meaning”向量，这个向量输入到decoder来生成一个翻译</center>

<ul>
<li>encoder - 将输入数据 $x$ 映射到一个不同的表示（低维的，压缩的）。</li>
<li><p><code>decoder</code> - 将<code>encoder</code>输出的新的特征表示映射成作为输出序列$y$的输入数据空间，一次从左到右一个，<code>decoder</code>通过计算新的隐藏状态生成 $y_{i+1}$字符。隐藏状态根据前面的隐藏状态$h_i$和前一个目标语言<code>word</code> $y_i$的嵌入生成。</p>
</li>
<li><p>条件输入成$c_i$来源<code>encoder</code>的输出$z$</p>
<script type="math/tex; mode=display">
input: (x_1,\cdots,x_m) \rightarrow_{maps}^{encoder} z = (z_1,\cdots,z_m) \rightarrow_{generates}^{decoder} output: (y_1,\cdots,y_n)</script></li>
</ul>
<p>我们考虑成两种类型的模型，有或者没有attention，后面假设$\forall ic_i = z_m$(<a href="https://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Cho et al., 2014 </a>)</p>
<p>此外，<code>encoder</code>的状态$h_m^E$作为一个压缩和固定长度的向量存在一个问题，它必须包含了输入句子的全部信息。但是这里它失去了一些信息。可以尝试使用一些启发式的方法来克服这个问题和改善<code>RNN</code>的性能</p>
<ul>
<li>Organize input : 多次输入 或 提供 逆向的序列作为输入</li>
<li>Provide more memory： 提供更长的记忆能力，结果表示记忆越大，<code>RNN</code>在各种任务上的性能越好。</li>
</ul>
<p>因此，为了避免记忆的问题，产生了对Attention的研究。</p>
<h2 id="Attention-Basis"><a href="#Attention-Basis" class="headerlink" title="Attention Basis"></a>Attention Basis</h2><p>Attention最直观的定义是来自<a href="https://mchromiak.github.io/articles/2017/Sep/12/Transformer-Attention-is-all-you-need/" target="_blank" rel="noopener">paper about Transformer architecture</a></p>
<blockquote>
<p>An attention function can be described as mapping a query and a set of key-value pairs to an output, where the query, keys, values, and output are all vectors. The output is computed as a weighted sum of the values, where the weight assigned to each value is computed by a compatibility function of the query with the corresponding key.</p>
</blockquote>
<p>能够通过下面的定义：</p>
<script type="math/tex; mode=display">
\begin{eqnarray} A(q, \{(k,v)\} ) \xrightarrow[\text{output}]{\text{maps as}} \sum_{i=1}^k{\overbrace{f_c(q,k_i)}^{\theta_i}}v_i, q \in Q, k \in K, v \in V \end{eqnarray}</script><script type="math/tex; mode=display">
Q,K,V-vecto\; space,f_c -compatibility\;function</script><p>具体的说，Attention mechanism 是输入状态的权重的分布。它接收任意数量的输入 $x_1,\cdots,x_k$，和<code>query</code> $q$，然后为每个输出产生权重$\theta_1,\cdots,\theta_k$。这就用来度量每个输入和query的相关程度。Attention mechanism的输出$out$是它的输入的加权平均</p>
<script type="math/tex; mode=display">
out = \sum_{i=1}^k \theta_ix_i</script><p>因此，使用了attention的网络，只关注输入序列的一部分，但是仍然提供输出序列。因此人民能够将它想象成一个辅助输入，以线性组合的形式提供给网络。这里的线性组合的权重由网络来控制的。</p>
<p>在长句子固定嵌入的encoder-decoder架构中带来的长期依赖的问题。（例如：在固定大小的 encoded向量$h_N^E$中，句子中的结束word依赖开始word$h_1^E$）。而且，长期以来，在<code>RNN</code>也存在这样的问题。尽管一些手段，比如反向输入输入句子和重复输入输入句子，或者<code>LSTM</code>有时改善了性能。然而，它们并不是总是有效。这是因为LSTM中的状态和梯度可能会产生梯度消失的情况。虽然被称为长时间基于但是并不是长时间工作，例如对于2000 words。</p>
<p><img src="/images/Neural_Network_Primer/WaveNet.gif" alt="WaveNet"></p>
<p><img src="/images/Neural_Network_Primer/ByteNet.png" alt="ByteNet"></p>
<center>图2：WaveNet(top; sound) and ByteNet(bottom; NLP) 架构(Image acquired from [Neural Machine Translation in Linear Time, Kalchbrenner et. al 2016 ](https://arxiv.org/abs/1610.10099))</center>

<p>这就是为什么固定编码可能成为性能瓶颈的原因。</p>
<p>Attention 被用来替换记忆和输入操作，这里的模型搜索输入句子(不是固定长度的向量)中和预测目标word相关的一部分。</p>
<p><img src="/images/Neural_Network_Primer/attention.png" alt="attention"></p>
<center>图3：Attention架构</center>

<p>在这个例子中，$\theta_{1,2}$越大，decoder相对其他的words，更加关注$y_3$第三个输出word。所有的权重被归一化总和为1。</p>
<p><img src="/images/Neural_Network_Primer/EncDecAttention.gif" alt="EncDecAttention"></p>
<center>图4：Attention；蓝色链接的透明度表示decoder对encoded word的注意力大小，透明度越少，关注越高。</center>

<p>在法译英中可以可视化在一个$\theta \;matrix$中</p>
<p><img src="/images/Neural_Network_Primer/attentionmatrix.png" alt="attentionmatrix"></p>
<center>图5：注意力矩阵，Adopted form [Bahdanu et al., 2016 ](https://arxiv.org/abs/1409.0473))</center>

<p>在法语输入句子中，“ la zone”这两个词在翻译成英语“ Area”时尤其需要注意。</p>
<p>大小为$InputSize \times OutputSize$的矩阵通过计算每个输出字符对每个输入字符的注意力数值来填充。行表示<code>Input</code>，列表示<code>Output</code>。对于长句子，它可能会快速的增长。这种方法需要对输入输出元素进行完整的查找，实际上它并不像生物的注意力那样有效。从直觉上看，不应该注意到不相关的对象。因此注意力应该是一种简单的记忆，对decoder产生每一个输出元素是有用的。它不需要对整个输入设置一个固定长度的编码向量。权重只是决定从encoder的输入记忆中获取哪一个符号。这种注意力是端到端记忆网络的进一步发展的主体。在端到端网络中，循环的注意力被使用每个输出符号执行多个计算步骤。这包括在每一步生成输出和改变记忆内容前，多次读取相同的序列。</p>
<p>通过反向传播来定义 <code>end-to-end</code>学习模型的权重。</p>
<h2 id="Layer-connections"><a href="#Layer-connections" class="headerlink" title="Layer connections"></a>Layer connections</h2><p>在DL架构中，梯度消失是常见的问题，因此，提出了一些方法来减轻对网络效率的影响。</p>
<h3 id="Highway-layers"><a href="#Highway-layers" class="headerlink" title="Highway layers"></a>Highway layers</h3><h3 id="Residual-connection-残差连接"><a href="#Residual-connection-残差连接" class="headerlink" title="Residual connection 残差连接"></a>Residual connection 残差连接</h3><p>具有多层结构的模型通常使用<code>shortcut</code> 或 <code>residual connections</code>。这个技巧成为了 <a href="https://arxiv.org/abs/1512.03385" target="_blank" rel="noopener">He et al. 2016 CVPR </a>赢得了<code>ImageNet 2016</code>的主要因素。残差连接是层之间的连接，通过<code>short-cut connection</code> 将当前层的输入$x$连接到它的输出上。</p>
<script type="math/tex; mode=display">
h=f(Wx+b)+\mathbf{x}</script><p>残差连接有助于解决梯度消失问题，因为即使layer的非线性函数$f$没有输出结果，$\mathbf{x}$形式的单位函数成为了输出</p>
<h3 id="Dense-connection"><a href="#Dense-connection" class="headerlink" title="Dense connection"></a>Dense connection</h3><h2 id="Position-Embeddings"><a href="#Position-Embeddings" class="headerlink" title="Position Embeddings"></a>Position Embeddings</h2><p>通常被用在非循环的网络中 （CNN），这种网络和循环网络不同，需要通过某种方式来保存序列输入符号的顺序。RNN通过循环的隐藏状态计算来学习序列中的位置。</p>
<h2 id="Auto-regressive-自回归-（AR"><a href="#Auto-regressive-自回归-（AR" class="headerlink" title="Auto-regressive 自回归 （AR)"></a>Auto-regressive 自回归 （AR)</h2><p>自回归问题是未来观测分布的条件均值。在自回归模型中，我们使用变量的过去值的线性组合来预测感兴趣的变量。这个术语<code>autoregression</code>表明它是对变量自身的回归。在神经网络中，每个单元同时接收来自前一层和同一层内的前一层的输入时所理解的自回归。</p>
<h2 id="End-to-End-learning-training"><a href="#End-to-End-learning-training" class="headerlink" title="End-to-End learning/training"></a>End-to-End learning/training</h2><p>训练一个模型最简单的方式就是在一端放入input，另一端获得output。神经网络的端到端学习仅仅以为了基于输入输出单一模型的网络权值优化。</p>
<p>在某些情况下，一个模型不足以得到预期的输出。这就需要一个相互独立的训练模型组成管道。在大多数情况下，输入和输出是两个不同的范围。另一种情况是神经网络需要很多层才能拟合记忆。因此，它需要将一个大的神经网络划分成较小的神经网络组成的管道。另外要注意的是，这种分解技术不一定是有效的，因为这种方法将中间的输出在局部进行了优化。</p>
<p>例子</p>
<ul>
<li>当训练机器人根据视觉来移动，一个模型可以用来对视觉输入（原始像素）的表示进行预处理，然后将处理的结果作为另一个模型的输入，这个模型负责决定机器人移动哪条腿。</li>
<li>图像字幕，将原始的图像像素信息转换成文本描述图片</li>
<li>语音识别，将语音转化成文本。</li>
</ul>
<h2 id="Hyper-parameters-meta-parameters-free-parameters"><a href="#Hyper-parameters-meta-parameters-free-parameters" class="headerlink" title="Hyper parameters (meta-parameters, free-parameters)"></a>Hyper parameters (meta-parameters, free-parameters)</h2><p>机器学习的关键是找到一个数学公式(模型)，其中的参数最适合数据。然而，训练不能直接从数据中发现模型高层次的属性，比如模型的<strong>复杂性</strong>和<strong>学习速度</strong>。这些属性也被叫做<strong>超参数</strong>。对于每个训练的模型的超参数都是在训练过程开始前预先定义的。超参数的值是重要的，但是需要额外的工作来决定。这些工作通过尝试不同的超参数值和训练不同的模型来完成。使用测试来比较，决定哪些超参数值应该被选择。比如最快的得到结果，需要较少的步骤。因此，可以通过模型选中间接地从数据中确定超参数。</p>
<p>解决机器学习问题的四个方式</p>
<ul>
<li>模型类型：比如FNN、RNN、SVN等等</li>
<li>体系架构：例如，对于RNN，可以选中隐藏层的数量，每个隐含层的单位大小</li>
<li>训练参数：例如，决定学习率，批处理大小</li>
<li>模型参数：模型训练来找到模型参数，比如神经网络中的权重和偏差。因此，超参数被认为是训练参数和体系架构中的步骤</li>
</ul>
<p>超参数的例子</p>
<p>梯度算法中的学习率，隐藏层的数量，k-means中的簇的数量，树的深度和树的叶子节点个数，小批量梯度下降中的批处理大小，正则化参数</p>
<h2 id="Transfer-learning"><a href="#Transfer-learning" class="headerlink" title="Transfer learning"></a>Transfer learning</h2><p>迁移学习在强化学习或监督学习中使用。深度学习需要大量的数据集来提高性能（避免过拟合）。然而当面对新的任务没有足够的数据，这种问题就可能产生。这里的想法就是使用其他已经存在的大的数据集来细致的调整神经网络，来使得这个新的任务只需要少量的数据就可以使用（比如：使用从CNN(ConvNet)得到的与训练的特征能被用在SVM中）。换句话说，将学习到的表示迁移到另一个问题上。然而，我们必须避免消极的迁移，因为它也可能减缓对目标任务的训练。当有了预训练的函数$h()$来搜索函数$g()$来使用新的输入$x_i$的投影</p>
<script type="math/tex; mode=display">
(h(g(x_i)))</script><p>例子</p>
<ul>
<li>正迁移 Positvie transfer：如果你之前学习过如何从没有腐烂的蔬菜学习对腐烂的蔬菜进行分类，你可以将腐烂的表示使用到水果上，尽管你之前没有见过腐烂的水果。</li>
<li>负迁移 Negative transfer：学习一项技能使得学习第二个技能更加困难。如果一个跆拳道运动知道如何训练拳击，可能很难理解什么是拳击。</li>
<li>主动迁移 Proactive transfer：当过去学习的模型影响到要学习的新模型</li>
<li>回溯迁移 Retroactive transfer：当一个新的模型影响到之前学习的模型</li>
<li>双向迁移 Bilateral Transfer：机器人学会了使用左机械手，但是在不同的对称性现在必须学习使用右机械手</li>
<li>零迁移 Zero transfer：两个模型是肚里的</li>
<li>刺激归纳 Stimulus generalization：知道什么是腐烂的水果并不意味这能够在生锈的金属上发现一样的。但是你可以总结得出在这两个案列上，它是不可用的。</li>
</ul>
<h2 id="Fine-tuning-微调"><a href="#Fine-tuning-微调" class="headerlink" title="Fine tuning 微调"></a>Fine tuning 微调</h2><p>微调主要在监督学习的背景下考虑。当在为一个算法选择超参数的时候，微调使用大量的机制来解决这个问题。当调整这个算法的行为，为了进一步改善性能而不是操控模型本身。当微调预训练的模型也许被认为和迁移学习等同。如果在微调的过程中使用的数据与预训练的模型使用的数据性质不同，这种情况是正确的。</p>
<p>例子</p>
<ul>
<li>找到模型的最佳超参数</li>
<li>在迁移学习中，替换固定的预训练好的模型使得模型更加灵活，更加适应新的任务。</li>
</ul>
<h2 id="Evolutionary-algorithm-（Evolutionary-Computation）"><a href="#Evolutionary-algorithm-（Evolutionary-Computation）" class="headerlink" title="Evolutionary algorithm （Evolutionary Computation）"></a>Evolutionary algorithm （Evolutionary Computation）</h2><p>机器学习问题中，以便由两个部分组成</p>
<ol>
<li>The model (function class, etc)</li>
<li>Methods of fitting the model (optimization algorithms)</li>
</ol>
<p>神经网络是一个模型：给定了结构和权重的设置，神经网络会产生一些输出。存在一些拟合神经网络的方法，比如反向传播，对比发散，等等。然而，神经网络的重点是如果每个人给你一个正确的权重，你就能很好的处理这个问题。</p>
<p>进化算法处理第二个部分—拟合模型，也就是优化。有一些和进化算法相关的经典模型：例如，进化程序通常试图优化特定类型的所有程序。然而，进化算法本质上是为一个特殊的模型找出正确参数的一种方法。通常，你以这样交叉操作方式来编写模型参数，交叉操作是一个合理的方法。能够使得进化算法改变来获取一个合理的参数设置。</p>
<p>进化算法是能够使用在机器学习中的一类策略，就像BP和其他的策略一样。</p>
<p>进化算法通常收敛非常缓慢，因为它们没有利用梯度信息。另一方面，它们提供了一个机会来避免局部最优和找到全局最优。</p>
<h2 id="Learning-rate-schemes（learning-rate-annealing-or-adaptive-learning-rates）"><a href="#Learning-rate-schemes（learning-rate-annealing-or-adaptive-learning-rates）" class="headerlink" title="　Learning rate schemes（learning rate annealing or adaptive learning rates）"></a>　Learning rate schemes（learning rate annealing or adaptive learning rates）</h2><p>随着训练改变学习率，比如SGD可以提高性能和减少训练次数。随着学习率自适应的变化，一个人可以使用不同的策略来决定学习率如何来改变。</p>
<p>See <a href="http://cs231n.github.io/neural-networks-3/#anneal" target="_blank" rel="noopener">cs231n </a> on learning rate annealing and <a href="https://www.tensorflow.org/versions/r0.12/api_docs/python/train/decaying_the_learning_rate" target="_blank" rel="noopener">Tensorflow decaying learning rate </a>.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/04/Transformer-All-is-all-you-need/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DongxianGu">
      <meta itemprop="description" content="Life,Happy,Code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Summer So Cold">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/04/Transformer-All-is-all-you-need/" class="post-title-link" itemprop="url">Transformer-All-is-all-you-need</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-04 12:15:50" itemprop="dateCreated datePublished" datetime="2020-03-04T12:15:50+08:00">2020-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-24 09:20:18" itemprop="dateModified" datetime="2020-03-24T09:20:18+08:00">2020-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NLP/" itemprop="url" rel="index"><span itemprop="name">NLP</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/03/04/Transformer-All-is-all-you-need/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/03/04/Transformer-All-is-all-you-need/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="The-Transformer-Attention-is-all-you-need"><a href="#The-Transformer-Attention-is-all-you-need" class="headerlink" title="The Transformer - Attention is all you need"></a>The Transformer - Attention is all you need</h1><p>参考来源：<a href="https://mchromiak.github.io/articles/2017/Sep/12/Transformer-Attention-is-all-you-need/#.Xl8qrXWTLmj" target="_blank" rel="noopener">https://mchromiak.github.io/articles/2017/Sep/12/Transformer-Attention-is-all-you-need/#.Xl8qrXWTLmj</a></p>
<p>前置知识：</p>
<ul>
<li>RNN – Andrej Karpathy’s blog <a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="noopener">The Unreasonable Effectiveness of Recurrent Neural Networks </a></li>
<li>Seq2Seq - Nathan Lintz Seq2seq-Nathan Lintz<a href="https://indico.io/blog/sequence-modeling-neuralnets-part1/" target="_blank" rel="noopener">Sequence Modeling With Neural Networks (Part 1): Language &amp; Seq2Seq</a>, Part2 <a href="https://indico.io/blog/sequence-modeling-neural-networks-part2-attention-models/" target="_blank" rel="noopener">Sequence modeling with attention</a></li>
<li>LSTM – Christopher Olah’s blog <a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks </a> and R2Rt.com <a href="https://r2rt.com/written-memories-understanding-deriving-and-extending-the-lstm.html" target="_blank" rel="noopener">Written Memories: Understanding, Deriving and Extending the LSTM</a>.</li>
<li>Attention – Christopher Olah<a href="https://distill.pub/2016/augmented-rnns/#attentional-interfaces" target="_blank" rel="noopener">Attention and Augmented Recurrent Neural Networks</a></li>
</ul>
<h2 id="算法的目标"><a href="#算法的目标" class="headerlink" title="算法的目标"></a>算法的目标</h2><ul>
<li><code>Seq2Seq的并行化：RNN/CNN</code>处理有序的逐字的序列是并行的障碍。<code>Transformer</code>通过使用注意力机制和对序列中字符的位置编码来替换递归结构来获得并行化运行，反过来，这也导致训练时间的明显减少。</li>
<li>减少顺序计算：独立序列中字符的位置距离，以$O(1)$的时间复杂度来学习两个符号之间的依赖关系，</li>
</ul>
<h2 id="RNN和CNN"><a href="#RNN和CNN" class="headerlink" title="RNN和CNN"></a>RNN和CNN</h2><ol>
<li>RNN<ul>
<li>优点：<code>RNN</code>对于语言，图片等序列的变长表示的处理是流行和成功的。<code>RNN</code>是<code>seq2seq</code>(with attention)的核心。门控模型比如<code>LSTM</code>、<code>GRU</code>适合处理远距离的误差传播</li>
<li>问题：它的顺序特点阻止了实例的并行化。远距离的依赖仍然难以处理，尽管有门这类的模型。<code>RNN</code>中对于序列状态的对齐是浪费的。难以对层级相似的领域建模，比如语言。</li>
</ul>
</li>
<li>CNN<ul>
<li>优点：对于每层的并行化和适应大多数依赖是局部的（感觉翻译有问题）</li>
<li>问题：当使用扩大卷积，对文本使用左填充，位置之间的路径可以是对数的。</li>
<li>解决方案：<code>multi-head self-attention</code> 机制。论文中表明这种方式可以减少2-3个数量级的计算。</li>
</ul>
</li>
</ol>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Paper: <a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">ArXiv</a>.</p>
<p>当使用<code>RNN</code>或者<code>CNN</code>接收一个序列作为输入时，它能按照逐字的处理句子。但这种顺序性对于处理的并行是一个障碍。更重的是，在这样的情况下，当序列太长的话，模型更倾向于以往序列中远距离的内容或者将它和后序位置的内容混合起来。</p>
<p>一种措施是采用卷积<code>seq2seq</code>。卷积能够使得<code>GPU</code>处理能够并行化。因此 <a href="https://arxiv.org/abs/1705.03122" target="_blank" rel="noopener">Gehring et al, 2017 </a> (Facebook AI)提出了一个全卷积架构来表示输入序列的层次表示。关键是距离近的在低层次相互作用，而距离远则在高层此相互作用。这种卷积网络的堆积被用来评估字之间的长距离依赖。尽管固定了卷积核的大小，但这都是可能的。</p>
<p>文中作者也提出了两个技巧：</p>
<ul>
<li>位置嵌入：将位置嵌入添加到输入嵌入当中，用于捕捉序列中的顺序。</li>
<li><code>Multi-step attention</code>：注意力机制使用当前的decoder状态和前面的目标字符的嵌入来计算。</li>
</ul>
<p><img src="/images/Transformer/MultiStepAttention.gif" alt=""></p>
<center>图1： Multi-step attention from ConvS2S</center>

<p>为了替换卷积网络，<code>Transformer</code>中提出了一种新的方法。他提出了对每个位置进行编码和使用注意力机制，来关联两个距离较远的单词，因此实现了并行化，加速了训练速度。</p>
<p><code>NLP</code>中通过<code>seq2seq</code>模型实现将输入句子编码成固定大小的向量表示。向量大小固定，与输入句子的长度无关。很明显这导致了失去了一些信息。为了解决这个问题，<code>Transformer</code>提出了一种基于注意力的替代方法</p>
<p>可以参考：</p>
<ul>
<li><a href="https://arxiv.org/abs/1703.03906" target="_blank" rel="noopener">Denny Britz on Attention, 2017</a></li>
<li><a href="https://arxiv.org/abs/1705.04304" target="_blank" rel="noopener">Self-attention (a.k.a Intra-attention)</a></li>
</ul>
<h2 id="Transformer的Motivation"><a href="#Transformer的Motivation" class="headerlink" title="Transformer的Motivation"></a>Transformer的Motivation</h2><p><code>Transformer</code>架构的目标是序列变换的问题，即输入序列转换为输出序列的任务。比如语音识别、文本语音转换、机器翻译、蛋白质第二结构预测、图灵机等。目标是设置一个单一的架构来处理尽可能多的序列。</p>
<p>基于<code>encoder-decode</code>r方案的复杂<code>RNN</code>和<code>CNN</code>是主要的序列变换模型（语言模型和机器模型）。循环模型由于序列性质而不能并行的训练。因此存在从记忆中学习长期依赖的问题。记忆越大，效果越好，但是内存会限制学习长序列的批处理。这也是为什么并行化没有帮助的理由。</p>
<p>减少序列计算的约束一直是众多研究的方向。但是在基于CNN的方法中，从输入到输出位置的隐藏表示的并行计算随着位置的增加而增加。<code>ConvS2S</code> 的 $O(n)$和<code>ByteNet</code>的$O(n\log n)$的复杂度使得学习长距离的依赖关系更加困难。</p>
<p><code>Transformer</code>减少了从输入/输出序列中两个字符的序列计算数量到常量$O(1)$数量级。<code>Transformer</code>使用多头的注意力机制实现了这个目标。多头注意力机制允许建模输入 或 输出序列的依赖而不用考虑他们的距离。</p>
<p>注意力的大多数研究都是和RNN网络结合起来。而<code>Transformer</code>的新方法是完全消除循环，使用注意力来处理输入和输出之间的依赖。<code>Transformer</code>将关注点转移到注意力机制上。它不仅消除了循环，而且有利于使用 <code>self-attention</code>的卷积。此外，还留出了更大的空间来并行化。</p>
<p>这篇文章的最高性能是通过将注意力机制运用到连接<code>encoder</code>和<code>decoder</code>来实现的。</p>
<p>这种架构被作者称为第一个完全使用<code>self-attention</code>来计算输入和输出的表示的架构。</p>
<h2 id="算法的对信息的处理策略"><a href="#算法的对信息的处理策略" class="headerlink" title="算法的对信息的处理策略"></a>算法的对信息的处理策略</h2><p>Transformer是基于<code>seq2seq</code>模型的统计机器翻译模型。<code>seq2seq</code>由两个<code>RNN</code>组成，一个是<code>encoder</code>用于处理输入，另一是<code>decoder</code>用于生成输出。</p>
<p>通常，<code>Transformer</code>的<code>encoder</code>将输入序列映射到连续表示$z$，反过来，$z$被<code>decoder</code>用来生成输出，例如一次一个字符。</p>
<p><code>encoder</code>的最终状态是一个固定长度的向量$z$。$z$必须<code>encode</code>包含原始句子的全部信息。因此$z$也被成为句子嵌入(sentence embedding)。</p>
<p><code>encoder-decoder</code>模型在它的每一步设计为<code>auto-regressive</code>（自回归）。使用前面生成的字符作为额外的输入来生成下一个字符时。</p>
<script type="math/tex; mode=display">
x_i+y_{i-1} \to y_i</script><h2 id="基于Encoder-Decoder的Transformer"><a href="#基于Encoder-Decoder的Transformer" class="headerlink" title="基于Encoder-Decoder的Transformer"></a>基于Encoder-Decoder的Transformer</h2><p>在<code>Transformer</code>（如<code>ByteNet</code>或<code>ConvS2S</code>)中，<code>decoder</code>是直接堆在<code>encoder</code>上面。<code>Encoder</code>和<code>Decoder</code>都是由相同的层堆积而成的。每个堆积层都是由两种一般类型的子层组成的：</p>
<ul>
<li><code>multi-head self-attention mechanism</code> </li>
<li><code>position-wise fully connected FNN</code></li>
</ul>
<p>与<code>ConvS2S</code>相反，这里的输入表示是有输入元素和它在序列中的绝对位置组合而成的。<code>ByteNet</code>有扩大的卷积层和没有<code>position-wise FNN</code>。Transformer针对这两种类型采用了两种不同的神经网络。</p>
<p>这种注意力机制的应用和变化使得Transformer变得新颖。</p>
<p>One can find the reference Transformer model implementation from authors is present in <a href="https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/transformer.py" target="_blank" rel="noopener">Tensor2Tensor (T2T) library </a></p>
<p><img src="/images/Transformer/encoder.png" alt=""></p>
<center>图2：单层Encoder（左） 和  N=6个相同的层组成的Decoder(右)</center>

<h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><ul>
<li><code>Stage 1- Encoder</code> 输入序列顺序的信息是很重要的。因为没有递归，也没有卷积，所以在序列中每个字符关于绝对或相对位置的信息使用位置编码来表示。因此，对于<code>encoder</code>的输入表示成这样：</li>
</ul>
<ul>
<li><code>positional encodings</code>: added $\oplus$ to</li>
<li><code>embedded input</code></li>
</ul>
<ul>
<li><p>$N=6$ layers。实际上是超过6层的。因为这些<code>layers</code>由两个layers组成：<code>position-wise FNN</code> 和 <code>encoder</code> 或 <code>decoder</code> 和基于注意力的<code>sublayers</code>。每个额外还包括四个线性投影和注意力逻辑。因此，可以提供比6 <code>layer</code>架构更深的层次。</p>
<ul>
<li><p><code>Stage 2- Multi-head attention</code></p>
</li>
<li><p><code>Stage 3- position-wise FNN</code></p>
<p><code>Stage2</code> 和 <code>Stage 3</code> 使用残差连接（因此，所有阶段都是用512维 $d_{model}=512$），然后接着在输出端使用<code>normalization layer</code></p>
</li>
</ul>
</li>
</ul>
<p>所以，<code>Encoder</code>的原理如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stage1_out = Embedding512 + TokenPositionEncoding512</span><br><span class="line">Stage2_out = layer_normalization( multihead_attention(Stage1_out) + Stage1_out )</span><br><span class="line">Stage3_out = layer_normalization(FFN(Stage2_out) + Stage2_out)</span><br><span class="line"></span><br><span class="line">out_enc = Stage3_out</span><br></pre></td></tr></table></figure>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p><code>Decoder</code>的架构是非常相似的，它在<code>Stage 3</code>采用额外的<code>layer</code>，使用在<code>decoder output</code> 上使用 <code>mask multi-head attention</code>。</p>
<ul>
<li>Stage1 - Decoder Input。输入是output embedding，偏移一个位置来确保对位置$i$的预测只依赖位置$i$之前的位置。</li>
<li>Stage2 Masked Multi-head attention 修改来防止位置影响后续的位置(感觉翻译有问题。)</li>
</ul>
<p>Stage 2,3,4也使用残差连接，在它的输出后面接着normalization layer。</p>
<p>Decoder的原理如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Stage1_out = OutputEmbedding512 + TokenPositionEncoding512</span><br><span class="line"></span><br><span class="line">Stage2_Mask = masked_multihead_attention(Stage1_out)</span><br><span class="line">Stage2_Norm1 = layer_normalization(Stage2_Mask) + Stage1_out</span><br><span class="line">Stage2_Multi = multihead_attention(Stage2_Norm1 + out_enc) + Stage2_Norm1</span><br><span class="line">Stage2_Norm2 = layer_normalization(Stage2_Multi) + Stage2_Multi</span><br><span class="line"></span><br><span class="line">Stage3_FNN = FNN(Stage2_Norm2)</span><br><span class="line">Stage3_Norm = layer_normalization(Stage3_FNN) + Stage2_Norm2</span><br><span class="line"></span><br><span class="line">out_dec = Stage3_Norm</span><br></pre></td></tr></table></figure>
<h2 id="组成Transformer架构的机制"><a href="#组成Transformer架构的机制" class="headerlink" title="组成Transformer架构的机制"></a>组成Transformer架构的机制</h2><p>Transformer主要由以下几种类型的layers组成，细节如下：</p>
<h3 id="Positional-Encoding——PE"><a href="#Positional-Encoding——PE" class="headerlink" title="Positional Encoding——PE"></a>Positional Encoding——PE</h3><p>在RNN(LSTM)中，time step的概念倍定义为一次一个的输入或输出。在FNN中，使用某种方式将位置编码表示成时间。在Transformer中，作者提出使用正弦波函数来表示时间，作为额外的输入。这种信号增加到输入和输出来表示时间的变化。</p>
<p>向输入嵌入增加位置编码的一种方式是嵌入输入元素的绝对位置(ConvS2S)。但是，Transformer的作者使用不同频率正弦和余弦函数。这种正弦的方法非常复杂，和嵌入绝对位置的方法有着相似的性能。但是，它能够允许模型能够在测试时间内对更长的句子产生更好的翻译。这种正弦方式能够让模型外推到更长的序列上。</p>
<p>这种编码方式能够感知当前处理的输入或输出的位置。位置编码能够被学习或者固定。作者通过测试表明：两种的性能相似。</p>
<script type="math/tex; mode=display">
\begin{align}
& PE(pos, 2i) = \sin(\frac{pos}{1000^{\frac{2i}{d_{model}}}}) \\
& PE(pos, 2i+1) = \cos(\frac{pos}{1000^{\frac{2i}{d_{model}}}}) \\
\end{align}</script><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><p>作者阐述了attention的定义，详细的可以查看<a href="https://mchromiak.github.io/articles/2017/Sep/01/Primer-NN/#attention-basis" target="_blank" rel="noopener">Attention primer</a>。Attention是一种函数，能够将两个元素的输入<code>(query,key-value pair)</code>映射到一个输出。由映射函数的到的输出是<code>values</code>的加权和。每个<code>value</code>的权重是度量每个input <code>key</code> 和<code>query</code>的相关程度。Transformer中attention的创新点是 <code>multi-head self-attention</code></p>
<h3 id="Scaled-Dot-Product-Attention"><a href="#Scaled-Dot-Product-Attention" class="headerlink" title="Scaled Dot-Product Attention"></a>Scaled Dot-Product Attention</h3><p>在<code>encoder-decoder</code>中，<code>query</code>通常是decoder的隐藏状态。<code>key</code>是encoder的隐藏状态。相应<code>value</code>是规范化的权重，表示一个<code>key</code>得到多少attention。输出使用加权和来计算。这里的<code>query</code>和<code>key</code>的点积用来计算value。</p>
<p>假设<code>queries</code> 和 <code>keys</code>的维度是 $d_k$，<code>values</code>的维度是$d_v$。这些维度是由线性投影得到的。输入通过三个矩阵表示：<code>queries</code> 矩阵 <code>Q</code>，<code>keys</code> 矩阵 <code>K</code>， <code>values</code>矩阵 <code>V</code>。</p>
<p>上面的方式有两个好处：</p>
<ul>
<li>加法和乘法点积变种有着相似的理论复杂性</li>
<li>有着常量$\frac{1}{\sqrt{d_k}}$点积能够更快和空间效率更高。被用来优化乘法代码</li>
</ul>
<script type="math/tex; mode=display">
Attention(Q,k,V)=softmax(\frac{QK^T}{\sqrt{d_k}})V</script><p>在Numpy中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attention</span><span class="params">(Q, k, V)</span>:</span></span><br><span class="line">    num = np.dot(Q, K.T)</span><br><span class="line">    denum = np.sqrt(K.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> np.dot(softmax(num/denum), V)</span><br></pre></td></tr></table></figure>
<h3 id="Multi-head-attention"><a href="#Multi-head-attention" class="headerlink" title="Multi-head attention"></a>Multi-head attention</h3><p>Transformer减少了输入和输出序列中相关位置的计算操作的量级到$O(1)$。然而这是由减少了有效的分解为代价的，因为平均注意力加权位置。</p>
<p><img src="/images/Transformer/MultiHead.png" alt=""></p>
<center>图3：由h个并行运行的attention layers组成的 Multi-Head Attention</center>

<p>为了减少代价，作者使用了Multi-head attention</p>
<ul>
<li>$h=8$ attention layers：表示K，Q，V的线性投影（为了减少维度）<script type="math/tex; mode=display">
head_i = Attention(QW_i^Q,KW_i^K,VW_i^V)</script></li>
</ul>
<p>  这里的投影就是参数矩阵</p>
<script type="math/tex; mode=display">
  W_i^Q,W_i^K \in \mathbb{R}^{d_{model} \times d_k},W_i^V \in \mathbb{R}^{d_{model} \times d_v}</script><ul>
<li><p>在每个layer（不同的<code>k,q,v</code>的线性投影）并行使用scaled-dot attention，可以得到$d_v$维的输出</p>
</li>
<li><p>连接每个layer（不同的线性投影）的输出：$Concat(head_1， head_2, \cdots , head_h)$</p>
</li>
<li><p>对上一步的连接结果进行线性投影</p>
<script type="math/tex; mode=display">
MultiHeadAttention(Q, K, V) = Concat(head_1, \cdots, head_h)W^o \quad where \quad W_0 \in  \mathbb{R^{d_{hd_v} \times d_{model}}}</script></li>
</ul>
<p><code>Transformer</code>使用 <code>multi-head</code> （ $d<em>{model}/h $ 维的并行的<code>attention</code>函数） <code>attention</code>  替代 单个（ $d</em>{model}$维）的 <code>attention</code>函数（其中<code>q,k,v</code>都是$d_{model}$维的）。由于减少了每个head的维度，所以在计算代价上和<code>single-head attention</code>是相似的。</p>
<p><code>Transformer</code>模仿了经典的注意力机制，在<code>encoder-decoder attention layers</code> 的<code>queries</code>是来自前面的<code>decoder layer</code>。 <code>keys</code> 和 <code>values</code>来源<code>encoder</code>的输出。因此，在<code>decoder</code>上的每个位置能够观察到输出序列的所有位置。</p>
<h3 id="Self-Attention-（SA"><a href="#Self-Attention-（SA" class="headerlink" title="Self-Attention （SA)"></a>Self-Attention （SA)</h3><p>See <a href="https://mchromiak.github.io/articles/2017/Sep/01/Primer-NN/#attention-basis" target="_blank" rel="noopener">Attention Primer</a> for basics on attention.</p>
<p>在<code>encoder</code>中，<code>self-attention layer</code> 处理来自同一个位置的输入<code>queries，keys，values</code>。encoder中的每个位置都可以观察到来自前面 layer of the encoder 的所有位置。</p>
<p>在decoder中，self-attention layer 能够让每个位置注意到decoder中前面的所有的位置，包括当前的位置。为了保持auto-regressive的属性，通过mask(set to $-\infty$)所有的 和与softmax非法连接的输入<code>values</code>，使用dot-attention attention来表示左边的信息流。</p>
<p>作者产生使用 self-attention layers 代替 循环 layers和卷积layers由三个原因。</p>
<ul>
<li><p>最小化每层的总的计算复杂度</p>
<p>self-attention layers 使用序列执行操作$O(1)$数量级连接所有的位置，在RNN中是$O(n)$。</p>
</li>
<li><p>最大化并行计算的数量，通过最小化序列操作的需求的数量来度量</p>
<p>对于序列长度 n 小于表示的维度d，对于非常长的序列 n &gt; d维self-attention 能够只考虑以输入序列中以各自输出位置为中心大小为r的邻域，从而使得最大路径增加到$O(\frac{n}{r})$</p>
</li>
<li><p>最小化由不同类型的layer组成的网络中任一两个输入和输出位置之间的最大路径长度。输入和输出序列中任何位置组合之间的路径越短，越容易学习到长期依赖关系。</p>
</li>
</ul>
<h3 id="Position-wise-FFN"><a href="#Position-wise-FFN" class="headerlink" title="Position-wise FFN"></a>Position-wise FFN</h3><p>在encoder和decoder最后那个，attention子层由一个全连接的FNN来处理。它应用在每个单独的位置上，同时意味着两个线性变换和一个ReLU</p>
<script type="math/tex; mode=display">
FNN(x) = max(0,xW_1+b_1)W_2+b_2</script><p>对于每个位置的线性变换是一样的，但是每个层使用不同的参数。它的工作方式类似于两个卷积核大小维1的卷积网络。输入或输出的维度是$d<em>{model}=512$，inner0layer 是$d</em>{ff}=2048$</p>
<h2 id="算法的伪代码or流程图"><a href="#算法的伪代码or流程图" class="headerlink" title="算法的伪代码or流程图"></a>算法的伪代码or流程图</h2><p><img src="/images/Transformer/transform20fps.gif" alt=""></p>
<center>图4：在英译法的Transformer的逐步变换</center>

<p>在encoder阶段（如图1所示），Transformer第一步对输入句子(空心圈)中的每个word生成初始的表示(representation/embedding)。下一步，对每个word，self-attention收集了句子上下文其他word的信息，并且产生了新的表示(representation，被填充后的圈；实心圆)。对句子里的每个word重复这个过程。对每一个word，基于前面的表示继续构建新的表示，前面的表示并行的重复多次（下一层的填空圈）</p>
<p>Decoder按照从左到右的模式每次相似的生成一个word。它观察decoder中先前生成的words和encoder的最终表示。</p>
<p>值得注意的self-attention策略允许遇见共指消解<code>coreference resolution</code>的问题，例如，句子中的单词<code>it</code>能够根据上下文指代句子中的不同名词。</p>
<p><img src="/images/Transformer/CoreferenceResolution.png" alt=""></p>
<center>图5：共参考消解. 两个例子中 it和不同的符号相关 </center>

<h2 id="启发和经验准则"><a href="#启发和经验准则" class="headerlink" title="启发和经验准则"></a>启发和经验准则</h2><p>作者进行了一系列的实验，讨论了以有着使用了100K Step 64维的 key,values的$h=8$heads为基础的模型，模型大小为512的$N=6$的layers的推荐方案</p>
<p>同时也说明了模型质量随着$d_k$的减少而下降，因此可以进一步优化 dot-product compatibility function。</p>
<p>固定的正弦位置编码和学习的位置编码相比，得分几乎相等。</p>
<h2 id="算法的使用场景"><a href="#算法的使用场景" class="headerlink" title="算法的使用场景"></a>算法的使用场景</h2><ul>
<li>语言翻译</li>
<li>句法类别分析的经典语言分析任务</li>
<li>输入输出不同的模式，如图像和视频</li>
<li>共指消解</li>
</ul>
<h2 id="可用于演示的数据集"><a href="#可用于演示的数据集" class="headerlink" title="可用于演示的数据集"></a>可用于演示的数据集</h2><ul>
<li>Perplexity (PPL) BLEU (PPL) BLEU</li>
<li>English-to-German translation development set WMT 2014 English-to-German and WMT 2014 English-to-French translation tasks</li>
<li>newstest2013 </li>
<li>English constituency parsing </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">DongxianGu</p>
  <div class="site-description" itemprop="description">Life,Happy,Code</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiangsu,Dongxian</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'VUd8OrYllPMWVxDqLagwIGsP-gzGzoHsz',
      appKey     : 'PiWbdIfbwtkQbPbW1Fh5WN2h',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
