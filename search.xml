<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>nmap基础教程</title>
    <url>/2020/02/05/nmap%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="nmap基础教程"><a href="#nmap基础教程" class="headerlink" title="nmap基础教程"></a>nmap基础教程</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Nmap主机扫描工具</p>
<p>主要功能：</p>
<ul>
<li>主机探测</li>
<li>端口扫描</li>
<li>版本检测</li>
<li>系统检测</li>
<li>支持探测脚本的编写</li>
</ul>
<p>应用场合</p>
<ul>
<li>通过对设备或者防火墙的探测来审计它的安全性</li>
<li>探测目标主机所开放的端口</li>
<li>通过识别新的服务器审计网络的安全性</li>
<li>探测网络上的主机</li>
</ul>
<h2 id="端口扫描工具"><a href="#端口扫描工具" class="headerlink" title="端口扫描工具"></a>端口扫描工具</h2><blockquote>
<p>借助工具，收集扫描IP提供哦你的计算机网络服务类型，从而发现弱点。</p>
</blockquote>
<p>常见服务对应端口</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>服务</th>
<th>端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP</td>
<td>80</td>
</tr>
<tr>
<td>HTTPS</td>
<td>443</td>
</tr>
<tr>
<td>Telnet</td>
<td>23</td>
</tr>
<tr>
<td>FTP</td>
<td>21</td>
</tr>
<tr>
<td>SSH（安全登录）、SCP（文件传输）、端口重定向</td>
<td>22</td>
</tr>
<tr>
<td>SMTP</td>
<td>25</td>
</tr>
<tr>
<td>POP3</td>
<td>110</td>
</tr>
<tr>
<td>WebLogic</td>
<td>7001</td>
</tr>
<tr>
<td>TOMCAT</td>
<td>8080</td>
</tr>
<tr>
<td>WIN2003远程登录</td>
<td>3389</td>
</tr>
<tr>
<td>Oracle数据库</td>
<td>1521</td>
</tr>
<tr>
<td>MS SQL* SEVER数据库sever</td>
<td>1433</td>
</tr>
<tr>
<td>MySQL 数据库sever</td>
<td>3306</td>
</tr>
</tbody>
</table>
</div>
<p>完整全面扫描</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -T4 -A -v</span><br></pre></td></tr></table></figure>
<p>其中-A选项用于使用进攻性（Aggressive）方式扫描；-T4指定扫描过程使用的时序（Timing），总有6个级别（0-5），级别越高，扫描速度越快，但也容易被防火墙或IDS检测并屏蔽掉，在网络通讯状况良好的情况推荐使用T4；-v表示显示冗余（verbosity）信息，在扫描过程中显示扫描的细节，从而让用户了解当前的扫描状态。</p>
<h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-sL: List Scan 列表扫描，仅将指定的目标的IP列举出来，不进行主机发现。  </span><br><span class="line">  </span><br><span class="line">-sn: Ping Scan 只进行主机发现，不进行端口扫描。  </span><br><span class="line">  </span><br><span class="line">-Pn: 将所有指定的主机视作开启的，跳过主机发现的过程。  </span><br><span class="line">  </span><br><span class="line">-PS/PA/PU/PY[portlist]: 使用TCPSYN/ACK或SCTP INIT/ECHO方式进行发现。  </span><br><span class="line">  </span><br><span class="line">-PE/PP/PM: 使用ICMP <span class="built_in">echo</span>, timestamp, and netmask 请求包发现主机。-PO[protocollist]: 使用IP协议包探测对方主机是否开启。  </span><br><span class="line">  </span><br><span class="line">-n/-R: -n表示不进行DNS解析；-R表示总是进行DNS解析。  </span><br><span class="line">  </span><br><span class="line">--dns-servers &lt;serv1[,serv2],...&gt;: 指定DNS服务器。  </span><br><span class="line">  </span><br><span class="line">--system-dns: 指定使用系统的DNS服务器  </span><br><span class="line">  </span><br><span class="line">--traceroute: 追踪每个路由节点</span><br></pre></td></tr></table></figure>
<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><ol>
<li><p>扫描方式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-sS/sT/sA/sW/sM:指定使用 TCP SYN/Connect()/ACK/Window/Maimon scans的方式来对目标主机进行扫描。  </span><br><span class="line">  </span><br><span class="line">  -sU: 指定使用UDP扫描方式确定目标主机的UDP端口状况。  </span><br><span class="line">  </span><br><span class="line">  -sN/sF/sX: 指定使用TCP Null, FIN, and Xmas scans秘密扫描方式来协助探测对方的TCP端口状态。  </span><br><span class="line">  </span><br><span class="line">  --scanflags &lt;flags&gt;: 定制TCP包的flags。  </span><br><span class="line">  </span><br><span class="line">  -sI &lt;zombiehost[:probeport]&gt;: 指定使用idle scan方式来扫描目标主机（前提需要找到合适的zombie host）  </span><br><span class="line">  </span><br><span class="line">  -sY/sZ: 使用SCTP INIT/COOKIE-ECHO来扫描SCTP协议端口的开放的情况。  </span><br><span class="line">  </span><br><span class="line">  -sO: 使用IP protocol 扫描确定目标机支持的协议类型。  </span><br><span class="line">  </span><br><span class="line">  -b &lt;FTP relay host&gt;: 使用FTP bounce scan扫描方式</span><br></pre></td></tr></table></figure>
</li>
<li><p>端口参数和扫描顺序</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-p &lt;port ranges&gt;: 扫描指定的端口  </span><br><span class="line">  </span><br><span class="line">实例: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9（其中T代表TCP协议、U代表UDP协议、S代表SCTP协议）  </span><br><span class="line">  </span><br><span class="line">-F: Fast mode – 快速模式，仅扫描TOP 100的端口  </span><br><span class="line">  </span><br><span class="line">-r: 不进行端口随机打乱的操作（如无该参数，nmap会将要扫描的端口以随机顺序方式扫描，以让nmap的扫描不易被对方防火墙检测到）。  </span><br><span class="line">  </span><br><span class="line">--top-ports &lt;number&gt;:扫描开放概率最高的number个端口（nmap的作者曾经做过大规模地互联网扫描，以此统计出网络上各种端口可能开放的概率。以此排列出最有可能开放端口的列表，具体可以参见文件：nmap-services。默认情况下，nmap会扫描最有可能的1000个TCP端口）  </span><br><span class="line">  </span><br><span class="line">--port-ratio &lt;ratio&gt;: 扫描指定频率以上的端口。与上述--top-ports类似，这里以概率作为参数，让概率大于--port-ratio的端口才被扫描。显然参数必须在在0到1之间，具体范围概率情况可以查看nmap-services文件。</span><br></pre></td></tr></table></figure>
</li>
<li><p>版本侦测</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-sV: 指定让Nmap进行版本侦测  </span><br><span class="line">  </span><br><span class="line">--version-intensity &lt;level&gt;: 指定版本侦测强度（0-9），默认为7。数值越高，探测出的服务越准确，但是运行时间会比较长。  </span><br><span class="line">  </span><br><span class="line">--version-light: 指定使用轻量侦测方式 (intensity 2)  </span><br><span class="line">  </span><br><span class="line">--version-all: 尝试使用所有的probes进行侦测 (intensity 9)  </span><br><span class="line">  </span><br><span class="line">--version-trace: 显示出详细的版本侦测过程信息。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><ol>
<li><p>Nmap扫描特定IP地址</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>用<code>-vv</code>对结果进行详细输出</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -vv &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>自行设置端口范围进行扫描</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -p1-998 &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>指定端口号进行扫描</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -p80,512,22,90,126,443 &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>对目标进行Ping扫描</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sP &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>路由跟踪</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -traceroute &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>扫描一个段的主机在线状况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sP &lt;network address &gt; &lt;/CIDR&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>操作系统探测</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -O &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>万能开关扫描</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -A &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>SYN扫描</strong>：利用基本的SYN扫描方式测试其端口开放状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">namp -sS -T4 &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>FIN扫描</strong>：利用FIN扫描方式探测防火墙状态。FIN扫描方式用于识别端口是否关闭，收到RST回复说明该端口关闭，否则说明是open或filtered状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">namp -sF -T4 &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>ACK扫描</strong>：利用ACK扫描判断端口是否被过滤。针对ACK探测包，为被过滤的端口（无论打开或关闭）会回复RST包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">namp -sA -T4 &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>扫描前不进行Ping扫描测试</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -Pn &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>如果有一个ip地址列表，将这个保存为一个txt文件，和nmap在同意目录下，扫描这个txt的所有主机，命令为</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -iL target.txt</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>版本检测扫描</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sV &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://www.cnblogs.com/weihua2616/p/6599629.html" target="_blank" rel="noopener">https://www.cnblogs.com/weihua2616/p/6599629.html</a></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>专利申请书书写</title>
    <url>/2020/02/02/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E4%B9%A6%E4%B9%A6%E5%86%99/</url>
    <content><![CDATA[<h1 id="专利申请书书"><a href="#专利申请书书" class="headerlink" title="专利申请书书"></a>专利申请书书</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>主要分为三个版块</p>
<ol>
<li>说明书摘要（必要时附摘要附图）</li>
<li>权利要求书</li>
<li>说明书（技术领域、背景技术、发明内容、附图说明、具体实施方式、附图）。</li>
</ol>
<h2 id="说明书摘要-abstract"><a href="#说明书摘要-abstract" class="headerlink" title="说明书摘要 abstract"></a>说明书摘要 abstract</h2><p>对整个发明做系统描述，介绍发明的特点和创新点。必要时请附上图片，以便说明和理解</p>
<h2 id="权利要求书"><a href="#权利要求书" class="headerlink" title="权利要求书"></a>权利要求书</h2><blockquote>
<p>专利法第二十六条第四款、专利法实施细则第二十条和第二十一条对权利要求书的撰写要求作了明确的规定，审查指南又对此作了更具体的规定，现分为实质性要求和形式要求两部分来加以说明。</p>
</blockquote>
<ol>
<li>实质性要求</li>
</ol>
<p>　　按照专利法及其实施细则的规定，权利要求书撰写的实质性要求为：权利要求书以说明书为依据；清楚、简明地表述请求保护的范围。</p>
<ol>
<li>形式要求<ul>
<li>权利要求中包括几项权利要求的，应当用阿拉伯数字顺序编号；</li>
<li>若有几项独立权利要求，各自的从属权利要求应当尽量紧靠其所引用的权利要求；</li>
<li>每一项权利要求只允许在其结尾使用句号，以强调其含义是不可分割的整体；</li>
<li>权利要求中使用的科技术语应当与说明书中使用的一致；</li>
<li>权利要求中可以有化学式、化学反应式或者数学式，但不得有插图；</li>
<li>除非绝对必要时，权利要求中不得使用”如说明书……部分所述”或者”如图……所示”等类似用语；</li>
<li>权利要求中通常不允许使用表格，除非使用表格能够更清楚地说明发明或实用新型要求保护的客体；</li>
<li>权利要求中的技术特征可以引用说明书附图中相应的附图标记，但必须加括号，且附图标记不得解释为对权利要求保护范围的限制；</li>
<li>除附图标记或者其它必要情形必须使用括号外，权利要求中应当尽量避免使用括号；</li>
<li>权利要求中采用并列选择时，其含义应当是清楚的；</li>
<li>一般情形下，权利要求不得引用人名、地名、商品名或者商标名称</li>
</ul>
</li>
</ol>
<h2 id="说明书"><a href="#说明书" class="headerlink" title="说明书"></a>说明书</h2><p>技术领域、背景技术、发明内容、附图说明、具体实施方式、附图</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://blog.csdn.net/u010440456/article/details/87801236" target="_blank" rel="noopener">https://blog.csdn.net/u010440456/article/details/87801236</a></li>
</ol>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx一般配置</title>
    <url>/2020/01/19/Nginx%E4%B8%80%E8%88%AC%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Nginx一般配置"><a href="#Nginx一般配置" class="headerlink" title="Nginx一般配置"></a>Nginx一般配置</h1><blockquote>
<p>一般后台项目配置到Nginx中</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">http</span> <span class="string">&#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">##</span></span><br><span class="line">	<span class="comment"># Basic Settings</span></span><br><span class="line">	<span class="comment">##</span></span><br><span class="line">	<span class="string">sendfile</span> <span class="string">on;</span></span><br><span class="line">	<span class="string">tcp_nopush</span> <span class="string">on;</span></span><br><span class="line">	<span class="string">tcp_nodelay</span> <span class="string">on;</span></span><br><span class="line">	<span class="string">keepalive_timeout</span> <span class="number">65</span><span class="string">;</span></span><br><span class="line">	<span class="string">types_hash_max_size</span> <span class="number">2048</span><span class="string">;</span></span><br><span class="line">	<span class="comment"># server_tokens off;</span></span><br><span class="line">	<span class="comment"># server_names_hash_bucket_size 64;</span></span><br><span class="line">	<span class="comment"># server_name_in_redirect off;</span></span><br><span class="line">	<span class="string">include</span> <span class="string">/etc/nginx/mime.types;</span></span><br><span class="line">	<span class="string">default_type</span> <span class="string">application/octet-stream;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">##</span></span><br><span class="line">	<span class="comment"># SSL Settings</span></span><br><span class="line">	<span class="comment">##</span></span><br><span class="line"></span><br><span class="line">	<span class="string">ssl_protocols</span> <span class="string">TLSv1</span> <span class="string">TLSv1.1</span> <span class="string">TLSv1.2;</span> <span class="comment"># Dropping SSLv3, ref: POODLE</span></span><br><span class="line">	<span class="string">ssl_prefer_server_ciphers</span> <span class="string">on;</span></span><br><span class="line">	<span class="string">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">listen</span> <span class="number">80</span><span class="string">;</span></span><br><span class="line">        <span class="string">return</span> <span class="number">301</span> <span class="attr">https://$http_host$request_uri;</span></span><br><span class="line">		<span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">    		<span class="string">proxy_pass</span>      <span class="attr">http://127.0.0.1:8000;</span> <span class="comment"># 代理本地地址</span></span><br><span class="line">   		<span class="string">&#125;</span></span><br><span class="line">	<span class="string">&#125;</span></span><br><span class="line">    <span class="string">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="comment"># SSL 配置</span></span><br><span class="line"> 		<span class="string">listen</span> <span class="number">443</span><span class="string">;</span></span><br><span class="line">		<span class="string">ssl</span> <span class="string">on;</span></span><br><span class="line">		<span class="string">ssl_certificate</span> <span class="string">/etc/nginx/server.crt;</span> <span class="comment">#(证书公钥)</span></span><br><span class="line">		<span class="string">ssl_certificate_key</span> <span class="string">/etc/nginx/server.key;</span> <span class="comment">#(证书私钥)</span></span><br><span class="line">		<span class="string">ssl_session_timeout</span> <span class="number">5</span><span class="string">m;</span></span><br><span class="line">		<span class="string">ssl_protocols</span>  <span class="string">SSLv2</span> <span class="string">SSLv3</span> <span class="string">TLSv1;</span></span><br><span class="line">		<span class="string">ssl_ciphers</span>  <span class="attr">HIGH:!aNULL:!MD5;</span></span><br><span class="line">		<span class="string">ssl_prefer_server_ciphers</span> <span class="string">on;</span>		</span><br><span class="line"> </span><br><span class="line">		<span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">	    	<span class="string">proxy_pass</span>      <span class="attr">http://127.0.0.1:8000;</span> <span class="comment"># tomcat服务器地址</span></span><br><span class="line">	  		<span class="comment">#  root /usr/share/nginx/html/;  # 本地静态网页路径</span></span><br><span class="line">		<span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="comment"># 配置 ws/wss</span></span><br><span class="line">	<span class="string">upstream</span> <span class="string">websocket</span> <span class="string">&#123;</span>  </span><br><span class="line">    	<span class="string">server</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9001;</span>  </span><br><span class="line">	<span class="string">&#125;</span>  </span><br><span class="line">	<span class="string">server</span> <span class="string">&#123;</span>  </span><br><span class="line">    	<span class="string">listen</span> <span class="number">8888</span><span class="string">;</span>  </span><br><span class="line">    	<span class="string">ssl</span> <span class="string">on;</span></span><br><span class="line">		<span class="string">ssl_certificate</span> <span class="string">/etc/nginx/server.crt;</span> <span class="comment">#(证书公钥)</span></span><br><span class="line">		<span class="string">ssl_certificate_key</span> <span class="string">/etc/nginx/server.key;</span> <span class="comment">#(证书私钥)</span></span><br><span class="line">    	<span class="string">ssl_session_timeout</span> <span class="number">20</span><span class="string">m;</span></span><br><span class="line">   	 	<span class="string">ssl_verify_client</span> <span class="string">off;</span></span><br><span class="line">    	<span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">	        <span class="string">proxy_pass</span> <span class="attr">http://websocket;</span>  </span><br><span class="line">       		<span class="string">proxy_http_version</span> <span class="number">1.1</span><span class="string">;</span>  </span><br><span class="line">        	<span class="string">proxy_set_header</span> <span class="string">Connection</span> <span class="string">"Upgrade"</span><span class="string">;</span>  </span><br><span class="line">    	<span class="string">&#125;</span>  </span><br><span class="line">	<span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
  </entry>
  <entry>
    <title>Go语言学习</title>
    <url>/2020/01/18/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Go语言学习"><a href="#Go语言学习" class="headerlink" title="Go语言学习"></a>Go语言学习</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>布尔型<br>布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</li>
<li>数字类型<br>整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</li>
<li>字符串类型:<br>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</li>
<li>派生类型:<br>包括：<ul>
<li>指针类型（Pointer）</li>
<li>数组类型</li>
<li>结构化类型(struct)</li>
<li>Channel 类型</li>
<li>函数类型</li>
<li>切片类型</li>
<li>接口类型（interface）</li>
<li>Map 类型</li>
</ul>
</li>
</ol>
<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p><a href="https://blog.csdn.net/xiaoyida11/article/details/51554022" target="_blank" rel="noopener">参考链接</a></p>
<h2 id="变量-variance"><a href="#变量-variance" class="headerlink" title="变量 variance"></a>变量 variance</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span> = <span class="string">"string"</span></span><br><span class="line"><span class="keyword">var</span> vname vtype <span class="comment">//自动赋初始值 </span></span><br><span class="line">vname = value</span><br><span class="line"><span class="keyword">var</span> v_name = value <span class="comment">// 自动判断类型</span></span><br><span class="line">v_name := value <span class="comment">// 声明新的变量，v_name 不是新变量编译出错</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>数值类型（包括complex64/128）为 0</p>
</li>
<li><p>布尔类型为 false</p>
</li>
<li><p>字符串为 “”（空字符串）</p>
</li>
<li><p>以下几种类型为 nil：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">a</span> <span class="title">error</span> // <span class="title">error</span> 是接口</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型相同多个变量, 非全局变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3 <span class="comment">// 和 python 很像,不需要显示声明类型，自动推断</span></span><br><span class="line"></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3 <span class="comment">// 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>值类型和引用类型</p>
<blockquote>
<p>所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值：</p>
</blockquote>
<p>通过 <code>&amp;i</code> 来获取变量 <code>i</code> 的内存地址</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br><span class="line"><span class="keyword">const</span> c_name1, c_name2 = value1, value2</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>iota</p>
<blockquote>
<p>iota，特殊常量，可以认为是一个可以被编译器修改的常量。<br>iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">	b          <span class="comment">//1</span></span><br><span class="line">	c          <span class="comment">//2</span></span><br><span class="line">	d = <span class="string">"ha"</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">	e          <span class="comment">//"ha"   iota += 1</span></span><br><span class="line">	f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">	g          <span class="comment">//100  iota +=1</span></span><br><span class="line">	h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">	i          <span class="comment">//8</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>其他运算符</li>
</ul>
<p>运算符优先级</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>* / % &lt;&lt; &gt;&gt; &amp; &amp;^</td>
</tr>
<tr>
<td>4</td>
<td>+ - \</td>
<td>\^</td>
</tr>
<tr>
<td>3</td>
<td>== != &lt; &lt;= &gt; &gt;=</td>
</tr>
<tr>
<td>2</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>1</td>
<td>\</td>
<td>\</td>
</tr>
</tbody>
</table>
</div>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* 在布尔表达式为 false 时执行 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s); </span><br><span class="line">    <span class="comment">/* 你可以定义任意个数的case */</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            fmt.Println(<span class="string">"1、case 条件语句为 false"</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            fmt.Println(<span class="string">"2、case 条件语句为 true"</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            fmt.Println(<span class="string">"3、case 条件语句为 false"</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            fmt.Println(<span class="string">"4、case 条件语句为 true"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            fmt.Println(<span class="string">"5、case 条件语句为 false"</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"6、默认 case"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。</p>
<p>select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);</span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每个 case 都必须是一个通信</li>
<li>所有 channel 表达式都会被求值</li>
<li>所有被发送的表达式都会被求值</li>
<li>如果任意某个通信可以进行，它就执行，其他被忽略。</li>
<li>如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。</li>
<li>否则：<ul>
<li>如果有 default 子句，则执行该语句。</li>
<li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</li>
</ul>
</li>
</ul>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> [condition |  ( init; condition; increment ) | Range]</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span> [condition |  ( init; condition; increment ) | Range]</span><br><span class="line">   &#123;</span><br><span class="line">      statement(s);</span><br><span class="line">   &#125;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>break</li>
<li>continue</li>
<li>goto</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span> &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>func：函数由 func 开始声明</li>
<li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li>
<li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li>
<li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li>
<li>函数体：函数定义的代码集合。</li>
</ul>
<p>函数参数</p>
<ul>
<li><p>值传递</p>
<blockquote>
<p>默认</p>
</blockquote>
</li>
<li><p>引用传递</p>
<blockquote>
<p>引用传递指针参数传递到函数内</p>
</blockquote>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义交换值函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="keyword">int</span>, y *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="keyword">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保持 x 地址上的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 值赋给 y */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数用法</p>
<ul>
<li>函数作为另外一个函数的实参：函数定义后可作为另外一个函数的实参数传入</li>
<li>闭包：闭包是匿名函数，可在动态编程中使用</li>
<li><p>方法：方法就是一个包含了接受者的函数</p>
<blockquote>
<p>Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。</p>
</blockquote>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(variable_name variable_data_type)</span> <span class="title">function_name</span><span class="params">()</span> [<span class="title">return_type</span>]</span>&#123;</span><br><span class="line">   <span class="comment">/* 函数体*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>变量声明的位置</p>
<ul>
<li><p>函数内定义的变量称为局部变量</p>
<blockquote>
<p>作用域只在函数体内，参数和返回值变量也是局部变量。</p>
</blockquote>
</li>
<li><p>函数外定义的变量称为全局变量</p>
<blockquote>
<p>全局变量可以在整个包甚至外部包（被导出后）使用。</p>
</blockquote>
</li>
<li>函数定义中的变量称为形式参数<blockquote>
<p>形式参数会作为函数的局部变量来使用。</p>
</blockquote>
</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>声明数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure>
<p>初始化数组<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> balance = [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line"><span class="keyword">var</span> balance = [...]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line">balance[<span class="number">4</span>] = <span class="number">50.0</span></span><br></pre></td></tr></table></figure></p>
<p>多维数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE1][SIZE2]...[SIZEN] variable_type</span><br><span class="line">a = [<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  第一行索引为 0 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  第二行索引为 1 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;,   <span class="comment">/* 第三行索引为 2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">void myFunction(param [<span class="number">10</span>]<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myFunction(param []<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *<span class="keyword">var</span>-<span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span>= <span class="number">20</span>   <span class="comment">/* 声明实际变量 */</span></span><br><span class="line">   <span class="keyword">var</span> ip *<span class="keyword">int</span>        <span class="comment">/* 声明指针变量 */</span></span><br><span class="line"></span><br><span class="line">   ip = &amp;a  <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">"a 变量的地址是: %x\n"</span>, &amp;a  )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line">   fmt.Printf(<span class="string">"ip 变量储存的指针地址: %x\n"</span>, ip )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   fmt.Printf(<span class="string">"*ip 变量的值: %d\n"</span>, *ip )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition</span><br><span class="line">   member definition</span><br><span class="line">   ...</span><br><span class="line">   member definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br><span class="line">或</span><br><span class="line">variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</span><br></pre></td></tr></table></figure>
<p>访问成员：<code>结构体.成员名</code></p>
<p>结构体指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> struct_pointer *Books</span><br></pre></td></tr></table></figure>
<h2 id="切片-Slice"><a href="#切片-Slice" class="headerlink" title="切片 Slice"></a>切片 Slice</h2><p>声明一个未指定大小的数组来定义切片<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br></pre></td></tr></table></figure></p>
<p>使用make()函数来创建切片:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure>
<ul>
<li>length 初始长度</li>
<li>capacity 容量</li>
</ul>
<p>初始化切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s :=[] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125; </span><br><span class="line">s := arr[:] </span><br><span class="line">s := arr[startIndex:endIndex] </span><br><span class="line">s := arr[startIndex:] </span><br><span class="line">s := arr[:endIndex] </span><br><span class="line">s1 := s[startIndex:endIndex] </span><br><span class="line">s :=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure>
<p>len() 和 cap() 函数</p>
<ul>
<li>切片是可索引的，并且可以由 len() 方法获取长度。</li>
<li>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</li>
</ul>
<p>一个切片在未初始化之前默认为 nil，长度为 0，实例如下：</p>
<p>切片截取<br>设置下限及上限来设置截取切片 <code>[lower-bound:upper-bound]</code></p>
<p>append() 和 copy() 函数</p>
<ul>
<li>拷贝切片的 copy 方法</li>
<li>向切片追加新元素的 append 方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line"><span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line"><span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line"><span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"><span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line"><span class="built_in">copy</span>(numbers1,numbers)</span><br></pre></td></tr></table></figure>
<h2 id="Range-范围"><a href="#Range-范围" class="headerlink" title="Range 范围"></a>Range 范围</h2><blockquote>
<p>Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。</p>
</blockquote>
<h2 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map(集合)"></a>Map(集合)</h2><blockquote>
<p>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。<br>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</p>
</blockquote>
<p>定义 Map</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明变量，默认 map 是 nil */</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 make 函数 */</span></span><br><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">   fmt.Println(country, <span class="string">"首都是"</span>, countryCapitalMap [country])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查看元素在集合中是否存在 */</span></span><br><span class="line">capital, ok := countryCapitalMap [ <span class="string">"American"</span> ] <span class="comment">/*如果确定是真实的,则存在,否则不存在 */</span></span><br><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">    fmt.Println(<span class="string">"American 的首都是"</span>, capital)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"American 的首都不存在"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delete() 函数</p>
<blockquote>
<p>delete() 函数用于删除集合的元素, 参数为 map 和其对应的 key。实例如下：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(countryCapitalMap, <span class="string">"Key"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">type_name(expression)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> sum <span class="keyword">int</span> = <span class="number">17</span></span><br><span class="line">   <span class="keyword">var</span> count <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line">   <span class="keyword">var</span> mean <span class="keyword">float32</span></span><br><span class="line">   </span><br><span class="line">   mean = <span class="keyword">float32</span>(sum)/<span class="keyword">float32</span>(count)</span><br><span class="line">   fmt.Printf(<span class="string">"mean 的值为: %f\n"</span>,mean)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义接口 */</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">   method_name1 [return_type]</span><br><span class="line">   method_name2 [return_type]</span><br><span class="line">   method_name3 [return_type]</span><br><span class="line">   ...</span><br><span class="line">   method_namen [return_type]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">/* variables */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现接口方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_name1</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现 */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_namen</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>Go 语言通过内置的错误接口提供了非常简单的错误处理机制。</p>
<p>error类型是一个接口类型，这是它的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"math: square root of negative number"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>Go 语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。</p>
<p>goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</p>
<p>goroutine 语法格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名( 参数列表 )</span><br></pre></td></tr></table></figure>
<p>通道（channel）:是用来传递数据的一个数据结构。</p>
<blockquote>
<p>通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 &lt;- 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 把 v 发送到通道 ch</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收数据</span></span><br><span class="line">           <span class="comment">// 并把值赋给 v</span></span><br></pre></td></tr></table></figure>
<p>声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>通道缓冲区<br>Channel buffer<br>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p>
<p>不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</p>
<p>注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p>
<p>Go 遍历通道与关闭通道</p>
<p>通过 <code>range</code> 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure>
<p>如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                c &lt;- x</span><br><span class="line">                x, y = y, x+y</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">        <span class="comment">// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个</span></span><br><span class="line">        <span class="comment">// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据</span></span><br><span class="line">        <span class="comment">// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不</span></span><br><span class="line">        <span class="comment">// 会结束，从而在接收第 11 个数据的时候就阻塞了。</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">                fmt.Println(i)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
  </entry>
  <entry>
    <title>遗传算法Java实现</title>
    <url>/2020/01/11/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="遗传算法Java实现"><a href="#遗传算法Java实现" class="headerlink" title="遗传算法Java实现"></a>遗传算法Java实现</h1><blockquote>
<p>采用了最优策略的GA：每次迭代保存当前最优的个体</p>
</blockquote>
<ol>
<li>GA （主要文件）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 种群规模</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> scale;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大迭代次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxGen;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前迭代次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> curGen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交叉概率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> rateOfCross;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变异概率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> rateOfMutate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 染色体长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dnaLength;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始种群，父代种群，行数表示种群规模，一行代表一个个体，即染色体，列表示染色体基因片段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[][] oldPopulation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新的种群，子代种群</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] newPopulation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 种群适应度，表示种群中各个个体的适应度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] fitness;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义域范围</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> minThreshold;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> maxThreshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 累积矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] accumlateMatrix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 评估类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IEvalFunc eval;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GA</span><span class="params">(<span class="keyword">int</span> scale, <span class="keyword">int</span> maxGen, <span class="keyword">double</span> rateOfCross, <span class="keyword">double</span> rateOfMutate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scale = scale;</span><br><span class="line">        <span class="keyword">this</span>.maxGen = maxGen;</span><br><span class="line">        <span class="keyword">this</span>.rateOfCross = rateOfCross;</span><br><span class="line">        <span class="keyword">this</span>.rateOfMutate = rateOfMutate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dnaLength</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minThreshold</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxThreshold</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> dnaLength, <span class="keyword">double</span> minThreshold, <span class="keyword">double</span> maxThreshold, IEvalFunc eval)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.oldPopulation = <span class="keyword">new</span> <span class="keyword">double</span>[scale][dnaLength];</span><br><span class="line">        <span class="keyword">this</span>.newPopulation = <span class="keyword">new</span> <span class="keyword">double</span>[scale][dnaLength];</span><br><span class="line">        <span class="keyword">this</span>.fitness = <span class="keyword">new</span> <span class="keyword">double</span>[scale];</span><br><span class="line">        <span class="keyword">this</span>.minThreshold = minThreshold;</span><br><span class="line">        <span class="keyword">this</span>.maxThreshold = maxThreshold;</span><br><span class="line">        <span class="keyword">this</span>.random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">this</span>.dnaLength = dnaLength;</span><br><span class="line">        <span class="keyword">this</span>.eval = eval;</span><br><span class="line">        <span class="keyword">this</span>.accumlateMatrix = <span class="keyword">new</span> <span class="keyword">double</span>[scale];</span><br><span class="line">        <span class="keyword">this</span>.curGen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化种群</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scale; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span>[] individual = <span class="keyword">new</span> <span class="keyword">double</span>[dnaLength];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dnaLength; j++) &#123;</span><br><span class="line">                individual[j] = minThreshold + (maxThreshold - minThreshold) * getRandom();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.oldPopulation[i] = individual;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算初始种群的适应度和累积矩阵</span></span><br><span class="line">        calFitness();</span><br><span class="line">        calAccumulateMatrix();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算适应度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calFitness</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scale; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.fitness[i] = evaluate(<span class="keyword">this</span>.oldPopulation[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算累积矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calAccumulateMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算初始累积概率</span></span><br><span class="line">        <span class="keyword">double</span> sumEval = <span class="number">0.0</span>;</span><br><span class="line">        <span class="comment">//double minFitness = Arrays.stream(this.fitness).min().getAsDouble();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scale; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> curFitness = <span class="keyword">this</span>.fitness[i];</span><br><span class="line">            sumEval += curFitness;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.accumlateMatrix[i] = curFitness;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.accumlateMatrix[i] = <span class="keyword">this</span>.accumlateMatrix[i - <span class="number">1</span>] + curFitness;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; scale; j++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.accumlateMatrix[j] /= sumEval;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始进化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (curGen = <span class="number">0</span>; curGen &lt; maxGen; curGen++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//达到最小误差 退出</span></span><br><span class="line"><span class="comment">//            if (Math.abs(this.fitness[scale-2]-this.fitness[scale-1]) &lt; 10E-5)&#123;</span></span><br><span class="line"><span class="comment">//                break;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次迭代 保存最优个体</span></span><br><span class="line">            <span class="keyword">double</span> tmpFitness = <span class="keyword">this</span>.fitness[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> bestIndividualIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.scale; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.fitness[i] &gt; tmpFitness) &#123;</span><br><span class="line">                    tmpFitness = <span class="keyword">this</span>.fitness[i];</span><br><span class="line">                    bestIndividualIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            newPopulation[<span class="number">0</span>] = <span class="keyword">this</span>.oldPopulation[bestIndividualIndex];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//选择剩下scale-1个体</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; scale; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> A = choose();</span><br><span class="line">                <span class="keyword">int</span> B;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    B = choose();</span><br><span class="line">                &#125; <span class="keyword">while</span> (A == B);</span><br><span class="line">                <span class="comment">//交叉</span></span><br><span class="line">                crossover(A, B, i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对于每个位置变异</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; scale; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.random.nextDouble() &lt; rateOfMutate) &#123;</span><br><span class="line">                    mutate(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            reCalculate();</span><br><span class="line">            System.out.println(String.format(<span class="string">"curGen: %d, the best fitness is %.6f"</span>, curGen, Arrays.stream(<span class="keyword">this</span>.fitness).max().getAsDouble()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重新计算参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reCalculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scale; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.oldPopulation[i] = <span class="keyword">this</span>.newPopulation[i];</span><br><span class="line">        &#125;</span><br><span class="line">        calFitness();</span><br><span class="line">        calAccumulateMatrix();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回选择个体的index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">choose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据累积矩阵选择</span></span><br><span class="line">        <span class="keyword">double</span> rate = getRandom();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.scale - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rate &lt; <span class="keyword">this</span>.accumlateMatrix[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rate &gt; <span class="keyword">this</span>.accumlateMatrix[i] &amp;&amp; rate &lt; <span class="keyword">this</span>.accumlateMatrix[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.scale - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交叉</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A     父母</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> B     父母</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 新种群的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crossover</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果不满足交叉概率，直接将A插入新的种群</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.random.nextDouble() &gt; <span class="keyword">this</span>.rateOfCross) &#123;</span><br><span class="line">            <span class="keyword">this</span>.newPopulation[index] = <span class="keyword">this</span>.oldPopulation[A];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span>[] newIndividual = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="keyword">this</span>.dnaLength];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dnaLength; i++) &#123;</span><br><span class="line">            newIndividual[i] = <span class="number">0.5</span> * <span class="keyword">this</span>.oldPopulation[A][i] + (<span class="number">1</span> - <span class="number">0.5</span>) * <span class="keyword">this</span>.oldPopulation[B][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.newPopulation[index] = newIndividual;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变异</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 个体的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mutate</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> stepDistance = <span class="number">0.05</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dnaLength; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> dir = <span class="keyword">this</span>.random.nextInt() % <span class="number">2</span> == <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.newPopulation[index][i] = <span class="keyword">this</span>.newPopulation[index][i] + stepDistance * dir;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 评估</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">evaluate</span><span class="params">(<span class="keyword">double</span>[] individual)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        return -(Math.pow(individual[0], 2) + 2 * individual[0] + 1);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.eval.eval(individual);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.random.nextDouble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>evaluate 接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 评估函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEvalFunc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">eval</span><span class="params">(<span class="keyword">double</span>[] A)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>测试文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GAMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GA ga = <span class="keyword">new</span> GA(<span class="number">10</span>, <span class="number">300</span>, <span class="number">1</span>, <span class="number">0.015</span>);</span><br><span class="line">        <span class="comment">// -(x^2+2x+1)</span></span><br><span class="line"><span class="comment">//        ga.init(1,-2,2, A -&gt; -(Math.pow(A[0], 2) + 3 * A[0] + 1));</span></span><br><span class="line">        ga.init(<span class="number">2</span>,-<span class="number">2</span>,<span class="number">2</span>, A -&gt; (Math.cos(A[<span class="number">0</span>]) + Math.sin(A[<span class="number">1</span>])));</span><br><span class="line">        ga.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> [] item : ga.oldPopulation)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; item.length; i++) &#123;</span><br><span class="line">                System.out.print(item[i]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>maven中scope详解</title>
    <url>/2020/01/10/maven%E4%B8%ADscope%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="maven中scope详解"><a href="#maven中scope详解" class="headerlink" title="maven中scope详解"></a>maven中scope详解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h5 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h5><ul>
<li>Maven 的哲学思想是，约定优于配置（Convention Over Configuration），Maven 依赖中 scope 的默认值是<strong>compile</strong></li>
<li>Scope 指定了依赖（第三方jar包）的 <strong>作用范围</strong></li>
<li>作用范围包括，所在项目的<strong>测试、编译、运行、打包等</strong>生命周期</li>
<li>其中，编译和运行还分为<ul>
<li><strong>测试代码</strong>的编译和运行</li>
<li><strong>非测试代码</strong>的编译和运行</li>
</ul>
</li>
</ul>
<h2 id="scope分类"><a href="#scope分类" class="headerlink" title="scope分类"></a>scope分类</h2><ol>
<li><p>test 测试范围</p>
<p>测试范围的依赖（第三方jar包），<strong>针对测试相关代码的编译和运行</strong>，在<strong>通常代码</strong>的编译和运行时都不需要，只有在<strong>有关测试的代码编译和运行测试代码阶段</strong>可用</p>
</li>
<li><p>compile 编译范围</p>
<p><strong>依赖默认范围</strong>，该依赖需要参与当前项目的<strong>编译、测试、运行、打包</strong></p>
</li>
<li><p>runtime 运行时范围</p>
<p>表示依赖<strong>无需参与当前项目的编译</strong>，但是后期的<strong>运行和测试</strong>需要参与，不参与编译能运行成功吗？？</p>
<p>与 compile 相比，<strong>跳过编译</strong>而已</p>
<p>比如，你可能在编译的时候需要 JDBC API JAR，只有在 <strong>运行时</strong>才需要 JDBC</p>
<p>貌似是编译时<strong>该包不参与</strong>，运行时参与<strong>？</strong></p>
</li>
<li><p>provided 表明该依赖已经提供，故只在未提供时才被使用</p>
<p>应用场景是你定义了一个Servlet，此刻得需要Servlet-api.jar 才能编译成功，但是当你达成<strong>war 包</strong>时，你并不想将 Servlet-api.jar 包进去，因为<strong>Tomcat等容器会提供</strong></p>
<p>跟compile 类似，说明JDK、容器或使用者会<strong>提供这个依赖</strong>，如Servlet.jar</p>
<p>这个依赖只作用在<strong> 编译和测试</strong>，该依赖会由系统组件提供，不需<strong>手动添加</strong>，只存在<strong>编译、运行、测试阶段</strong>，打包是不用包进去，打包阶段做了<strong>exclude</strong>动作</p>
<p>没有传递性</p>
</li>
<li><p>system</p>
<p>被依赖项<strong>不会从maven仓库下载</strong>，而是<strong>从本地系统指定路径下寻找</strong>，需要 systemPath 属性</p>
</li>
</ol>
<h2 id="scope-的传递依赖"><a href="#scope-的传递依赖" class="headerlink" title="scope 的传递依赖"></a>scope 的传递依赖</h2><p> A -&gt; B -&gt; C, 当前项目 A，A依赖于B，B依赖于C，知道B在 A中的scope，怎么知道 C在 A 中的 scope</p>
<ul>
<li>即，<strong>A需不需要 C的问题</strong>，本质由 <strong>C在B中的scope决定</strong></li>
<li>当 C 在 B 中的scope 是test 或 provided 时，C <strong>直接被丢弃</strong>，<strong>A不依赖C</strong></li>
<li>否则 A 依赖 C，C的scope <strong>继承与B 的scope</strong></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>链接：<a href="https://www.jianshu.com/p/a9bd44a83dc5" target="_blank" rel="noopener">https://www.jianshu.com/p/a9bd44a83dc5</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Awk命令的使用</title>
    <url>/2020/01/10/Awk%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Awk命令的使用"><a href="#Awk命令的使用" class="headerlink" title="Awk命令的使用"></a>Awk命令的使用</h1><blockquote>
<p>The awk utility shall execute programs written in the  awk  programming<br>      language,  which  is  specialized for textual data manipulation. An awk<br>      program is a sequence of patterns and corresponding actions. When input<br>      is read that matches a pattern, the action associated with that pattern<br>      is carried out.</p>
</blockquote>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk '&#123;pattern + action&#125;' &#123;filenames&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>pattern 表示 AWK 在数据中查找的内容</li>
<li>action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 </li>
<li>pattern就是要表示的正则表达式，用斜杠括起来。</li>
</ul>
<p>awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。</p>
<p>通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> awk '&#123; print $0 &#125;' /etc/passwd      </span><br><span class="line">root:x:0:0::/root:/bin/bash</span><br><span class="line">nobody:x:65534:65534:Nobody:/:/usr/bin/nologin</span><br><span class="line">dbus:x:81:81:System Message Bus:/:/usr/bin/nologin</span><br><span class="line">bin:x:1:1::/:/usr/bin/nologin</span><br><span class="line">daemon:x:2:2::/:/usr/bin/nologin</span><br><span class="line">mail:x:8:12::/var/spool/mail:/usr/bin/nologin</span><br><span class="line">ftp:x:14:11::/srv/ftp:/usr/bin/nologin</span><br><span class="line">http:x:33:33::/srv/http:/usr/bin/nologin</span><br></pre></td></tr></table></figure>
<p>调用 awk时，我们指定/etc/passwd 作为输入文件。执行 awk 时，它依次对/etc/passwd 中的每一行执行 print 命令。</p>
<p><img src="/images/awk_format.jpg" alt="&#39;awk 格式&#39;"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> awk -F":" '&#123; print $1 &#125;' /etc/passwd</span><br><span class="line"><span class="meta">$</span> awk -F":" '&#123; print $1 $3 &#125;' /etc/passwd</span><br><span class="line"><span class="meta">$</span> awk -F":" '&#123; print $1 " " $3 &#125;' /etc/passwd</span><br><span class="line"><span class="meta">$</span> awk -F":" '&#123; print "username: " $1 "\t\tuid:" $3" &#125;' /etc/passwd</span><br></pre></td></tr></table></figure>
<p><code>-F</code>参数：指定分隔符，可指定一个或多个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> awk -F":" '&#123; if (NR &gt; 5 &amp;&amp; NR &lt;= 10) print $1 &#125;' /etc/passwd</span><br><span class="line">mail</span><br><span class="line">ftp</span><br><span class="line">http</span><br><span class="line">systemd-journal-remote</span><br><span class="line">systemd-network</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F '[ ,]+' '&#123;print $3" "$7&#125;' test.txt</span><br></pre></td></tr></table></figure>
<p>统计<code>/etc/passwd</code>的账户人数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> awk '&#123;count++&#125; END&#123; print "user count is",count&#125;' /etc/passwd</span><br><span class="line">user count is 30</span><br></pre></td></tr></table></figure>
<p>统计某个文件夹下的文件占用的字节数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> ls -l | awk 'BEGIN&#123;size=0;&#125; &#123;size=size+$5&#125; END&#123;print "[end]size is",size&#125;'</span><br><span class="line">[end]size is 36268220</span><br><span class="line"><span class="meta">$</span> ls -l | awk 'BEGIN&#123;size=0;&#125; &#123;size=size+$5&#125; END&#123;print "[end]size is",size/1024/1024,"M"&#125;'</span><br><span class="line">[end]size is 34.5881 M</span><br></pre></td></tr></table></figure>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>= += -= <em>= /= %= ^= *</em>=</td>
<td>赋值语句</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td>&amp;&amp;</td>
<td>逻辑运算符</td>
</tr>
<tr>
<td>~  !~</td>
<td>正则运算符</td>
</tr>
<tr>
<td>&lt; &lt;= &gt; &gt;= != ==</td>
<td>关系运算符</td>
</tr>
<tr>
<td>+ - * / &amp; ++ — ！</td>
<td>算术运算符 &amp;求余</td>
</tr>
<tr>
<td>$ ?: 空格 ln</td>
<td>其他运算符</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> awk 'BEGIN&#123;a=5;a+=5;print a&#125;'                                         </span><br><span class="line">10</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> awk 'BEGIN&#123;a=1;b=2; print (a&gt;1&amp;&amp;b==2,a&gt;=0 || b&gt;1)&#125;'</span><br><span class="line">0 1</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> awk 'BEGIN&#123;a="1234gwx";if(a~/4g/) &#123;print "ok"&#125;&#125;'   </span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><div class="table-container">
<table>
<thead>
<tr>
<th>变量名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0</td>
<td>当前记录</td>
</tr>
<tr>
<td>$1-$n</td>
<td>当前记录的第n个字段</td>
</tr>
<tr>
<td>FS</td>
<td>输入字段分隔符，默认空格</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符，默认换行符</td>
</tr>
<tr>
<td>NF</td>
<td>当前记录的字段数目</td>
</tr>
<tr>
<td>NR</td>
<td>以及读出记录数，从1开始</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段分隔符</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> awk 'BEGIN&#123;FS=":"&#125;&#123;print $1 &#125;' /etc/passwd      </span><br><span class="line">root</span><br><span class="line">nobody</span><br><span class="line">dbus</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line"><span class="meta">$</span> awk 'BEGIN&#123;FS=":";OFS="#";ORS="\\\n"&#125;&#123;print $1,$2&#125;' /etc/passwd</span><br><span class="line"><span class="meta">root#</span>x\</span><br><span class="line"><span class="meta">nobody#</span>x\</span><br><span class="line"><span class="meta">dbus#</span>x\</span><br><span class="line"><span class="meta">bin#</span>x\</span><br><span class="line"><span class="meta">daemon#</span>x\</span><br><span class="line"><span class="meta">mail#</span>x\</span><br></pre></td></tr></table></figure>
<h2 id="其他表达式"><a href="#其他表达式" class="headerlink" title="其他表达式"></a>其他表达式</h2><ol>
<li><p>规则表达式<code>awk &#39;/REG/{action} &#39; file</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> awk -F: '$1~/root/&#123;print $0&#125;' /etc/passwd</span><br><span class="line">root:x:0:0::/root:/bin/bash</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>布尔表达式<code>awk &#39;布尔表达式{action}&#39; file</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> awk -F: '$1=="root"&#123;print $0&#125;' /etc/passwd</span><br><span class="line">root:x:0:0::/root:/bin/bash</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="awk-的-if、循环和数组"><a href="#awk-的-if、循环和数组" class="headerlink" title="awk 的 if、循环和数组"></a>awk 的 if、循环和数组</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.</span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">if</span> ( <span class="variable">$0</span> !~ <span class="regexp">/matchme/</span> ) &#123;</span><br><span class="line">　　　　print <span class="variable">$1</span> <span class="variable">$3</span> <span class="variable">$4</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>.</span><br><span class="line">&#123;</span><br><span class="line">    count=<span class="number">1</span><span class="keyword">do</span> &#123;</span><br><span class="line">        print <span class="string">"I get printed at least once no matter what"</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ( count !=<span class="number">1</span> )</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>.</span><br><span class="line"><span class="keyword">for</span> ( initial assignment; comparison; increment ) &#123;</span><br><span class="line">    code block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.</span><br><span class="line">x=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">　　print <span class="string">"iteration"</span>, x</span><br><span class="line">　　<span class="keyword">if</span> ( x==<span class="number">10</span> ) &#123;</span><br><span class="line">　　　　<span class="keyword">break</span></span><br><span class="line">　　&#125;</span><br><span class="line">　　x++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.</span><br><span class="line">&#123;</span><br><span class="line">    cities[<span class="number">1</span>]=”beijing”</span><br><span class="line">    cities[<span class="number">2</span>]=”shanghai”</span><br><span class="line">    cities[“three”]=”guangzhou”</span><br><span class="line">    <span class="keyword">for</span>( c <span class="keyword">in</span> cities) &#123;</span><br><span class="line">        print cities[c]</span><br><span class="line">    &#125;</span><br><span class="line">    print cities[<span class="number">1</span>]</span><br><span class="line">    print cities[“<span class="number">1</span>”]</span><br><span class="line">    print cities[“three”]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 awk 中查看服务器连接状态并汇总</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> netstat -an|awk '/^tcp/&#123;++s[$NF]&#125;END&#123;for(a in s)print a,s[a]&#125;'</span><br><span class="line"></span><br><span class="line">LISTEN 8</span><br><span class="line">ESTABLISHED 8</span><br><span class="line">SYN_SENT 3</span><br></pre></td></tr></table></figure>
<h2 id="常用字符串函数"><a href="#常用字符串函数" class="headerlink" title="常用字符串函数"></a>常用字符串函数</h2><p><img src="/images/awk_string_func.jpg" alt></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> awk 'BEGIN&#123;info="this is a test2010test!";gsub(/[0-9]+/,"!",info);print info&#125;'</span><br><span class="line">this is a test!test!</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> awk 'BEGIN&#123;info="this is a test2010test!";print index(info,"test")?"ok":"no found";&#125;'</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">awk 'BEGIN&#123;info="this is a test2010test!";print match(info,/[0-9]+/)?"ok":"no found";&#125;'</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">awk 'BEGIN&#123;info="this is a test2010test!";print substr(info,4,10);&#125;'</span><br><span class="line">s is a tes</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> awk 'BEGIN&#123;info="this is a test";split(info,tA," ");print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;'</span><br><span class="line">4</span><br><span class="line">1 this</span><br><span class="line">2 is</span><br><span class="line">3 a</span><br><span class="line">4 test</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/ginvip/p/6352157.html" target="_blank" rel="noopener">https://www.cnblogs.com/ginvip/p/6352157.html</a></p>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
  </entry>
  <entry>
    <title>Find命令使用</title>
    <url>/2020/01/08/Find%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="find命令的使用"><a href="#find命令的使用" class="headerlink" title="find命令的使用"></a>find命令的使用</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find [起始目录] 寻找条件 操作</span><br><span class="line">find PATH OPTION [-exec COMMAND &#123; &#125; \;]</span><br></pre></td></tr></table></figure>
<h2 id="Option-寻找条件"><a href="#Option-寻找条件" class="headerlink" title="Option 寻找条件"></a>Option 寻找条件</h2><p>寻找条件可以是一个用逻辑运算符 not、and、or 组成的复合条件。逻辑运 算符 and、or、not 的含义为：</p>
<ol>
<li><code>and</code>：逻辑与，在命令中用<code>-a</code>表示，是系统缺省的选项，表示只有当所给的条 件都满足时，寻找条件才算满足。例如：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find path –name 'tmp' –xtype c -user 'inin'</span><br></pre></td></tr></table></figure>
<p>该命令寻找三个给定条件都满足的所有文件</p>
<ol>
<li><code>or</code>：逻辑或，在命令中用<code>-o</code>表示。该运算符表示只要所给的条件中有一个满足 时，寻找条件就算满足。例如：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find path –name 'tmp' –o –name 'mina*'</span><br></pre></td></tr></table></figure>
<p>该命令查询文件名为’tmp’或是匹配’mina*’的所有文件。</p>
<ol>
<li><code>not</code>：逻辑非，在命令中用<code>!</code>表示。该运算符表示查找不满足所给条件的文件 。例如：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find ! –name 'tmp'</span><br></pre></td></tr></table></figure>
<p>该命令查询文件名不是’tmp’的所有文件。</p>
<p>Tips:当使用很多的逻辑选项时，可以用括号把这些选项括起来。为了避免Shell本身对括号引起误解，在话号前需要加转义字符“\”来去除括号的意义。例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find \(–name 'tmp' –xtype c -user 'inin' \)</span><br></pre></td></tr></table></figure>
<ol>
<li>具体参数：</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>-name ’字串’</td>
<td>查找文件名匹配所给字串的所有文件，字串内可用通配符 *、?、[ ]。</td>
</tr>
<tr>
<td>-lname ’字串’</td>
<td>查找文件名匹配所给字串的所有符号链接文件，字串内可用通配符 *、?、[ ]。</td>
</tr>
<tr>
<td>-gid n</td>
<td>查找属于ID号为 n 的用户组的所有文件。</td>
</tr>
<tr>
<td>-uid n</td>
<td>查找属于ID号为 n 的用户的所有文件。</td>
</tr>
<tr>
<td>-group ’字串’</td>
<td>查找属于用户组名为所给字串的所有的文件。</td>
</tr>
<tr>
<td>-user ’字串’</td>
<td>查找属于用户名为所给字串的所有的文件。</td>
</tr>
<tr>
<td>-empty</td>
<td>查找大小为 0的目录或文件。</td>
</tr>
<tr>
<td>-path ’字串’</td>
<td>查找路径名匹配所给字串的所有文件，字串内可用通配符*、?、[ ]。</td>
</tr>
<tr>
<td>-perm 权限</td>
<td>查找具有指定权限的文件和目录，权限的表示可以如711，644。</td>
</tr>
<tr>
<td>-size n[bckw]</td>
<td>查找指定文件大小的文件，n 后面的字符表示单位，缺省为 b，代表512字节的块。</td>
</tr>
<tr>
<td>-type x</td>
<td>查找类型为 x 的文件，x 为下列字符之一：b 块设备文件;c 字符设备文件;d 目录文件;p 命名管道(FIFO);f 普通文件;l 符号链接文件(symbolic links);s socket文件</td>
</tr>
<tr>
<td>-amin n</td>
<td>查找n分钟以前被访问过的所有文件。</td>
</tr>
<tr>
<td>-atime n</td>
<td>查找n天以前被访问过的所有文件。</td>
</tr>
<tr>
<td>-cmin n</td>
<td>查找n分钟以前文件状态被修改过的所有文件。</td>
</tr>
<tr>
<td>-ctime n</td>
<td>查找n天以前文件状态被修改过的所有文件。</td>
</tr>
<tr>
<td>-mmin n</td>
<td>查找n分钟以前文件内容被修改过的所有文件。</td>
</tr>
<tr>
<td>-mtime n</td>
<td>查找n天以前文件内容被修改过的所有文件。</td>
</tr>
<tr>
<td>-print：</td>
<td>将搜索结果输出到标准输出。</td>
</tr>
</tbody>
</table>
</div>
<p>例子：在root以及子目录查找不包括目录/root/bin的，greek用户的，文件类型为普通文件的，3天之前的名为test-find.c的文件，并将结构输出，find命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -name "test-find.c" -type f -mtime +3 -user greek -prune /root/bin -print</span><br></pre></td></tr></table></figure>
<p>当然在这其中，-print是一个默认选项，我们不必刻意去配置它。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>-exec：对搜索的结构指令指定的shell命令。注意格式要正确：”-exec 命令 {} \;”</p>
<p>在}和\之间一定要有空格才行;</p>
<p>{}表示命令的参数即为所找到的文件;命令的末尾必须以“ \;”结束。</p>
<p>例子：对上述例子搜索出来的文件进行删除操作，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -name "test-find.c" -type f -mtime +3 -user greek -prune /root/bin -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>find命令指令实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name ‘main*’ -exec more &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>查找当前目录中所有以main开头的文件，并显示这些文件的内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . \(-name a.out - o -name ‘*.o’\) -atime +7 -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>删除当前目录下所有一周之内没有被访问过的a .out或*.o文件。</p>
<p>命令中的“.”表示当前目录，此时 find 将从当前目录开始，逐个在其子目录中查找满足后面指定条件的文件。</p>
<p> “(” 和 “)” 表示括号()，其中的 “\” 称为转义符。之所以这样写是由于对 Shell 而言，(和)另有不同的含义，而不是这里的用于组合条件的用途。</p>
<p>“-name a.out” 是指要查找名为a.out的文件;</p>
<p> “-name ‘*.o’” 是指要查找所有名字以 .o 结尾的文件。</p>
<p>这两个 -name 之间的 -o 表示逻辑或(or)，即查找名字为a.out或名字以 .o结尾的文件。</p>
<p> find命令在当前目录及其子目录下找到这佯的文件之后，再进行判断，看其最后访问时间 是否在7天以前(条件 -atime +7)，若是，则对该文件执行命令 rm(-exec rm {} \;)。</p>
<p>其中 {} 代表当前查到的符合条件的文件名，\;则是语法所要求的。</p>
<p> 上述命令中第一行的最后一个 \ 是续行符。当命令太长而在一行写不下时，可输入一个 \，之后系统将显示一个 &gt;，指示用户继续输入命令。</p>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>链接：<a href="https://www.chinaz.com/server/2009/0807/85796.shtml" target="_blank" rel="noopener">https://www.chinaz.com/server/2009/0807/85796.shtml</a> </p>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习基础</title>
    <url>/2019/12/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="机器学习基础-待完成"><a href="#机器学习基础-待完成" class="headerlink" title="机器学习基础(待完成)"></a>机器学习基础(待完成)</h1><blockquote>
<p>参考 花书 《深度学习》第五章 和 周志华《机器学习》</p>
</blockquote>
<h2 id="学习算法"><a href="#学习算法" class="headerlink" title="学习算法"></a>学习算法</h2><p>机器学习算法是一种能够从数据中学习的算法。</p>
<p>“学习”：对于某类任务T和性能度量P，一个计算机程序被认为可以从经验E中学习，通过经验E改进后，它在任务T上由性能度量P衡量的性能有所提升。</p>
<h3 id="任务T"><a href="#任务T" class="headerlink" title="任务T"></a>任务T</h3><p>机器学习任务定义为机器学习系统应该如何处理<strong>样本</strong>(example)。</p>
<p>样本：我们从某些希望机器学习系统处理的对象或事件中收集到的已经量化的<strong>特征</strong>（feature）的集合。通常样本表示成一个Vector $x\in \mathbb{R}^n$,其中的每个分量$x_i$是一个特征。</p>
<p>常见机器学习任务：</p>
<ul>
<li>分类：计算机程序需要指定某些输入属于k类中的哪一类。</li>
<li>输入缺失分类：当一些输入可能丢失时，学习算法必须学习一组函数，而不是单个分类函数。每个函数对应着分类具有不同缺失输入子集的$X$。这种情况在医疗诊断中经常出现。</li>
<li>回归：计算机程序需要对给定输入预测数值。输出函数$f:\mathbb{R}^n \rightarrow \mathbb{R}$</li>
<li>转录：机器学习系统观测一些相对非结构化表示的数据，并转录信息为离散的文本形式。如光学字符识别。</li>
<li>机器翻译：输入是一种语言的符号序列，计算机程序必须将其转化成另一种语言的符号序列。通常适用于自然语言。</li>
<li>结构化输出：结构化输出任务的输出是向量或者其他包含多个值的数据结构，并且构成输出的这些不同元素间具有重要关系。包括上述转录任务和翻译任务在内的很多其他任务。例如语法分析——映射自然语言句子到语法结构树，标记树的节点的词性。</li>
<li>异常检测：计算机程序在一组事件或对象中筛选，并标记不正常或非典型的个体。例如信用卡欺诈检测。</li>
<li>合成和采样：机器学习程序生成一些和训练数据近似的新样本常用与生成媒体，游戏的自然纹理。某些情况下希望采样或合成过程中可以根据输入生成一些特定类型的输出。如根据书写的句子，输出句子语音的音频波形。这是一类结构化输出任务，没有唯一正确的结构，希望结构更加自然和真实。</li>
<li>缺失值填补：给定一个新样本$x\in \mathbb{R}^n$，$X$中某些元素$x_i$缺失。算法填补这些缺失值。</li>
<li>去噪：干净样本$x\in \mathbb{R}^n$经过未知损坏过程得到的损失样本$\tilde{x} \in \mathbb{R}^n$。算法根据损失后的样本$\tilde{x}$预测干净的样本$x$，或者一般的预测条件概率分布$p(x|\tilde{x})$。</li>
<li>密度估计或概率质量函数估计：在密度估计问题中，学习算法学习函数$p<em>{model}:\mathbb{R}^n \rightarrow \mathbb{R}$，其中$p</em>{model}(x)$可以解释成样本采样空间的概率密度函数（$x$是连续的）或者概率质量函数（$x$是离散的）。</li>
</ul>
<h3 id="性能度量P"><a href="#性能度量P" class="headerlink" title="性能度量P"></a>性能度量P</h3><p>性能度量（performance measure）：衡量模型泛化能力的评估标准</p>
<p>回归任务最常用的性能度量是均方误差(mean squared error)</p>
<script type="math/tex; mode=display">
E(f;D)=\frac{1}{m}\sum_{i=1}^m(f(x_i)-y_i)^2</script><p>更一般的，对于数据分布$D$和概率密度函数$p（\cdot）$，均方误差可以描述为</p>
<script type="math/tex; mode=display">
E(f;D) = \int_{x\sim D}(f(x)-y)^2p(x)dx</script><h4 id="错误率和精度"><a href="#错误率和精度" class="headerlink" title="错误率和精度"></a>错误率和精度</h4><p>分类任务中最常用的两种性能度量。</p>
<ul>
<li><p>错误率：分类错误的样本数占样本总数的比例。</p>
<script type="math/tex; mode=display">
E(f;D)=\frac{1}{m}\sum_{i=1}^m\mathbb{I}(f(x_i)\neq y_i) \\
E(f;D)=\frac{1}{m}\int_{x\sim D}\mathbb{I}(f(x)\neq y)p(x)dx</script></li>
<li><p>精度：分类正确的样本数占样本总数的比例。</p>
<script type="math/tex; mode=display">
acc(f;D)=\frac{1}{m}\sum_{i=1}^m\mathbb{I}(f(x_i) = y_i)=1-E(f;D) \\
acc(f;D)=\frac{1}{m}\int_{x\sim D}\mathbb{I}(f(x) = y)p(x)dx=1-E(f;D)</script></li>
</ul>
<h4 id="查准率、查全率和-F1"><a href="#查准率、查全率和-F1" class="headerlink" title="查准率、查全率和$F1$"></a>查准率、查全率和$F1$</h4><p>对于二分类问题，可将样例根据其真实类别与机器学习预测类别的组合化为真正例(true positive)、假正例(false positive)、真反例(true negative)、假反例(false negative)四种情况，令$TP,FP,TN,FN$分别表示其对应的样例数，则有$TP+FP+TN+FN=$样例总数。分类结果可用”混淆矩阵“(confusion matrix)表示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">预测结果</th>
<th style="text-align:center">预测结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">真实情况</td>
<td style="text-align:center">正例</td>
<td style="text-align:center">反例</td>
</tr>
<tr>
<td style="text-align:center">正例</td>
<td style="text-align:center">$TP$(真正例)</td>
<td style="text-align:center">$FN$ (假反例)</td>
</tr>
<tr>
<td style="text-align:center">反例</td>
<td style="text-align:center">$FP$(假正例)</td>
<td style="text-align:center">$TN$(真反例)</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>查准率$P$</p>
<script type="math/tex; mode=display">
P = \frac{TP}{TP+FP}</script></li>
<li><p>查全率$R$</p>
<script type="math/tex; mode=display">
R = \frac{TP}{TP+FN}</script></li>
<li><p>$P-R$曲线：以查准率为纵轴、查全率为横轴作图。$P-R$图直观地显示出学习器在样本总体上的查全率、查准率。若一个学习器的$P-R$曲线被另一学习器的曲线完全”包住”，则后者的性能优于前者。</p>
</li>
<li><p>”平衡点“(Break-Event Point,BEP)：查准率=查全率 时的取值。BEP高的性能高。</p>
</li>
<li><p>$F1$度量</p>
<script type="math/tex; mode=display">
F1=\frac{2\times P \times R}{P+R}=\frac{2\times TP}{样例总数+TP-TN}</script><blockquote>
<p>$F1$是基于查准率和查全率的调和平均定义的$\frac{1}{F1}=\frac{1}{2}(\frac{1}{P}+\frac{1}{R})$</p>
</blockquote>
</li>
<li><p>更一般的$F_\beta$</p>
<script type="math/tex; mode=display">
F_\beta=\frac{(1+\beta^2 \times P \times R)}{(\beta^2\times P)+R}</script><blockquote>
<p> $F<em>\beta$是基于查准率和查全率的加权调和平均定义的$\frac{1}{F</em>\beta}=\frac{1}{1+\beta^2}(\frac{1}{P}+\frac{\beta^2}{R})$。与算术平均$\frac{P+R}{2}$和几何平均$\sqrt{P\times R}$相比，调和平均更重视较小值。</p>
</blockquote>
<p>​    $\beta \gt 1$查全率影响更大，$\beta \lt 1$查准率影响更大</p>
</li>
</ul>
<h4 id="ROC-和-AUC"><a href="#ROC-和-AUC" class="headerlink" title="$ROC$和$AUC$"></a>$ROC$和$AUC$</h4><ul>
<li>真正例率$(True\;Positive\;Rate,\; TPR)$ == 查全率<script type="math/tex; mode=display">
TPR = \frac{TP}{TP+FN}</script></li>
</ul>
<ul>
<li><p>假正例率$(False\;Positive\;Rate,\; TPR)$ == 反例的查全率</p>
<script type="math/tex; mode=display">
FPR = \frac{FP}{TN+FP}</script></li>
<li><p>$ROC$曲线，$TPR$为$y$轴，$FPR$为$x$轴。$TPR$ 越高，$FPR$ 越小，我们的模型和算法就越高效。几何角度就是$ROC$曲线下的面积越大，模型越优秀，即$AUC(Area\;Under\;Cruve)$</p>
</li>
</ul>
<h3 id="经验E"><a href="#经验E" class="headerlink" title="经验E"></a>经验E</h3><p>数据即经验</p>
<p>根据学习过程中的不同经验，机器学习算法分为无监督和监督算法。</p>
<h2 id="容量、过拟合和欠拟合"><a href="#容量、过拟合和欠拟合" class="headerlink" title="容量、过拟合和欠拟合"></a>容量、过拟合和欠拟合</h2><ul>
<li>泛化：在未观测到的输入上表现良好的能力。</li>
<li>训练误差：训练集上的计算error</li>
<li>决定机器学习算法是否良好的因素<ol>
<li>降低训练误差</li>
<li>缩小训练误差和测试误差的差距</li>
</ol>
</li>
<li>欠拟合$(underfitting)$：模型不能在训练集上获得足够低的误差。</li>
<li>过拟合$(overfitting)$：训练误差和测试误差之间的差距太大。</li>
<li>模型的<strong>容量</strong>$(capacity)$：拟合各种函数的能力。调整容量可以调整模型偏向于过拟合和欠拟合。</li>
<li>容量低的模型可能很难拟合训练集。容量高的模型可能会出现过拟合。</li>
<li>假设空间$(hypothesis\;space)$：即学习算法可以选择为解决方案的函数集。</li>
</ul>
<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><ul>
<li>正则化：修改学习算法，使其降低泛化误差而非训练误差。<ul>
<li>使用<strong>权重衰减</strong>修改线性回归的训练标准，使其偏好于平方$T^2$范数较小的权重。</li>
</ul>
</li>
</ul>
<h2 id="超参集和验证集"><a href="#超参集和验证集" class="headerlink" title="超参集和验证集"></a>超参集和验证集</h2><ul>
<li>超参数：设置控制算法行为，超参数的值不是通过学习算法本身学习出来的。</li>
<li>验证集：用于挑选超参数的数据子集。Normally, eight percent of trained set is used to train, others are used to validate.</li>
</ul>
<h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><ul>
<li>k-折交叉验证：将数据集分成k个不重合的子集。测试误差可以估计为k次计算后的平均测试误差。第i次测试时，数据的第i个子集用于测试集，其他的数据用于训练集。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>vim基本操作</title>
    <url>/2019/12/01/vim%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="vim-基础操作"><a href="#vim-基础操作" class="headerlink" title="vim 基础操作"></a>vim 基础操作</h1><blockquote>
<p>来源于 <code>vimtutor</code></p>
</blockquote>
<h2 id="第一讲小结"><a href="#第一讲小结" class="headerlink" title="第一讲小结"></a>第一讲小结</h2><ol>
<li><p>光标在屏幕文本中的移动既可以用箭头键，也可以使用 <code>hjkl</code> 字母键。</p>
<ul>
<li>h (左移)</li>
<li>j (下行)</li>
<li>k (上行)</li>
<li>l (右移)</li>
</ul>
</li>
<li><p>欲进入 Vim 编辑器(从命令行提示符)，请输入：vim 文件名 &lt;回车&gt;</p>
</li>
<li><p>欲退出 Vim 编辑器，请输入 \<esc>   :q!   &lt;回车&gt; 放弃所有改动。<br>或者输入 \<esc>   :wq   &lt;回车&gt; 保存改动。</esc></esc></p>
</li>
<li><p>在正常模式下删除光标所在位置的字符，请按： x</p>
</li>
<li><p>欲插入或添加文本，请输入：</p>
<ul>
<li>i   输入欲插入文本   \<esc> 在光标前插入文本</esc></li>
<li>A   输入欲添加文本   \<esc>             在一行后添加文本</esc></li>
</ul>
</li>
</ol>
<p>特别提示：按下 \<esc> 键会带您回到正常模式或者撤消一个不想输入或部分完整<br>的命令。</esc></p>
<h2 id="第二讲小结"><a href="#第二讲小结" class="headerlink" title="第二讲小结"></a>第二讲小结</h2><ol>
<li>欲从当前光标删除至下一个单词，请输入：dw</li>
<li>欲从当前光标删除至当前行末尾，请输入：d$</li>
<li>欲删除整行，请输入：dd</li>
<li>欲重复一个动作，请在它前面加上一个数字：2w</li>
<li><p>在正常模式下修改命令的格式是：<br> <code>operator   [number]   motion</code><br>  其中：</p>
<ul>
<li>operator - 操作符，代表要做的事情，比如 d 代表删除</li>
<li>[number] - 可以附加的数字，代表动作重复的次数</li>
<li>motion   - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)， $ 代表行末等等。</li>
</ul>
</li>
<li><p>欲移动光标到行首，请按数字0键：0</p>
</li>
<li>欲撤消以前的操作，请输入：u (小写的u)<br>  欲撤消在一行中所做的改动，请输入：U (大写的U)<br>  欲撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R</li>
</ol>
<h2 id="第三讲小结"><a href="#第三讲小结" class="headerlink" title="第三讲小结"></a>第三讲小结</h2><ol>
<li><p>要重新置入已经删除的文本内容，请按小写字母 p 键。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置于当前光标所在行的下一行。</p>
</li>
<li><p>要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字符即可。</p>
</li>
<li><p>更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。</p>
<p> 比如输入 ce 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当前光标到行末的内容。</p>
</li>
<li><p>更改类命令的格式是：<code>c   [number]   motion</code></p>
</li>
</ol>
<h2 id="第四讲小结"><a href="#第四讲小结" class="headerlink" title="第四讲小结"></a>第四讲小结</h2><ol>
<li><p>CTRL-G 用于显示当前光标所在位置和文件状态信息。<br>  G 用于将光标跳转至文件最后一行。<br>  先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。<br>  gg 用于将光标跳转至文件第一行。</p>
</li>
<li><p>输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。<br>  输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。<br>  完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查<br>  找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。<br>  CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。</p>
</li>
<li><p>如果光标当前位置是括号(、)、[、]、{、}，按 % 会将光标移动到配对的括号上。</p>
</li>
<li><p>在一行内替换头一个字符串 old 为新的字符串 new，请输入  <code>:s/old/new</code><br> 在一行内替换所有的字符串 old 为新的字符串 new，请输入<code>:s/old/new/g</code><br> 在两行内替换所有的字符串 old 为新的字符串 new，请输入  <code>:#,#s/old/new/g</code><br> 在文件内替换所有的字符串 old 为新的字符串 new，请输入  <code>:%s/old/new/g</code><br> 进行全文替换时询问用户确认每个替换需添加 c 标志<code>:%s/old/new/gc</code></p>
</li>
</ol>
<h2 id="第五讲小结"><a href="#第五讲小结" class="headerlink" title="第五讲小结"></a>第五讲小结</h2><ol>
<li><p>:!command 用于执行一个外部命令 command。</p>
<p>  请看一些实际例子：<br> | (ms-dos)       | (unix)        |                                |<br> | ——————— | ——————- | ——————————————— |<br> | :!dir          | :!ls          | 用于显示当前目录的内容。       |<br> | :!del filename | :!rm filename | 用于删除名为 filename 的文件。 |</p>
</li>
<li><p><code>:w filename</code>  可将当前 vim 中正在编辑的文件保存到名为 filename 的文件中。</p>
</li>
<li><p><code>v motion :w filename</code> 可将当前编辑文件中可视模式下选中的内容保存到文件filename 中。</p>
</li>
<li><p><code>:r filename</code> 可提取磁盘文件 filename 并将其插入到当前文件的光标位置后面。</p>
</li>
<li><p><code>:r !dir</code> 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。</p>
</li>
</ol>
<h2 id="第六讲小结"><a href="#第六讲小结" class="headerlink" title="第六讲小结"></a>第六讲小结</h2><ol>
<li><p>输入小写的 o 可以在光标下方打开新的一行并进入插入模式。输入大写的 o 可以在光标上方打开新的一行。</p>
</li>
<li><p>输入小写的 a 可以在光标所在位置之后插入文本。输入大写的 a 可以在光标所在行的行末之后插入文本。</p>
</li>
<li><p>e 命令可以使光标移动到单词末尾。</p>
</li>
<li><p>操作符 y 复制文本，p 粘贴先前复制的文本。</p>
</li>
<li><p>输入大写的 r 将进入替换模式，直至按 \<esc> 键回到正常模式。</esc></p>
</li>
<li><p>输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下：<br> |                   |                        |<br> | ————————- | ——————————— |<br> | ‘ic’ ‘ignorecase’ | 查找时忽略字母大小写   |<br> | ‘is’ ‘incsearch’  | 查找短语时显示部分匹配 |<br> | ‘hls’ ‘hlsearch’  | 高亮显示所有的匹配短语 |</p>
<p> 选项名可以用完整版本，也可以用缩略版本。</p>
</li>
<li><p>在选项前加上 no 可以关闭选项：  <code>:set noic</code></p>
</li>
</ol>
<h2 id="第七讲小结"><a href="#第七讲小结" class="headerlink" title="第七讲小结"></a>第七讲小结</h2><ol>
<li><p>输入 <code>:help</code> 或者按 <code>&lt;f1&gt;</code> 键或 <code>&lt;help&gt;</code> 键可以打开帮助窗口。</p>
</li>
<li><p>输入入 <code>:help cmd</code> 可以找到关于 cmd 命令的帮助。</p>
</li>
<li><p>输入 <code>ctrl-w ctrl-w</code>  可以使您在窗口之间跳转。</p>
</li>
<li><p>输入 <code>:q</code> 以关闭帮助窗口</p>
</li>
<li><p>您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。</p>
</li>
<li><p>当输入 <code>:</code> 命令时，按 <code>ctrl-d</code> 可以查看可能的补全结果。按 <code>&lt;tab&gt;</code> 可以使用一个补全。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>面向对象设计原则</title>
    <url>/2019/11/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="面向对象的七种设计原则"><a href="#面向对象的七种设计原则" class="headerlink" title="面向对象的七种设计原则"></a>面向对象的七种设计原则</h1><hr>
<h2 id="原则一：（SRP：Single-responsibility-principle）单一职责原则又称单一功能原则"><a href="#原则一：（SRP：Single-responsibility-principle）单一职责原则又称单一功能原则" class="headerlink" title="原则一：（SRP：Single responsibility principle）单一职责原则又称单一功能原则"></a>原则一：（SRP：Single responsibility principle）单一职责原则又称单一功能原则</h2><p><strong>核心</strong>：解耦和增强内聚性（高内聚，低耦合）</p>
<p><strong>描述</strong>：类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题。</p>
<h2 id="原则二：开闭原则（OCP：Open-Closed-Principle）"><a href="#原则二：开闭原则（OCP：Open-Closed-Principle）" class="headerlink" title="原则二：开闭原则（OCP：Open Closed Principle）"></a>原则二：开闭原则（OCP：Open Closed Principle）</h2><p><strong>核心思想</strong>：对扩展开放，对修改关闭。即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。</p>
<p><strong>扩展开放</strong>：某模块的功能是可扩展的，则该模块是扩展开放的。软件系统的功能上的可扩展性要求模块是扩展开放的。</p>
<p><strong>修改关闭</strong>：某模块被其他模块调用，如果该模块的源代码不允许修改，则该模块修改关闭的。软件系统的功能上的稳定性，持续性要求是修改关的。</p>
<h2 id="原则三：里氏替换原则（LSP：Liskov-Substitution-Principle）"><a href="#原则三：里氏替换原则（LSP：Liskov-Substitution-Principle）" class="headerlink" title="原则三：里氏替换原则（LSP：Liskov Substitution Principle）"></a>原则三：里氏替换原则（LSP：Liskov Substitution Principle）</h2><p><strong>核心</strong>：</p>
<ol>
<li><p>在任何父类出现的地方都可以用他的子类来替代（子类应当可以替换父类并出现在父类能够出现的任何地方）子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。</p>
</li>
<li><p>子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性</p>
</li>
<li><p>覆盖或实现父类的方法时输入参数可以被放大。即子类可以重载父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。</p>
</li>
<li><p>覆盖或实现父类的方法时输出结果可以被缩小。</p>
</li>
</ol>
<h2 id="原则四：依赖倒转原则-DIP：Dependence-Inversion-Principle"><a href="#原则四：依赖倒转原则-DIP：Dependence-Inversion-Principle" class="headerlink" title="原则四：依赖倒转原则(DIP：Dependence Inversion Principle)"></a>原则四：依赖倒转原则(DIP：Dependence Inversion Principle)</h2><p><strong>别名</strong>：依赖倒置原则或依赖反转原则</p>
<p><strong>核心</strong>：要依赖于抽象，不要依赖于具体的实现</p>
<ol>
<li><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）</p>
</li>
<li><p>抽象不应该依赖细节（具体实现）</p>
</li>
<li><p>细节（具体实现）应该依赖抽象。</p>
</li>
</ol>
<p><strong>三种实现方式</strong>:</p>
<ol>
<li><p>通过构造函数传递依赖对象</p>
</li>
<li><p>通过setter方法传递依赖对象</p>
</li>
<li><p>接口声明实现依赖对象</p>
</li>
</ol>
<h2 id="原则五：接口分离原则-ISP：Interface-Segregation-Principle"><a href="#原则五：接口分离原则-ISP：Interface-Segregation-Principle" class="headerlink" title="原则五：接口分离原则(ISP：Interface Segregation Principle)"></a>原则五：接口分离原则(ISP：Interface Segregation Principle)</h2><p><strong>核心思想</strong>：不应该强迫客户程序依赖他们不需要使用的方法。</p>
<p><strong>接口分离原则的意思就是</strong>：一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口当中.</p>
<p><strong>分离接口的两种实现方法</strong>：</p>
<ol>
<li><p>使用委托分离接口。（Separation through Delegation）</p>
</li>
<li><p>使用多重继承分离接口。（Separation through Multiple Inheritance）</p>
</li>
</ol>
<h2 id="原则六：合成复用原则（CRP：Composite-Reuse-Principle）"><a href="#原则六：合成复用原则（CRP：Composite-Reuse-Principle）" class="headerlink" title="原则六：合成复用原则（CRP：Composite Reuse Principle）"></a>原则六：合成复用原则（CRP：Composite Reuse Principle）</h2><p><strong>核心思想</strong>：尽量使用对象组合，而不是继承来达到复用的目的。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。</p>
<p><strong>复用的种类</strong>：</p>
<ol>
<li><p>继承</p>
</li>
<li><p>合成聚合</p>
</li>
</ol>
<p><em>注：在复用时应优先考虑使用合成聚合而不是继承</em></p>
<h2 id="原则七：迪米特原则（LOD：Law-of-Demeter）"><a href="#原则七：迪米特原则（LOD：Law-of-Demeter）" class="headerlink" title="原则七：迪米特原则（LOD：Law of Demeter）"></a>原则七：迪米特原则（LOD：Law of Demeter）</h2><p>又叫最少知识原则</p>
<p><strong>核心思想</strong>：一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。（类间解耦，低耦合）意思就是降低各个对象之间的耦合，提高系统的可维护性；在模块之间只通过接口来通信，而不理会模块的内部工作原理，可以使各个模块的耦合成都降到最低，促进软件的复用</p>
<p><em>注</em>：</p>
<ol>
<li><p>在类的划分上，应该创建有弱耦合的类；</p>
</li>
<li><p>在类的结构设计上，每一个类都应当尽量降低成员的访问权限；</p>
</li>
<li><p>在类的设计上，只要有可能，一个类应当设计成不变；</p>
</li>
<li><p>在对其他类的引用上，一个对象对其它对象的引用应当降到最低；</p>
</li>
<li><p>尽量降低类的访问权限；</p>
</li>
<li><p>谨慎使用序列化功能；</p>
</li>
<li><p>不要暴露类成员，而应该提供相应的访问器(属性)</p>
</li>
</ol>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
  </entry>
  <entry>
    <title>Keras初体验</title>
    <url>/2019/11/29/Keras%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="Keras-初体验"><a href="#Keras-初体验" class="headerlink" title="Keras 初体验"></a>Keras 初体验</h1><h2 id="使用内置struct加载mnist手写字符数据集"><a href="#使用内置struct加载mnist手写字符数据集" class="headerlink" title="使用内置struct加载mnist手写字符数据集"></a>使用内置<code>struct</code>加载<code>mnist</code>手写字符数据集</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load mnist dataset</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadImageSet</span><span class="params">(filename)</span>:</span></span><br><span class="line">    imgfile = open(filename, <span class="string">'rb'</span>)</span><br><span class="line">    buffers = imgfile.read()</span><br><span class="line"></span><br><span class="line">    head = struct.unpack_from(<span class="string">'&gt;IIII'</span>, buffers, <span class="number">0</span>)<span class="comment"># 读取前四个int，解析返回列表</span></span><br><span class="line">    offset = struct.calcsize(<span class="string">'&gt;IIII'</span>) <span class="comment"># 计算前四个int大小</span></span><br><span class="line"></span><br><span class="line">    imgNum = head[<span class="number">1</span>]</span><br><span class="line">    width = head[<span class="number">2</span>]</span><br><span class="line">    height = head[<span class="number">3</span>]</span><br><span class="line">    bits = imgNum*width*height</span><br><span class="line">    bitstr = <span class="string">'&gt;'</span>+str(bits)+<span class="string">'B'</span></span><br><span class="line">    print(bitstr)</span><br><span class="line">    data = struct.unpack_from(bitstr, buffers, offset)</span><br><span class="line">    data = np.reshape(data, (imgNum, width*height))</span><br><span class="line">    imgfile.close()</span><br><span class="line">    <span class="keyword">return</span> data, head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadLabel</span><span class="params">(filename)</span>:</span></span><br><span class="line">    imgfile = open(filename, <span class="string">'rb'</span>)</span><br><span class="line">    buffers = imgfile.read()</span><br><span class="line"></span><br><span class="line">    head = struct.unpack_from(<span class="string">'&gt;II'</span>, buffers, <span class="number">0</span>)</span><br><span class="line">    offset = struct.calcsize(<span class="string">'&gt;II'</span>)</span><br><span class="line"></span><br><span class="line">    imgNum = head[<span class="number">1</span>]</span><br><span class="line">    bits = imgNum</span><br><span class="line">    bitstr = <span class="string">'&gt;'</span>+str(bits)+<span class="string">'B'</span></span><br><span class="line">    print(bitstr)</span><br><span class="line">    data = struct.unpack_from(bitstr, buffers, offset)</span><br><span class="line">    data = np.reshape(data, (imgNum, <span class="number">1</span>))</span><br><span class="line">    imgfile.close()</span><br><span class="line">    <span class="keyword">return</span> data, head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_data, train_head = loadImageSet(<span class="string">'./mnist/train-images.idx3-ubyte'</span>)</span><br><span class="line">label_data, label_head = loadLabel(<span class="string">'./mnist/train-labels-idx1-ubyte'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Train\n"</span>)</span><br><span class="line">print(<span class="string">f'Head information:<span class="subst">&#123;train_head&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'Shape:<span class="subst">&#123;train_data.shape&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Label\n"</span>)</span><br><span class="line">print(<span class="string">f'Head information:<span class="subst">&#123;label_head&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'Shape:<span class="subst">&#123;label_data.shape&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="构建模型并训练"><a href="#构建模型并训练" class="headerlink" title="构建模型并训练"></a>构建模型并训练</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_hot</span><span class="params">(data,n)</span>:</span></span><br><span class="line">    num = data.shape[<span class="number">0</span>]</span><br><span class="line">    res = np.zeros((num,n))</span><br><span class="line">    <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(data):</span><br><span class="line">        res[i,v]= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">label_data = one_hot(label_data,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line"></span><br><span class="line">model.add(Dense(input_dim=<span class="number">28</span>*<span class="number">28</span>, units=<span class="number">500</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">500</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">              optimizer=<span class="string">'adam'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line">model.fit(train_data, label_y, batch_size=<span class="number">100</span>, epochs=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h2 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_data = loadImageSet(<span class="string">'./mnist/t10k-images-idx3-ubyte'</span>)[<span class="number">0</span>]</span><br><span class="line">test_label = one_hot(loadLabel(<span class="string">'./mnist/t10k-labels-idx1-ubyte'</span>)[<span class="number">0</span>],<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">score = model.evaluate(test_data,test_label)</span><br><span class="line">print(<span class="string">'Total loss on Testing Set:'</span>,score[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">'Accuracy of  Testing Set:'</span>,score[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>常见数据结构</title>
    <url>/2019/11/28/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="常见的数据结构和算法"><a href="#常见的数据结构和算法" class="headerlink" title="常见的数据结构和算法"></a>常见的数据结构和算法</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><strong>线性表</strong>$Linear List$是由$n(n \geq 0)$个具有相同类型的数据元素$a_1,a_2,\dots,a_n$组成的有限序列。其中元素的个数$n$定义为表的长度。</p>
<p>非空线性表的逻辑特征：</p>
<ul>
<li>有且仅有一个开始结点$a_1$，该结点没有前趋，仅有一个后继$a_2$。</li>
<li>有且仅有一个终点结点$a<em>n$，该结点没有后继，仅有一个前趋$a</em>{n-1}$</li>
<li>其余内部内部结点$a<em>i \; (2 \leq i \leq n-1)\;$都有且仅有一个前趋$a</em>{i-1}$和一个后继$a_{i+1}$。</li>
</ul>
<p>线性表中的数据元素不限定形式，但同一线性表中的数据元素必须具有相同特性，相邻元素之间存在着序偶。</p>
<h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><p>线性表的两种存储表示方法：</p>
<ul>
<li>顺序存储表示</li>
<li>链式存储表示</li>
</ul>
<p>顺序表：线性表的顺序存储指的是把线性表的数据元素按逻辑顺序依次存放一组地址连续的存储单元里。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LISTINCREMENT = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqList_d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    SqList_d(<span class="keyword">int</span> n);</span><br><span class="line">    ~SqList_d();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SqListInsert</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">SqListDelete</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAllData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SqList_d::SqList_d(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    elem = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    maxSize = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqList_d::~SqList_d()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] elem;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    maxSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SqList_d::SqListInsert(<span class="keyword">int</span> i, <span class="keyword">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= maxSize)</span><br><span class="line">    &#123;</span><br><span class="line">        elem = (<span class="keyword">int</span> *)<span class="built_in">realloc</span>(elem, (maxSize + LISTINCREMENT) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入位置异常"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = length; j &gt;= i; j--)</span><br><span class="line">        elem[j] = elem[j - <span class="number">1</span>];</span><br><span class="line">    elem[i - <span class="number">1</span>] = e;</span><br><span class="line">    length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SqList_d::SqListDelete(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"溢出"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"删除位置异常"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e = elem[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        elem[j - <span class="number">1</span>] = elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    length--;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SqList_d::printAllData()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Item: "</span> &lt;&lt; i &lt;&lt; <span class="string">" value: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;elem[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    SqList_d la = SqList_d(<span class="number">10</span>);</span><br><span class="line">    la.SqListInsert(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    la.printAllData();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设顺序吧每个数据元素占有$m$个存储单元，且数据元素的存储位置定义为其所占的存储空间中第一个单元的存储地址，则表中相邻的数据元素$a<em>i$和$a</em>{i+1}$的存储位置$LOC(a<em>i)$和$LOC(a</em>{i+1})$也是相邻的，且满足如下关系：</p>
<script type="math/tex; mode=display">LOC(a_{i+1}) = LOC(a_i) + m</script><p>如果知道第一个元素$a_i$的存储位置则：</p>
<script type="math/tex; mode=display">LOC(a_{i}) = LOC(a_1) + (i-1)*m</script><p>由于计算任意数据元素存储地址的时间都是相等的，因此顺序表是一种 <strong>随机存取</strong>$(Random\;Access)$结构</p>
<p>顺序表的优点：</p>
<ul>
<li>节省存储空间</li>
<li>随机存取(直接存取)</li>
</ul>
<p>顺序表的缺点：</p>
<ul>
<li>插入和删除需要移动大量元素</li>
<li>表容量</li>
</ul>
<h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h3><p>链式存储结构：用一组地址任意的存储单元来依次存放线性表中的数据元素。</p>
<p>链式存储结构中的每个数据节点需要保存以下两部分信息：</p>
<ul>
<li>存储数据元素自身信息的部分。称为数据域；</li>
<li>存储与前驱和后继结点的逻辑关系。称为指针域。</li>
</ul>
<ol>
<li><p>单链表</p>
<p>单链表：如果结点只包含一个指针域。则称为单链表$Single\;Linked\;List$。</p>
<p>结构为：$\boxed{data|next}$</p>
<p>$data$为数据域，用来存放数据元素自身的信息；$next$为指针域也成链域，用来存放后继结点的地址。</p>
<p>表中的第一个结点$a_1$无前驱，故设置一个头指针$(Head\;Pointer)head$指向$a_1$,此外最后一个结点无后继，故$a_n$的指针域为空。</p>
<script type="math/tex; mode=display">head\;\to\;\boxed{a_1|\quad}\;\to\;\boxed{a_2|\quad}\;\to\;\boxed{a_3|\quad}\;\to\dots\;\to\;\boxed{a_n|\land}</script><p>链式映像或非顺序映像：逻辑上相邻的两个数据元素其存储的物理位置不一定相邻。</p>
<p>单链表是 <strong>非随机存取</strong> 的存储结构。(顺序存取)</p>
<p>单链表基本操作的实现：</p>
<ul>
<li>创建链表<ul>
<li>头插入法</li>
<li>尾插入法</li>
</ul>
</li>
<li>查找操作<ul>
<li>按位序查找</li>
<li>按值查找</li>
</ul>
</li>
<li>插入操作</li>
<li>删除操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Node *Head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        LinkList();</span><br><span class="line">        ~LinkList();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">CreateList1</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">CreateList2</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ListInsert</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> LinkList::CreateList1(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//头插法创建线性表：不停的从头部插入</span></span><br><span class="line">    Node *p,*s;</span><br><span class="line">    p = Head;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请依次输入"</span> &lt;&lt; n &lt;&lt; <span class="string">"个数据元素值："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = <span class="keyword">new</span> Node;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s-&gt;data;</span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态链表</p>
<p>静态链表：指用一维数组表示的单链表。</p>
</li>
<li><p>循环链表</p>
<p>循环链表：一种头尾相连的链表</p>
</li>
<li><p>双向链表</p>
<p>双向链表的结点结构：</p>
<script type="math/tex; mode=display">\boxed{piror|data|next}</script></li>
</ol>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><blockquote>
<p>栈和队列属于特殊的线性表 ，它们在逻辑结构上和线性表相似。栈和队列在操作比一般线性表多一些限制，栈只能在表的一端进行操作，而队列只能在一端进行插入，一端进行删除。</p>
</blockquote>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>栈</strong>：$Stack$，是限定仅在表尾进行插入或删除操作的线性表。</p>
<ul>
<li>栈顶：允许插入和删除的一端。</li>
<li>栈底：另一端。</li>
<li>空栈：当栈中没有任何元素。</li>
<li>进栈(入栈)：将一个元素从栈顶插入到栈的操作。</li>
<li>出栈(弹出):从栈顶删除一个元素的操作。</li>
</ul>
<p>特点：<strong>先进先出</strong>$FIFO$和<strong>后进先出</strong>$LIFO$</p>
<p>栈的抽象数据类型:</p>
<ul>
<li>数据对象：$D={a_i | a_i \in  ElemSet,i=1,2,\cdots,n,n \ge 0}$</li>
<li>数据关系：$R={<a_{i-1},a_i>,a<em>i&gt;|a</em>{i-1},a_i \in D,i=1,2,\cdots,n}$</a_{i-1},a_i></li>
</ul>
<p>约定$a_n$端为栈顶，$a_1$端为栈底。</p>
<ul>
<li>基本操作：<ul>
<li>$InitStack(\&amp;S)$</li>
<li>$DestroyStack(\&amp;S)$</li>
<li>$CleanStack(\&amp;S)$</li>
<li>$StackEmpty(S)$</li>
<li>$StackLength(S)$</li>
<li>$GetTop(S,\&amp;e)$</li>
<li>$Push(\&amp;S,e)$</li>
<li>$PopStack(\&amp;S,\&amp;e)$</li>
<li>$StackTraverse(S,visit())$</li>
</ul>
</li>
</ul>
<h4 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h4><p>顺序栈：采用顺序存储结构的栈。</p>
<p>顺序栈：利用一组地址连续的存储单元一次存放自栈底到栈顶的数据元素，同时附设$top$指针指示栈顶元素在顺序栈的位置。通常$top=0$表示空栈。</p>
<p>顺序栈的类定义和基本操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *base; <span class="comment">//栈底指针</span></span><br><span class="line">    <span class="keyword">int</span> top;   <span class="comment">//栈顶</span></span><br><span class="line">    <span class="keyword">int</span> stackSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    SqStack(<span class="keyword">int</span> m);</span><br><span class="line">    ~SqStack()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] base;</span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">        stackSize = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StackTranverse</span><span class="params">()</span></span>; <span class="comment">//显示栈中元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SqStack::Push(<span class="keyword">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == stackSize - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈满，无法入栈"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    top++;</span><br><span class="line">    base[top] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SqStack::Pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">if</span> (top = <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈空，无法出栈"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = base[top--];</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SqStack::GetTop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SqStack::StackTranverse()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"空栈"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"index: "</span> &lt;&lt; i &lt;&lt; <span class="string">" value: "</span> &lt;&lt; base[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序栈的应用：</p>
<ul>
<li>数制转换</li>
<li>括号匹配的检验</li>
<li>行编辑程序问题</li>
<li>迷宫求解</li>
</ul>
<h4 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h4><p>链栈的结点结构和单链表的结点结构相同。链表只能在栈顶执行插入和删除操作，因此以单链表的头部作为栈顶最方便，而且也没必要为单链表附加头结点链表的头指针即为栈顶指针。</p>
<p>链栈的类定义和基本操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Node *top;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    LinkStack() &#123; top == <span class="literal">NULL</span>; &#125;;</span><br><span class="line">    ~LinkStack();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> top != <span class="literal">NULL</span> ? <span class="number">1</span> : <span class="number">0</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LinkStack::~LinkStack()</span><br><span class="line">&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">while</span> (top)</span><br><span class="line">    &#123;</span><br><span class="line">        p = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> top;</span><br><span class="line">        top = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LinkStack::Push(<span class="keyword">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    Node *s = <span class="keyword">new</span> Node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = top;</span><br><span class="line">    top = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> LinkStack::Pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈溢出"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = top-&gt;data;</span><br><span class="line">    Node *p = top;</span><br><span class="line">    top = top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是线性表的特例。它将元素排列成队，有入口和出口，数据元素只能从队尾入队，从队头离队。队列具有<strong>先进先出 FIFO</strong>或<strong>后进后出LILO</strong></p>
<p><strong>队列</strong>：$Queue$是另一种限定存取位置的线性表。只允许在表的一端进入，在另一端删除，其中允许插入的一端称为<strong>队尾（Rear）</strong>，允许删除的一端称为<strong>队头（Front）</strong></p>
<ul>
<li>入队：从队尾插入元素</li>
<li>出队：从队头删除元素</li>
</ul>
<p>队列的抽象数据类型：</p>
<ul>
<li>数据对象：$D={a_i | a_i \in ElemSet,i=1,2,\cdots,n,n \ge 0}$</li>
<li>数据关系：$R={<a_{i-1},a_i> | a_{i_1},a_i \in D,i=2,\cdots,n}$</a_{i-1},a_i></li>
</ul>
<p>确定 $a_1$端为队头，$a_n$端为队尾。</p>
<ul>
<li>基本操作：<ul>
<li>$InitQueue(\&amp;Q)$</li>
<li>$DestroyQueue(\&amp;Q)$</li>
<li>$CleanQueue(\&amp;Q)$</li>
<li>$QueueEmpty(Q)$</li>
<li>$QueueLength(Q)$</li>
<li>$GetHead(Q,\&amp;e)$</li>
<li>$EnQueue(\&amp;Q,e)$</li>
<li>$DeQueue(\&amp;Q,\&amp;e)$</li>
<li>$QueueTraverse(Q,visit())$</li>
</ul>
</li>
</ul>
<h4 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h4><p>顺序队列：队列的顺序存储结构。</p>
<p>用一组地址连续的存储单元依次存放从队头到队尾的元素，由于队列的队头和队尾的位置是变化的，因而还需要两个指针front和rear作为队头指针和队尾指针来分别指示队头和队尾在队列中的位置。</p>
<p>当rear大于等于容量时，新元素无法入队，但事实上队列的低端还有空闲的存储单元，这种现象称为“假溢”。</p>
<p>为了解决这种现象引入了循环队列。</p>
<p>解决“假溢”现象的方法：将存储队列的数组看成是头尾相接的圆环，并成为循环存储空间，即允许队列直接从数组中下标最大的位置延续到下标最小的位置。</p>
<p>循环队列$(Circular\;Queue)$：队列的头尾相接的顺序存储结构</p>
<p>这种队列，队空和队满时头尾指针均相等，故无法通过$front==rear$来判断队列“空”还是“满”。</p>
<p>解决这个问题的办法：</p>
<ul>
<li>设置一个布尔变量以区别队列的空和满</li>
<li>少用一个元素空间：约定入队前，测试尾指针在循环意义下加1后是否等于头指针，若相等则认为队满，但实际还有一个空位置</li>
<li>使用一个计数器记录队列中元素的总数，即队列长度。</li>
</ul>
<p>以方法2讨论：</p>
<p>循环队列的长度$(rear-front+QueunSize) \% QueueSize$</p>
<p>循环队列的类定义和基本操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *base; <span class="comment">//存储空间基址</span></span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">int</span> queueSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    CQueue(<span class="keyword">int</span> m);</span><br><span class="line">    ~CQueue();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetHead</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">QueueDisplay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CQueue::CQueue(<span class="keyword">int</span> m)</span><br><span class="line">&#123;</span><br><span class="line">    queueSize = m;</span><br><span class="line">    base = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(queueSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    front = <span class="number">0</span>;</span><br><span class="line">    rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CQueue::~CQueue()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] base;</span><br><span class="line">    front = <span class="number">0</span>;</span><br><span class="line">    rear = <span class="number">0</span>;</span><br><span class="line">    queueSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CQueue::EnQueue(<span class="keyword">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((rear + <span class="number">1</span>) % (queueSize) == front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"上溢，无法入队"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    base[rear] = e;</span><br><span class="line">    rear = (rear + <span class="number">1</span>) % queueSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CQueue::DeQueue()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"下溢，不能出队"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = base[front];</span><br><span class="line">    front = (front + <span class="number">1</span>) % queueSize;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CQueue::GetHead()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"队空，无元素"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = base[front];</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CQueue::GetLast()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"队空，无元素"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = base[rear];</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CQueue::QueueDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"队空，无元素"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = front % queueSize; i &lt; rear; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; queueSize) &#123;</span><br><span class="line">            index = i % queueSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"index: "</span> &lt;&lt; index &lt;&lt; <span class="string">" value: "</span> &lt;&lt; base[index] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; (rear) % queueSize; i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; "index: " &lt;&lt; i &lt;&lt; " value: " &lt;&lt; base[i] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CQueue cq = CQueue(<span class="number">6</span>);</span><br><span class="line">    cq.EnQueue(<span class="number">1</span>);</span><br><span class="line">    cq.EnQueue(<span class="number">2</span>);</span><br><span class="line">    cq.EnQueue(<span class="number">3</span>);</span><br><span class="line">    cq.EnQueue(<span class="number">4</span>);</span><br><span class="line">    cq.EnQueue(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"入队后："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    cq.QueueDisplay();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"第一个元素出队后："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    cq.DeQueue();</span><br><span class="line">    cq.QueueDisplay();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h4><p>队列的链式存储结构称为<strong>链队列$(Linked\;Queue)$</strong></p>
<p>根据队列先进先出的特性，链队列是仅在表头删除元素和表尾插入元素的单链表。</p>
<p>链队列的类定义和基本操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Node *front;</span><br><span class="line">    Node *rear;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    LinkQueue();</span><br><span class="line">    ~LinkQueue();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetHead</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">QueueDisplay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LinkQueue::LinkQueue()</span><br><span class="line">&#123;</span><br><span class="line">    front = <span class="keyword">new</span> Node;</span><br><span class="line">    front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    rear = front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkQueue::~LinkQueue()</span><br><span class="line">&#123;</span><br><span class="line">    Node *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (front != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LinkQueue::EnQueue(<span class="keyword">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">"进入队列！！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Node *s = <span class="keyword">new</span> Node;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = rear-&gt;next;</span><br><span class="line">    rear-&gt;next = s;</span><br><span class="line">    rear = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (front-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        front-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> LinkQueue::DeQueue()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    Node *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rear == front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"下溢"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = front-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rear = front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> LinkQueue::GetHead()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"下溢"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = front-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"当前队列为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> LinkQueue::GetLast()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"下溢"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = rear-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LinkQueue::QueueDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"队列为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((p != rear));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkQueue lq = LinkQueue();</span><br><span class="line">    lq.EnQueue(<span class="number">1</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">2</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">3</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">4</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">5</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">7</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> e = lq.DeQueue();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    e = lq.DeQueue();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    e = lq.GetHead();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    e = lq.GetLast();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    lq.QueueDisplay();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组和广义表"><a href="#数组和广义表" class="headerlink" title="数组和广义表"></a>数组和广义表</h2><p>数组和广义表可以看做是线性表的扩展，即数组和广义表中的数据元素本身也是一种数据结构。数组中每个数据元素具有相同的结构，广义表中的数据元素可以有不同的数据结构。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组$(Array)$是由相同类型的一组数据元素组成的一个有限序列。其数据元素也称为数组元素。数组中的每个元素都有一个序号，称为<strong>下标$(index)$</strong>。可以通过下标访问数据元素。</p>
<p>数组元素受$n(n\ge1)$个线性关系的约束，每个数据元素在$n$<br>个线性关系中的符号$i_1,i_2,\cdots,i_n$成为数据元素的下标，并称该数组为$n$维数组。</p>
<p>当$n=2$是，为二维数组，任何一个数据元素有两个下标，一个为行号，一个为列号。如$a_{ij}$表示第$i$行第$j$列的数据元素</p>
<p>一维数组可以看作是一个线性表，二维数组可以看作数据元素是一维数组的线性表。</p>
<p>数组中的每个数据元素都和一组唯一的下标值对应。因此数组是一种随机存取机构。</p>
<p>数据的抽象数据类型</p>
<ul>
<li><p>数据对象：$j_i=0,\cdots,b_i-1,i=1,2,\cdots,n$</p>
<script type="math/tex; mode=display">D=\{a_{j_1j_2\cdots j_n}|n(n>0),b_i,j_i,a_{j_1j_2\cdots j_n}\in ElemSet\}</script><p>$n$是数据的维数，$b_i$是数据的第$i$维的长度，$j_i$是数组元素第$i$维的下标。</p>
</li>
<li><p>数据关系：$R={R_1,R_2,\cdots,R_n}$</p>
</li>
</ul>
<script type="math/tex; mode=display">R_i=\{<a_{j1\cdots ji \cdots jn},a_{j1\cdots ji+1\cdots jn}>\}
    \\ 0\le j_k\le b_k-1,1\le k\le n\;n\neq i,
    \\ 0\le j_i \le b_i-2,
    - InitArray(\&A,n,bound1,...,boundn)
    \\a_{j1\cdots ji \cdots jn},a_{j1\cdots ji+1\cdots jn}\in D,i=2,\cdots,n</script><ul>
<li>基本操作<ul>
<li>$InitArray(\&amp;A,n,bound1,…,boundn)$<ul>
<li>初始条件：无</li>
<li>操作结果：若维数$n$和各维长度$b_1,…,b_n$合法，则构造相应的数组$A$，并返回$OK$</li>
</ul>
</li>
<li>$DestroyArray(\&amp;A)$<ul>
<li>初始条件：无</li>
<li>操作结果：销毁数组$A$</li>
</ul>
</li>
<li>$GetValue(A,\&amp;e,index1,…,indexn)$<ul>
<li>初始条件：$A$是$n$维数组，$e$为数据元素变量，$index1,\cdots,indexn$是$n$个下标值。</li>
<li>操作结果：若下标$index1,\cdots,indexn$都不超界，则读取与下标对应的数据元素的值，并赋值给$e$</li>
</ul>
</li>
<li>$Assign(\&amp;A,e,index1,…,indexn)$<ul>
<li>初始条件：$A$是$n$维数组，$e$为数据元素变量，$index1,\cdots,indexn$是$n$个下标值。</li>
<li>操作结果：若下标$index1,\cdots,indexn$都不超界，则将$e$赋值给下标对应的数据元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数组的存储结构"><a href="#数组的存储结构" class="headerlink" title="数组的存储结构"></a>数组的存储结构</h4><p>由于计算机内存结构是一维的，因此用一维内存来表示多维数组，必须按某种次序将数据元素排成一个序列，然后将这个序列放在存储空间中。</p>
<p>由于一般不对数组进行插入和删除操作，一般采用顺序存储的方法来表示数组。</p>
<p>用一组连续的存储单元存放数据元素存在一个次序约定的问题，是先存一行数据元素还是先存一列数据元素？</p>
<p>根据<strong>存储方式</strong>的不同，顺序存储方法分为一下两类：</p>
<ul>
<li><p>行优先顺序存储</p>
<p>以行序为主序的存储方式。将数据元素按行排列，第$i+1$个行向量紧接在第$i$个行向量后面。</p>
</li>
<li><p>列优先顺序存储</p>
<p>以列序为主序的存储方式。将数据元素按列排列，第$j+1$个列向量紧接在第$j$个列向量后面。</p>
</li>
</ul>
<p>行优先顺序存储：$\boxed{a<em>{11}|a</em>{12}|\cdots|a<em>{1n}|a</em>{21}|a<em>{22}|\cdots|a</em>{2n}|\cdots|a<em>{m1}|a</em>{m2}|\cdots|a<em>{mn}}$<br>列优先顺序存储：$\boxed{a</em>{11}|a<em>{21}|\cdots|a</em>{m1}|a<em>{12}|a</em>{22}|\cdots|a<em>{m2}|\cdots|a</em>{1n}|a<em>{2n}|\cdots|a</em>{mn}}$</p>
<p>二维数组元素地址，按行优先顺序存储的计算公式</p>
<p>任一数据元素$a<em>{ij}$的存储地址$LOC(a</em>{ij})$应为数组的基地址加上排在$a<em>{ij}$前面的数据元素所占用的单元数，因此$a</em>{ij}$的存储地址计算公式为：</p>
<script type="math/tex; mode=display">LOC(a_{ij})=LOC(a_{l_1l_2})+((i-l_1)*(h_2-l_2+1)+(j-l_2))*c\\=LOC(a_{l_1l_2})+i*(h_2-l_2+1)*c-l_1*(h_2-l_2+1)*c+j*c-l_2*c</script><p>令：$M_1=(h_2-l_2+1)*c,M_2=c,$则有</p>
<script type="math/tex; mode=display">LOC(a_{ij})=v_0+i*M_1+j*M_2</script><p>其中，$v<em>0=LOC(a</em>{l<em>1l_2})+-l_1<em>M_1-l_2</em>M_2,i\in[l_1,h_1],j\in[l_2,h_2],$且$i$和$j$均为整数；$LOC(a_l{ij})$是数据元素$a</em>{ij}$的存储地址，$LOC(a_{l_1l_2})$是二维数组中第一个元素的存储地址，即基地址。</p>
<p>二维数组推广到一般，按照行优先顺序存储，则下标为$i_1,i_2,\cdots,i_n$的存储地址为：</p>
<script type="math/tex; mode=display">LOC(a_{i_1,i_2,\cdots,i_n})
=LOC(a_{l_1,l_2,\cdots,l_n})+(j_1d_2d_3\cdots d_n+j_2d_3\cdots d_n+\cdots+j_{n-1}d_n+j_n)*c\\=V_0+i_1*M_1+i_2*M_2+\cdots+i_n*M_n</script><h4 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h4><p>在矩阵中，若非零元素呈现某种规律分布或举证中出现大量零数据元素。为了节省空间，可以对这类矩阵进行压缩。</p>
<p>压缩存储的原则：</p>
<ul>
<li>为多个值相同的非零数据元素分配一个存储空间</li>
<li>不为零数据元素分配存储空间</li>
</ul>
<p>特殊矩阵$(Special\;Matrix)$：值相同的数据元素或者零数据元素在矩阵中的分布有一定的规律。</p>
<p>稀疏矩阵$(Sparse\;Maxtrix)$：矩阵中有许多零数据元素(一般根据稀疏因子的值判定领数据元素是否较多)</p>
<ol>
<li><p>特殊矩阵的压缩存储<br>特殊矩阵是指非零数据元素或零<strong>数据元素的分布</strong>具有一定<strong>规律</strong>的矩阵。</p>
<p>常见的特殊矩阵有:对称矩阵、对角矩阵等，它们都是方阵，行数和列数相同。</p>
<ol>
<li><p>对称对称的压缩<br>在一个$n$阶方阵$A$中，若数据元素满足下述性质:</p>
<script type="math/tex; mode=display">a_{ij}=a_{ji}(i\ge1,j\le n)</script><p>则称为$A$为$n$阶对称矩阵。</p>
<p>对称矩阵只需存储矩阵中的上三角$a<em>{ij}(i\le j)$或下三角$a</em>{ij}(i\ge j)$的数据元素。</p>
<p>对称矩阵优先采用行优先顺序存储下三角中的数据元素。</p>
<p>下三角的数据元素可用一个容量是$n<em>(n+1)/2$的一维数组存储。对于下三角中任意数据元素$a<em>{ij}(i\ge j)$,$a</em>{ij}$在一维数组中的下标$k$与$i、j$的关系为：$k=i</em>(i+1)/2+j$。</p>
<script type="math/tex; mode=display">\boxed{a_{00}|a_{10}|a_{11}|a_{20}|a_{21}|a_{22}|\cdots|a_{ij}|\cdots|a_{n-1,0}|a_{n-1,1}|\cdots|a_{n-1,n-1}}</script><p>若采用上述的压缩存储方式，则矩阵中的任一数据元素$a_{ij}$与它在一维数组中的存储位置$k$之间存在如下的对应关系:</p>
<script type="math/tex; mode=display">k=\begin{cases}i(i-1)/2+j-1,\ge j
\\j(j-1)/2+i-1,\lt j\end{cases}</script><p>其中$k=0,1,2，\cdots,((n+1)n/2)-1,<br>\1+2+3+(i-1)=(i-1)i/2,<br>\(i-1)i/2+j=k+1\quad i\ge j\quad and\quad i,j\ge 1$</p>
</li>
<li><p>对角矩阵的压缩存储</p>
<p>对角矩阵：所有的非零数据元素都集中在以主对角线为中心的带状区域中的举证，即除了<strong>主对角线上和主对角线相邻两侧</strong>的若干条对角线上的数据之外，其余所有数据元素均为零数据元素。</p>
</li>
</ol>
</li>
<li><p>稀疏矩阵的压缩存储</p>
<p><strong>稀疏矩阵$(Sparse\;Matrix)$</strong>:矩阵$A$中有$s$个非零数据元素，若$s$远远小于矩阵数据元素的总数即$(s\ll m*n)$。</p>
<p>稀疏因子：假设$m\ast n$阶矩阵中有$s$个非零元素，令$t=s/(m\ast n)$，称$t$为稀疏因子。</p>
<p>通常认为$s\ll0.05$时，称为稀疏矩阵。</p>
<p>存储方法：</p>
<pre><code>-  三元组顺序表
-  十字链表表示法(需要了解，笔记没有写)
</code></pre><ol>
<li><p>稀疏矩阵的三元组顺序表</p>
<ul>
<li>不存储零数据元素，只存储稀疏矩阵的非零数据元素。</li>
<li>除了存储非零数据的元素的数据值，还需要同时存储它所在的行和列的位置$(i,j)$。</li>
<li>一个三元组$(i,j,a_{ij})$唯一确定了矩阵$A$的一个非零数据元素。</li>
<li>若把稀疏矩阵的三元组线性表按顺序存储结构存储，则称为<strong>稀疏矩阵的三元组顺序表</strong></li>
</ul>
</li>
<li><p>稀疏矩阵的类定义和基本操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Triple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    ElemType e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMatrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mu; <span class="comment">//行数</span></span><br><span class="line">    <span class="keyword">int</span> nu; <span class="comment">//列数</span></span><br><span class="line">    <span class="keyword">int</span> tu; <span class="comment">//非零数据的个数</span></span><br><span class="line">    Triple *data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    SMatrix();</span><br><span class="line">    SMatrix(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, Triple data[]);</span><br><span class="line">    ~SMatrix();</span><br><span class="line">    <span class="function">SMatrix <span class="title">MCreate</span><span class="params">(<span class="keyword">int</span> d[][<span class="number">3</span>], <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MDisplay</span><span class="params">(SMatrix a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MatrixTrans_1</span><span class="params">(SMatrix A, SMatrix &amp;B)</span></span>; <span class="comment">//矩阵转置算法1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MatrixTrans</span><span class="params">(SMatrix A, SMatrix &amp;B)</span></span>;   <span class="comment">//快速转置算法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SMatrix::SMatrix()</span><br><span class="line">&#123;</span><br><span class="line">    mu = <span class="number">0</span>;</span><br><span class="line">    nu = <span class="number">0</span>;</span><br><span class="line">    tu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; tu; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[p].i = <span class="number">0</span>;</span><br><span class="line">        data[p].j = <span class="number">0</span>;</span><br><span class="line">        data[p].e = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SMatrix::SMatrix(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, Triple data[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mu = m;</span><br><span class="line">    <span class="keyword">this</span>-&gt;nu = n;</span><br><span class="line">    <span class="keyword">this</span>-&gt;tu = k;</span><br><span class="line">    <span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SMatrix SMatrix::MCreate(<span class="keyword">int</span> d[][<span class="number">3</span>], <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    SMatrix M = &#123;m, n, k, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="number">0</span>)</span><br><span class="line">        M.data = <span class="keyword">new</span> Triple[k];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        M.data[i].i = d[i][<span class="number">0</span>];</span><br><span class="line">        M.data[i].j = d[i][<span class="number">1</span>];</span><br><span class="line">        M.data[i].e = d[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//矩阵遍历</span></span><br><span class="line"><span class="keyword">void</span> SMatrix::MDisplay(SMatrix a)</span><br><span class="line">&#123;</span><br><span class="line">    Triple p;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, c = <span class="number">0</span>;</span><br><span class="line">    p = a.data[k];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; a.mu; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; a.nu; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; a.tu &amp;&amp; p.i == i &amp;&amp; p.j == j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; p.e;</span><br><span class="line">                k++;</span><br><span class="line">                <span class="keyword">if</span> (k &lt; a.tu)</span><br><span class="line">                    p = a.data[k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于三元组顺序表的转置算法</span></span><br><span class="line"><span class="keyword">void</span> SMatrix::MatrixTrans_1(SMatrix A, SMatrix &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    B.mu = A.nu;</span><br><span class="line">    B.nu = A.tu;</span><br><span class="line">    B.tu = A.tu;</span><br><span class="line">    <span class="keyword">int</span> q, p;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">if</span> (B.tu)</span><br><span class="line">    &#123;</span><br><span class="line">        q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt; A.nu; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt;= A.tu - <span class="number">1</span>; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (A.data[p].j == col)</span><br><span class="line">                &#123;</span><br><span class="line">                    B.data[q].i = A.data[p].j;</span><br><span class="line">                    B.data[q].j = A.data[p].i;</span><br><span class="line">                    B.data[q].e = A.data[p].e;</span><br><span class="line">                    q++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速转置算法</span></span><br><span class="line"><span class="keyword">void</span> SMatrix::MatrixTrans(SMatrix A, SMatrix &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> col, k, p, q;</span><br><span class="line">    <span class="keyword">int</span> *num, *cpot;</span><br><span class="line">    num = <span class="keyword">new</span> <span class="keyword">int</span>[B.nu];</span><br><span class="line">    cpot = <span class="keyword">new</span> <span class="keyword">int</span>[B.nu];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (B.tu)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">0</span>; col &lt; A.tu; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[col] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; A.tu; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[A.data[k].j]++;</span><br><span class="line">        &#125;</span><br><span class="line">        cpot[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt;= A.nu; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            cpot[col] = cpot[col - <span class="number">1</span>] + num[col - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; A.tu; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            col = A.data[p].j;</span><br><span class="line">            q = cpot[col];</span><br><span class="line">            B.data[q].i = A.data[p].j;</span><br><span class="line">            B.data[q].j = A.data[p].i;</span><br><span class="line">            B.data[q].e = A.data[p].e;</span><br><span class="line">            cpot[col]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矩阵的运算一般有<strong>矩阵转置、矩阵相加、矩阵相减、矩阵相乘</strong>等。</p>
<ul>
<li><p>矩阵转置</p>
<p>$def：$一个$m\ast n$的矩阵$A$，它的转置矩阵$B$是一个$n\ast m$的矩阵，且<br>$a[i][j]==b[j][i],1\le i\le m,1\le j\le m$，即$A$的行是$B$的列，$A$的列是$B$的行。</p>
<ol>
<li><p>基于三元组顺序表的转置算法</p>
<ul>
<li><p>基本思想：对矩阵$A$的三元组从头到尾多次扫描</p>
<ol>
<li>第一次扫描时，将$A$中列号为1的三元组行列交换并赋值到矩阵$B$的三元组中；</li>
<li>第二次扫描时，将$A$中列号为2的三元组行列交换并赋值到矩阵$B$的三元组中；</li>
<li>依次类推直到$A$中所有的三元组都赋值到矩阵$B$的三元组中。</li>
</ol>
</li>
<li><p>评价:基于三元组顺序表的矩阵算法更加复杂，虽然节省了存储空间，但可能增大算法的时间复杂度，故基于三元组顺序表的转置算法仅适用<br>$tu \ll m\ast n$情况。</p>
</li>
</ul>
</li>
<li><p>快速转置算法</p>
<ul>
<li><p>快速转置算法的核心思想：对矩阵$A$扫描一次，按矩阵$A$提供的列号一次确定装入矩阵$B$的一个三元组$d$的位置。</p>
<ol>
<li>一遍扫描先确定三元组的位置关系(具体是根据矩阵$A$中非零数据元素的分布确定每列第一个非零数据元素在矩阵$B$中的位置)</li>
<li>二次扫描由位置关系装入三元组。</li>
</ol>
</li>
<li><p>位置关系是快速转置算法的关键<br>为求得矩阵$A$各列第一个非零数据元素的三元组的所在位置，引入两个辅助运算功能的一个数组$num[],cpot[]$</p>
<ul>
<li><p>$num[col]$:存放矩阵$A$中第$col$列的非零数据元素的个数。</p>
</li>
<li><p>$cpot[col]$:存放矩阵$A$中第$col$列第一个非零数据元素的三元组在$B$的位置。</p>
</li>
<li><p>位置计算公式</p>
<script type="math/tex; mode=display">\begin{cases}cpot[1]=1\\
cpot[col]=cpot[col-1]+num[col-1];2\le col\leq n\end{cases}</script></li>
</ul>
</li>
<li><p>步骤：</p>
<ol>
<li>求矩阵$A$中各列非零数据元素的个数$num[]$</li>
<li>求矩阵$A$中各列第一个非零数据元素在转置矩阵$B$中的下标$cpot[col]$</li>
<li>对矩阵$A$进行一次扫描，遇到第$col$列的第一个非零三元组时，按照$cpot[col]$的位置，将其放至矩阵$B$中，当再次遇到第$col$列的非零元三元组时，只需顺序放到第$col$列数据元素的后面。</li>
</ol>
</li>
<li><p>评价：相对于基于三元组顺序表的转置算法，多占用了两个数组的存储空间，同时算法本身比较复杂，但时间复杂度较低，为$O(nu+tu)$。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>矩阵相乘<br>由于两个稀疏矩阵相乘不一定是稀疏矩阵，所以矩阵的乘积采用二维数组表示。设矩阵$A$为$m$行$p$列，矩阵$B$为$p$行$n$列，则计算矩阵乘积$C$($C$为$m$行$n$列)的一般传统方式，依据下述公式计算：</p>
<script type="math/tex; mode=display">C[i][j]=\sum^{p-1}_{k=1}A[i][k]\ast B[k][j]</script><p>一般传统的矩阵相乘的算法代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        c[i][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;p;k++)</span><br><span class="line">            c[i][j]+=a[i][k]*b[k][j];</span><br></pre></td></tr></table></figure>
<p>算法的时间复杂度为$O(m<em>n</em>p)$</p>
<p>如果采用三元组顺序存储表示，则不能采用上述传统矩阵相乘算法。</p>
<p>思路：先求得各个$c[i][j]$的部分积，最后分别累加，只需对$B$每一行扫描一次。</p>
<p>采用上述思路，需要一些辅助数组：</p>
<ol>
<li>一个累加器$ctemp[]$存储当前行中$c[i][j]$的部分积，待当前行中所有数据元素全部算完后，再将非零数据元素的结果存放到$C.data$中。</li>
<li>为了便于在$B$的三元组表中找到各行的第一个非零数据元素，与快速矩阵转置算法类似，引入$num[row]$和$cpot[row]$两个一维数组。其中$num[row]$指示$row$行的非零元个数，$cpot[row]$指示第$row$行第一个非零数据元素的位置。$cpot[row]$的计算公式如下：</li>
</ol>
<script type="math/tex; mode=display">\begin{cases}cpot[0]]=1\\
            cpot[row]=cpot[row-1]+num[row-1];\end{cases}</script><p>采用三元组顺序表表示的稀疏矩阵的乘法步骤如下：</p>
<ol>
<li>如果矩阵$A$的列数和矩阵$B$的行数不同，则不满足计算条件，算法退出。</li>
<li>如果矩阵$A$的列数与矩阵$B$的行数相同，则申请矩阵$C$的存储空间，令矩阵$C$的行数等于矩阵$A$的行数，矩阵$C$的列数等于矩阵$B$的列数。</li>
<li>如果矩阵$A$或矩阵$B$中的非零数据元素个数为0，则矩阵$C$为全零矩阵，计算结束，算法退出。</li>
<li>如果矩阵$A$和矩阵$B$的非零数据元素个数均不为0，求$B$的$num[row]$和$cpot[row]$。</li>
<li>按矩阵$A$的行号从小到大的顺序，执行一下操作。<ol>
<li>对每行非零数据元素执行一下操作：<ul>
<li>累加器$ctemp[nu]$清零；</li>
<li>数据元素$a[i][k]$与$b[k][j]$相乘，累加到$ctemp[j]$中。</li>
</ul>
</li>
<li>如果$ctemp[j]$非零，则得到一个$c[i][j]$即在$C$中新添加一个三元组，$C$的非零数据元素个数增1。</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><p><strong>广义表</strong>$(Generalized\;Lists)$是$n(n\ge 0)$个数据元素的有限序列，一般记作:</p>
<script type="math/tex; mode=display">LS=(a_1,a_2,\cdots,a_n)</script><p>其中,$LS$是广义表的名称，$a_i(i\le i\le n)$是$LS$的直接数据元素，也称成员，它可以是单个数据元素，也可以是一个广义表，它们分别称为$LS$的单数据元素(原子)或子表。</p>
<p>当广义表$LS$非空时：</p>
<ul>
<li>表头$(Head)$：第一个数据元素</li>
<li>表尾$(Tail)$：除去表头后其余数据元素组成的广义表</li>
<li>长度：直接数据元素的个数</li>
<li>深度：括号中最大嵌套层数</li>
</ul>
<p>广义表$()$和广义表$(())$是不同的，前者为空表，长度为0，后者长度为1。</p>
<p>广义表的性质：</p>
<ul>
<li>广义线性：不考虑其数据元素的内部结构，则它是一个线性表，它的直接数据元素之间是线性关系</li>
<li>数据元素复合性：数据元素分为单数据元素和子表，数据类型不统一。</li>
<li>数据元素递归性：广义表是递归的。即广义表可以是自身的子表。</li>
<li>数据元素共享性：广义表以及广义表的数据元素可以被其他广义表共享。</li>
</ul>
<p>广义表的抽象数据类型：</p>
<ul>
<li>数据对象：$D={e_i|i=1,2,\cdots,n;n\ge 0;e_i\in AtomSet\;or\;e_i\in GList}$$AtomSet$为某个数据对象</li>
<li>数据关系：$R={<e_{i-1},e_i>|e_{i-1},e_i\in D,2\le i\le n}$</e_{i-1},e_i></li>
<li>基本操作：<ul>
<li>$InitGList(\&amp;L)$</li>
<li>$CreateGList(\&amp;L,S)$</li>
<li>$CopyGList(\&amp;T,L)$</li>
<li>$GListLength(L)$</li>
<li>$GListDepth(L)$</li>
<li>$GListEmpty(L)$</li>
<li>$GetHead(L)$</li>
<li>$GetTail(L)$</li>
<li>$InsertFirst_GL(\&amp;L,e)$</li>
<li>$DeleteFirst_GL(\&amp;L,e)$</li>
<li>$Traverse_GL(L,visit())$</li>
</ul>
</li>
</ul>
<h4 id="广义表的存储结构"><a href="#广义表的存储结构" class="headerlink" title="广义表的存储结构"></a>广义表的存储结构</h4><p>由于数据元素<strong>类型的不统一</strong>，难以采用顺序存储结构，而采用链式存储结构存储广义表。</p>
<p>若广义表不空，则可分解为<strong>表头和表尾</strong>；反之，一对确定的表头和表尾可唯一确定一个广义表。</p>
<p>根据上述性质可采用<strong>头尾表示法</strong>$(Head\;Tail\;Express)$来存储广义表。</p>
<p>广义表的数据元素可以是单数据元素也可以是广义表，相应的在头尾表示法中链表的结点结构也有两种：</p>
<ul>
<li>表结点，用于存储广义表</li>
<li>数据元素结点，用于存储但数据元素</li>
</ul>
<p>为了区别这两类结点，在结点设置一个标识域，标志为1，则为表结点；标志为0，则该结点为数据元素结点。</p>
<script type="math/tex; mode=display">\boxed{tag=1|hp|tp}\quad\quad\boxed{tag=0|data}</script><ul>
<li>tag:区分表结点和数据元素结点的标志</li>
<li>hp:指向表头结点的指针</li>
<li>tp:指向表尾结点的指针</li>
<li>data:存储数据元素自身的信息</li>
</ul>
<p><code>LS=((),(a),(a,(b,c,d)))</code>的头尾链表存储结构。(自己完成)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">atom</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        GLNode *hp, *tp;</span><br><span class="line">    &#125; ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    GLNode *ls; <span class="comment">//指向表头的指针</span></span><br><span class="line">    <span class="keyword">char</span> result[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> count;                      <span class="comment">//计数</span></span><br><span class="line">    <span class="function">GLNode *<span class="title">CreateGList</span><span class="params">(<span class="built_in">string</span> st)</span></span>; <span class="comment">//由广义表的书面格式s创建广义表</span></span><br><span class="line">    <span class="function">GLNode *<span class="title">CopyGList</span><span class="params">(GLNode *ts, GLNode *ls)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(GLNode *ls)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(GLNode *ls)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    GList();</span><br><span class="line">    GList(<span class="built_in">string</span> s);</span><br><span class="line">    ~GList();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DepthGList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GListCopy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Server</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="built_in">string</span> &amp;hstr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GListDisplay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GList::GList()</span><br><span class="line">&#123;</span><br><span class="line">    ls = <span class="literal">NULL</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GList::~GList()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] ls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树和二叉树-重点"><a href="#树和二叉树-重点" class="headerlink" title="树和二叉树(重点)"></a>树和二叉树(重点)</h2><p>树是一种非线性结构。树是一种<strong>层次结构</strong>。</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树$(Tree)$:是$n(n\ge0)$个结点的有限集。</p>
<p>树的递归定义如下：</p>
<p>当$n=0$时，$T$称为空树；当$n&gt;0$时，$T$是非空树。在一棵非空树中：</p>
<ol>
<li><p>有且仅有一个特定的结点，它只有后继结点，没有前驱结点，这个结点称为根$(Root)$</p>
</li>
<li><p>当$n\gt1$时，除了根以外的其余结点分为$m(m\gt0)$个互不相交的有限集合$T_1,T_2，\cdots,T_m$其中每一个集合本身又是一棵树，并且称为根的<strong>子树</strong>$(SubTree)$。T的定义记作：</p>
<script type="math/tex; mode=display">T=\begin{cases}\varPhi,n=0\\
\{root,T_1,T_2,\cdots,T_m\},n\gt0\end{cases}</script><p>其中，$root$表示$T$的根，$T_1,T_2,\cdots,T_m$表示$T$的$m$棵子树。</p>
</li>
</ol>
<blockquote>
<p>树中结点数目 = 每种结点的度 * 每种结点个数 + 1 </p>
</blockquote>
<h4 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h4><ul>
<li>结点$(Node)$:树中的每个元素对应一个结点</li>
<li>结点的度$(Degree)$:是结点所拥有的子树的个数</li>
<li>树的度$(Degree)$:树中所有结点的度的最大值</li>
<li>叶子结点$(Deaf)$:即度为0的结点，又称为终端结点，叶子结点简称叶子</li>
<li>分支结点$(Branch)$:即度不为0的结点，又称非终端结点，分支结点简称为分支</li>
<li>孩子结点$(Child)$:若结点$X$有子树，则子树的根结点即为结点$X$的孩子结点，孩子结点简称孩子</li>
<li>双亲结点$(Parent)$:若结点$X$有孩子，则$X$即为孩子的双亲结点，双亲结点简称双亲</li>
<li>兄弟结点$(Sibling)$:同一双亲的孩子结点间互称为兄弟结点，兄弟结点简称兄弟</li>
<li>堂兄弟结点$(Cousin)$:结点在树中的层次相同，但双亲不同的结点称为堂兄弟结点，堂兄弟结点简称堂兄弟</li>
<li>结点的层次:根结点的层次为1，根结点的孩子的层次为2，根结点的孩子的孩子的层次为3.依次类推</li>
<li>祖先结点$(Ancestor)$:从根结点到结点$X$所经过分支上的所有结点，都称为$X$的祖先结点，祖先结点简称为祖先</li>
<li>子孙结点$(Descendant)$:结点$X$的孩子，以及这些孩子的孩子都是$X$的子孙结点，子孙结点简称子孙</li>
<li>树的深度$(Depth)$:树中距离根最远的结点所处的层次即为树的深度。空树的深度为0，有一个根结点的树的深度为1.</li>
<li>树的高度$(Height)$:叶子结点的高度为1，非叶子结点的高度等于它的孩子结点的高度的最大值加1,这样定义树的高度等于根结点的高度。高度的深度的计算的方向不同，但数值相等</li>
<li>路径$(Path)$:从树的双亲结点移动到其孩子结点和其他子孙结点所经过的路线；路径上经过的边的个数成为路径长度。</li>
<li>有序树$(Ordered\;Tree)$:树中个结点的各棵子树从左到右都是有次序的树</li>
<li>无序树$(Unordered\;Tree)$:树中各个结点的各棵子树不存在确定的次序关系</li>
<li>森林$(Forest)$:$m(m\ge0)$棵互不相交的树的集合称之为森林</li>
</ul>
<h4 id="树的性质和存储"><a href="#树的性质和存储" class="headerlink" title="树的性质和存储"></a>树的性质和存储</h4><ol>
<li><p>树的性质</p>
<ul>
<li>树中的结点个数等于树中所有结点的度数之和再加1<br>假设树中的结点个数为</li>
<li>度为$m$的树中第$i$层上至多有$m^{i-1}$个结点$(i\ge1)$</li>
</ul>
</li>
<li><p>树的存储结构</p>
<ol>
<li><p>树的顺序存储结构</p>
<p>双亲表示法：$(Parent\;Express)$，一维数组来存储树的每个结点的信息，数组中的一个数据元素表示树中的一个结点，数据元素为结构体类型，其中包括结点本身的信息以及其双亲结点在数组中的位置信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> parent</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PNode</span> <span class="title">Tree</span>[<span class="title">MaxSize</span>];</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>树的链式存储结构</p>
<ul>
<li><p>孩子表示法</p>
<ul>
<li>多重链表表示法：每个结点包括一个信息域和多个指针域，每个指针域指向该结点的一个孩子。<ul>
<li>每个结点的指针域的个数等于树的度数</li>
<li>每个结点的指针域的个数等于该结点的度数</li>
</ul>
</li>
<li>孩子链表示法：存储单元的主体是一个与结点个数大小一样的一维数组，数组的每个元素由两个域组成，一个域用来存放结点的自身信息，另一个域用来存放指针，该指针指向由该结点孩子组成的单链表的表头。</li>
</ul>
</li>
<li><p>双亲孩子表示法：将双亲表示法和孩子表示法相结合的存储方法。将各结点的孩子组成单链表，同时用一维数组顺序存储树的各结点，一维数组中的数组元素除了本身的信息和该结点的孩子结点链表的头指针之外，还有一个域指向双亲结点。</p>
</li>
<li><p>孩子兄弟表示法：又称二叉链表表示法或二叉树表示法。以二叉链表作为树的存储结构，链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，分别命名为$firstchild$和$nextsibling$域。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    TNode *firstchild,*nextsibling;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>树的遍历<br>遍历：$(Traverse)$是树的基本操作。</p>
<p>树的遍历：指从根结点出发，按照某种次序访问树中所有结点，使得每个结点被访问一次且仅被访问一次。</p>
<ul>
<li>先根遍历(先序遍历)</li>
<li>后根遍历(后序遍历)</li>
<li>层次遍历(一层一层的访问)</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h4><ol>
<li>森林的存储结构<ol>
<li>森林的顺序存储结构</li>
<li>森林的链式存储结构<ul>
<li>双亲孩子表示法</li>
<li>孩子兄弟表示法</li>
</ul>
</li>
</ol>
</li>
<li>森林的遍历<ul>
<li>先序遍历森林<br>若森林非空<ol>
<li>访问森林第一棵树的根节点</li>
<li>先序遍历第一棵树中根结点的子树森林</li>
<li>先序遍历除去第一棵树之后剩余的树构成的森林</li>
</ol>
</li>
<li>中序遍历森林<br>若森林非空<ol>
<li>中序遍历第一个棵树的根结点和子树森林</li>
<li>访问第一个棵树的根结点</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="二叉树-重点"><a href="#二叉树-重点" class="headerlink" title="二叉树(重点)"></a>二叉树(重点)</h4><ol>
<li><p>定义</p>
<p>二叉树：$(Binary\;Tree)$:一种树形结构，每个结点至多有两棵子树，分别称为左子树和右子树。</p>
<p>二叉树的递归定义如下：</p>
<script type="math/tex; mode=display">T=\begin{cases}\phi,n=0\\\{root,T_L,T_r\},n\gt0\end{cases}</script></li>
<li><p>性质</p>
<ul>
<li>在二叉树的第$i(i\ge1)$层上至多有$2^{i-1}$个结点。</li>
<li>深度为$k(k\ge1)$的二叉树至多有$2^{k}-1$个结点</li>
<li>对任何一棵非空二叉树，如果其叶子结点数为$n_0$,度为2的结点数为$n_2$则$n_0=n_2+1$.<ul>
<li>满二叉树：$(Full\;Binary\;Tree)<br>$深度为$k$且有$2^{k}-1$个结点的二叉树。除最底层结点度为0，其余都为2。</li>
<li>完全二叉树：$(Complete\;Binary\;Tree)$<br>如果一棵深度为$k$且具有$n$个结点的二叉树，它的每一个结点都与深度为$k$的满二叉树中顺序编号为$1\sim n$的结点一一对应。</li>
</ul>
</li>
<li>具有$n(n\gt0)$个结点的完全二叉树的深度为$\left\lfloor log_2n\right\rfloor+1$</li>
<li>如果将一棵$n$个结点的完全二叉树按照自顶向下，同一层自左向右的顺序连续给结点编号$1,2,3,\cdots,n$。<br>按照此结点编号将树中各结点顺序地存放于一个一维数组，并简称编号为$i$的结点为结点$1\le i\le n)$<ol>
<li>若$i=1$，则结点$i$为根，无双亲结点；若$i\gt1$,则结点的双亲结点为结点$\left\lfloor\frac{i}{2}\right\rfloor$</li>
<li>若$2i\le n$，则结点$i$的左孩子为结点$2i$，否则$i$无左孩子</li>
<li>若$2i+1\le n$，则结点$i$的右孩子为结点$2i+1$，否则结点$i$无右孩子</li>
</ol>
</li>
</ul>
</li>
<li><p>二叉树的存储结构</p>
<ul>
<li><p>二叉树的顺序存储结构</p>
<ol>
<li>完全二叉树的顺序存储表示</li>
<li>一般二叉树的顺序表示：对不存在的结点仍然编号。</li>
</ol>
</li>
<li><p>二叉树的链式存储结构</p>
<p>顺序存储方式用于完全二叉树的存储非常有效，但用于一般二叉树，存储空间浪费。</p>
<p>根据二叉树的定义，每个结点可以有两个分支：<br>二叉树的结点至少三个域，分别存放数据信息$data$、左孩子结点指针$lchild$和右孩子结点指针$rchild$，这种结构称为二叉链表$(Binary)\;Linked\;List$。<br>为了便于查找，可以增加一个指向双亲结点的指针域。这样的结构称为三叉链表$(Trifurcate\;Linked\;List)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    BiTNode *lchild, *rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    BiTNode *bt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">RCreate</span><span class="params">(BiTNode *p, <span class="keyword">int</span> k, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">PreTraverse</span><span class="params">(BiTNode *p)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InTraverse</span><span class="params">(BiTNode *p)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">PostTraverse</span><span class="params">(BiTNode *p)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    BinaryTree();</span><br><span class="line">    ~BinaryTree();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(<span class="keyword">int</span> end)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BiTNode *<span class="title">GetRoot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BiTreeDisplay</span><span class="params">(BiTNode *bt, <span class="keyword">int</span> level = <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BinaryTree::BinaryTree()</span><br><span class="line">&#123;</span><br><span class="line">    bt = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinaryTree::~BinaryTree()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] bt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>平衡二叉树：每个结点的左右子树的高度之差的绝对值不超过1.</p>
</blockquote>
</li>
<li><p>二叉树的遍历</p>
<ol>
<li><p>二叉树遍历的概念</p>
<ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层次遍历</li>
</ul>
</li>
<li><p>二叉树遍历的递归算法和非递归算法</p>
<ol>
<li><p>递归算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> BinaryTree::PreTraverse(BiTNode *p)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        PreTraverse(p-&gt;lchild);</span><br><span class="line">        PreTraverse(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BinaryTree::InTraverse(BiTNode *p)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InTraverse(p-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        InTraverse(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BinaryTree::PostTraverse(BiTNode *p)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PostTraverse(p-&gt;lchild);</span><br><span class="line">        PostTraverse(p-&gt;rchild);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>非递归算法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> BinaryTree::PreOrderTraverse()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"先序非递归遍历二叉树："</span>;</span><br><span class="line">    BiTNode *p = bt;</span><br><span class="line">    <span class="function">SqStack <span class="title">s</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (p || !s.StackEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            s.Push(p-&gt;data);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.Pop();</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>二叉树遍历的应用</p>
<ul>
<li>利用后序递归遍历计算结点个数</li>
<li>利用后序递归遍历计算树的高度</li>
<li>利用后序递归遍历销毁二叉树</li>
<li>利用先序递归遍历复制二叉树</li>
<li>利用先序递归遍历判断两棵二叉树是否相等</li>
<li>利用先序递归遍历构造二叉树</li>
<li>利用先序遍历输出显示二叉树</li>
</ul>
</li>
</ol>
</li>
<li><p>线索二叉树</p>
<p>一个具有$n$个结点的二叉树若采用二叉链表存储结构，在$2n$个指针域中只有$n-1$个指针域用来存储孩子结点的地址，另外的$n+1$个指针域为空，利用这些空指针域存放指向该结点的某种遍历序列中的前驱和后继结点的位置信息。</p>
<p>其中：</p>
<script type="math/tex; mode=display">ltag=\begin{cases}0,*lchild\;is\;lchild\\
1,*lchild\;is\;preNode\end{cases}</script><script type="math/tex; mode=display">rtag=\begin{cases}0,*rchild\;is\;rchild\\
1,*rchild\;is\;postNode\end{cases}</script><p>线索$(Thread)$：指向结点前驱和后继的指针<br>线索二叉树$(Thread\;Binary\;Tree)$：加上线索的二叉树<br>线索链表$(Thread\;Linked\;List)$：加上线索的二叉链表<br>线索化：对二叉树以某种次序进行遍历使其成为线索二叉树的过程</p>
<p>结点结构示意图：</p>
<script type="math/tex; mode=display">\boxed{lchild|ltag|data|rtag|rchild}</script><p>线索二叉树的定义和基本操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    BiThrNode *lchild, *rchild;</span><br><span class="line">    <span class="keyword">int</span> LTag, RTag;</span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadBiTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    BiThrNode *bt;</span><br><span class="line">    BiThrNode *pre;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RCreate</span><span class="params">(BiThrNode *p, <span class="keyword">int</span> flag, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    BiThrNode *Thrt;</span><br><span class="line">    ThreadBiTree();</span><br><span class="line">    ~ThreadBiTree();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(<span class="keyword">int</span> end)</span></span>;</span><br><span class="line">    <span class="function">BiThrNode *<span class="title">GetRoot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InOrderThreading</span><span class="params">(BiThrTree &amp;Thrt, BiThrTree T)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BiTreeDisplay</span><span class="params">(BiThrNode *bt, <span class="keyword">int</span> level = <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">ThreadBiTree::ThreadBiTree()</span><br><span class="line">&#123;</span><br><span class="line">    bt = <span class="literal">NULL</span>;</span><br><span class="line">    Thrt = <span class="keyword">new</span> BiThrNode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadBiTree::~ThreadBiTree()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ThreadBiTree::InThreading(BiThrTree p)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        InThreading(p-&gt;lchild);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;LTag = <span class="number">1</span>;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pre-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;RTag = <span class="number">1</span>;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        InThreading(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="树，森林与二叉树的转换"><a href="#树，森林与二叉树的转换" class="headerlink" title="树，森林与二叉树的转换"></a>树，森林与二叉树的转换</h3><ol>
<li><p>树与二叉树的转换</p>
<p>由于树和二叉树都可以采用二叉链表作为存储结构，则以二叉链表作为中间形态导出树和二叉树之间的对应关系。</p>
<p>将一棵树转换成二叉树的方法如下：</p>
<ol>
<li>加线：在树中所有相邻兄弟之间加一条连线</li>
<li>抹线：对树中的每个结点，只保留它与第一个孩子结点之间的连线，删除它与其他孩子结点之间的连线</li>
<li>旋转：以树的根结点为轴心，将整棵树顺时针旋转45°，使之成为一棵层次分明的二叉树</li>
</ol>
</li>
<li><p>森林与二叉树的转换</p>
<ol>
<li>将森林中的每棵树转换成对应的二叉树</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子。</li>
</ol>
</li>
</ol>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆：设有$n$个元素的序列${k_1,k_2,\cdots,k_n}$,当且仅当满足下述关系之一时：</p>
<script type="math/tex; mode=display">\begin{cases}k_i\le k_{2i}\\
k_i\le k_{2i+1}\end{cases}
\;or\;
\begin{cases}k_i\ge k_{2i}\\
k_i\ge k_{2i+1}\end{cases}</script><p>若以一维数组存储堆，则堆对应为一棵完全二叉树，且所有非叶子结点的值均不大于或不小于其子女的值，根结点的值是最小或最大的。</p>
<p>堆具有下列其中某一条性质的完全二叉树：</p>
<ol>
<li>每个结点的值都小于或等于其左右孩子结点的值，称为小根堆或小顶堆。</li>
<li>每个结点的值都大于或等于其左右孩子结点的值，称为大根堆或大顶堆。</li>
</ol>
<h3 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h3><ol>
<li><p>概念</p>
<p>哈夫曼树：又称最优二叉树，指带权路径长度最小的二叉树。</p>
<p>涉及的术语：</p>
<ul>
<li>结点的权：对结点赋予的一个有着某种意义的数值</li>
<li>结点的带权路径长度：从树根结点到该结点之间的路径长度与该结点权值的乘积</li>
<li>叶子结点：树中度为0的结点</li>
<li>树的带权路径长度：树中所有叶子结点的带权路径长度之和</li>
</ul>
<p>树的带权路径长度$WPL$可记为：</p>
<script type="math/tex; mode=display">WPL=\sum^n_{k=1}W_k\bullet L_k</script><p>其中$W_k$为第$k$个叶子结点的权值，$L_k$为第$k$个叶子结点的路径长度。</p>
</li>
<li><p>哈夫曼树的构造</p>
<p>哈夫曼树的构造算法如下：</p>
<ol>
<li>根据给定的$n$个权值${w_1,w_2,\cdots,w_n}$构造$n$棵二叉树的集合$F=(T_1,T_2,\cdots,T_n)$，其中每棵二叉树$T_i$中只有一个权值为$W_i$的根结点，其左右子树均为空。</li>
<li>在$F$中选取两个根结点的权值最小的树，分别作为左右子树构造一棵新的二叉树，且将新的二叉树的根结点的权值为置其左右子树上根结点的权值之和。</li>
<li>在$F$中删除作为左右子树的两棵二叉树，同时将新得到的二叉树加入$F$中。</li>
<li>重复2和3，直到$F$只含有一棵树为止，这棵树就是哈夫曼树。</li>
</ol>
</li>
<li><p>哈夫曼编码</p>
<p>在数据通信中，需要将传送的文字转换成由二进制字符0、1组成的字符串也称编码。</p>
<p>每个字符所转换的二进制字符长度相等称为<strong>等长编码</strong>。</p>
<p>如果让出现频率高的字符采用尽可能短的编码，出现频率低的字符采用稍长的编码，构造一种<strong>不等长编码</strong>，则电文的代码总长度会更短。</p>
<p>设计电文总长最短的编码方式：构造以字符使用频率作为权值的哈夫曼树。</p>
<p>具体操作如下：设需要编码的字符集合为${d_1,d_2,\cdots,d_n}$，它们在电文中出现的次数或频率集合为${w_1,w_2,\cdots,w_n}$，以$d_1,d_2,\cdots,d_n$作为叶子结点，$w_1,w_2,\cdots,w_n$作为它们的权值，构造一棵哈夫曼树，规定哈夫曼树的左分支代表0，右分支代表1，则从根结点到每个叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，称之为<strong>哈夫曼编码</strong>。</p>
<p><strong>在不等长编码的选择上，必须使任何一个字符的编码都不是其他字符编码的前缀，以保证译码的唯一性。</strong></p>
<p>若采用哈夫曼编码，则能确保译码的唯一性。</p>
<p>哈夫曼编码的算法：</p>
<ol>
<li>构造哈夫曼树。</li>
<li>在哈夫曼树上求叶子结点的编码。</li>
</ol>
</li>
</ol>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><ul>
<li>图：是由有穷非空的顶点集合和顶点之间的边的集合组成的，可表示为：</li>
</ul>
<p>  其中，表示图，图中的数组元素通常叫做<strong>顶点</strong>称为顶点的非空有穷集合，是图中顶点之间边的集合。</p>
<ul>
<li><p>无向边：若顶点和间的边没有方向，用表示</p>
</li>
<li><p>无向图：只有无向边的图</p>
</li>
<li><p>有向边(弧)：若顶点和间的边有方向,用表示且称为弧尾或初始点,称为弧头或终端点</p>
</li>
<li><p>有向图：只有有向边的图</p>
</li>
<li><p>自环:顶点有直接与自身相连的边</p>
</li>
<li><p>多重图：任意连个顶点之间有多条边直接相连</p>
</li>
<li><p>完全图：在由个边组成的<strong>无向图</strong>中，若有条边，则称之<strong>无向完全图</strong>。在由个边组成的<strong>有向图</strong>中，若有条边，则称之为<strong>有向完全图</strong></p>
</li>
<li><p>权：在某些图上，边或弧上具有与它相关的数据信息称之为权</p>
</li>
<li><p>网或网络：带权的图</p>
<p>分别称带权的有向图和带权的无向图为<strong>有向网和无向网</strong></p>
</li>
<li><p>邻接顶点：相邻的两个结点互为邻接顶点</p>
</li>
<li><p>子图：设图和，若且，则称图为图的子图。</p>
</li>
<li><p>度：与顶点关联的边的数目，记作。</p>
<ul>
<li>有向图中，顶点的度等于出度加入度</li>
<li>入度：以顶点为弧头的弧的数目，记作</li>
<li>出度：以顶点为弧尾的弧的数目，记作</li>
<li></li>
<li>无论有向图和无向图，若图有n个顶点和e条边，则有：</li>
</ul>
</li>
<li><p>路径：从一个顶点到另一个顶点经过的顶点序列</p>
</li>
<li><p>路径长度：一条路径上经过的边或弧的数目</p>
</li>
<li><p>简单路径和回路：路径上的各顶点补充度称为简单路径，若第一个顶点和最后一项顶点重复，称这样的路径为回路或环。</p>
</li>
<li><p>连通图和连通分量：在无向图中，两顶点之间存在路径，则两顶点是连通的。如果图中任意一对顶点都是连通的，则此图为连通图。非连通图的极大连通子图叫做连通分量</p>
</li>
<li><p>强连通图与强连通分量：在有向图中，若在每一对顶点和之间都存在一条从到的路径，也存在一条从到的路径，则此图叫做强连通图，而非强连通图的极大强连通子图叫做强连通分量。</p>
</li>
<li><p>生成树：具有个顶点的连通图的生成树是包含中全部顶点的一个极小连通子图，在生成树中添加任意一条原图中的边必会产生回路或环，减少一条边则必然会成为非连通图。一棵具有个顶点的生成树有且仅有条边</p>
</li>
<li><p>生成森林：非连通图的每个连通分量都可以得到一棵生成树，这些连通分量的生成树构成了森林，即生成森林</p>
</li>
<li><p>稀疏图和稠密图：边很少的图称为稀疏图，反之称为稠密图。稀疏和稠密是模糊的概念，稀疏图和稠密图常常是相对而言。</p>
<blockquote>
<p>Prim常用求稠密图的最小生成树</p>
</blockquote>
</li>
</ul>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><ol>
<li><p>图的顺序存储结构——邻接矩阵</p>
<p>邻接矩阵存储结构是指用两个数组表示图。</p>
<p>一个一维数组存储图中顶点的信息，一个二维数组存储图中顶点之间的关系。</p>
<p>设图包含个顶点，则的邻接矩阵是一个二维数组</p>
<ul>
<li>若是一个无权图，则的邻接矩阵定义为：</li>
</ul>
</li>
</ol>
<ul>
<li>若是一个网，则的邻接矩阵定义为：</li>
</ul>
<p>   图的邻接矩阵存储结构具有的特点：</p>
<ul>
<li>无向图的邻接矩阵是对称的，采用压缩矩阵进行存储。</li>
<li>有向图的邻接矩阵不一定对称，因此采用邻接矩阵存储据具有个顶点的有向图，需要个存储单元。</li>
<li>无向图邻接矩阵的第行(或第列)中非零元素的个数，就是顶点的度。</li>
<li>有向图邻接矩阵的第行中非零元素的个数，就是顶点的出度，第列中非零元素的个数就是顶点的入度。</li>
<li><p>邻接矩阵容易确定图中两顶点的是否有边，但检测边需要很大的时间代价。</p>
<p>邻接矩阵的存储结构的类定义和基本操作：</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MAX_VERTEX_NUM 20</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int infinity = INT32_MAX;</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct ArcCell</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int adj; //对无权图1,0表示是否相邻，对带权图表示权值类型</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *info;</span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct MGraph</span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string vexs[MAX_VERTEX_NUM];                  //顶点表</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArcCell arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; //邻接矩阵表，即  边表</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int vexnum;                                   //顶点数</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int arcnum;                                   //边数</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int kind;                                     //邻接矩阵存储的  图的种类</span><br></pre></td></tr></table></figure>
<p>16</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>17</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Graph</span><br></pre></td></tr></table></figure>
<p>18</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>19</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private:</span><br></pre></td></tr></table></figure>
<p>20</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MGraph mgraph;</span><br></pre></td></tr></table></figure>
<p>21</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool visited[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>
<p>22</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>23</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public:</span><br></pre></td></tr></table></figure>
<p>24</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Graph(/* args */);</span><br></pre></td></tr></table></figure>
<p>25</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~Graph();</span><br></pre></td></tr></table></figure>
<p>26</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CreateGraph();</span><br></pre></td></tr></table></figure>
<p>27</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int LocateVex(string u); //返回顶点u在图中的位置</span><br></pre></td></tr></table></figure>
<p>28</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool CreateDG();         //构造有向图</span><br></pre></td></tr></table></figure>
<p>29</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool CreateUDG();        //构造无向图</span><br></pre></td></tr></table></figure>
<p>30</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool CreateDN();         //构造有向网</span><br></pre></td></tr></table></figure>
<p>31</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool CreateUDN();        //构造无向网</span><br></pre></td></tr></table></figure>
<p>32</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Display();          //输出邻接矩阵</span><br></pre></td></tr></table></figure>
<p>33</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void DFSTraverse(int v); //深度优先遍历</span><br></pre></td></tr></table></figure>
<p>34</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void BFDTraverse(int v); //广度优先遍历</span><br></pre></td></tr></table></figure>
<p>35</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>图的链式存储结构</p>
<ol>
<li><p>邻接表是图的一种链式存储结构</p>
<ul>
<li>基本思想： 邻接表只存储有关联的信息，对图中存在的相邻顶点之间边的信息进行存储，而对于不相邻的顶点则不保留信息。设图具有个顶点，则用顶点数组表和边表来表示图</li>
<li>顶点数组表 用于存储顶点的名或其他有关信息，也称为数据域。该数组的大小为图中的顶点个数。顶点数组表中的数据元素也称为表头结点。 每个表头结点由两个域组成：<ul>
<li>：结点的数据域，用来保存结点的数据值</li>
<li>：结点的指针域，也称为链域，指向自该结点出发的第一条边的边结点</li>
</ul>
</li>
<li>边表(弧表) 图中每一个顶点建立一个单链表，第个单链表的结点表示依附于顶点的边。该单链表中的结点称为边结点， 每个边结点由三个域组成：<ul>
<li>:指示该边所指向的顶点在图中的位置，也称为邻接点域</li>
<li>:边结点的指针域，指向下一条边结点</li>
<li>:存储和边相关的信息，如权值</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<pre><code>  1

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//邻接表</span><br><span class="line"></span><br><span class="line">struct ArcNode</span><br></pre></td></tr></table></figure>


  3

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>


  4

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int adjvex;</span><br></pre></td></tr></table></figure>


  5

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArcNode *next;</span><br></pre></td></tr></table></figure>


  6

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


  7

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


  8

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct VertexNode</span><br></pre></td></tr></table></figure>


  9

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>


  10

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int vertex;</span><br></pre></td></tr></table></figure>


  11

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArcNode *firstedge;</span><br></pre></td></tr></table></figure>


  12

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


  13

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


  14

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MAX_VERTEX_NUM 20</span><br></pre></td></tr></table></figure>


  15

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


  16

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct ArcNode</span><br></pre></td></tr></table></figure>


  17

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>


  18

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int adjvex;</span><br></pre></td></tr></table></figure>


  19

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct ArcNode *nextarc;</span><br></pre></td></tr></table></figure>


  20

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *info;</span><br></pre></td></tr></table></figure>


  21

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


  22

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


  23

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct VNode</span><br></pre></td></tr></table></figure>


  24

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>


  25

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string data;</span><br></pre></td></tr></table></figure>


  26

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArcNode *firstarc;</span><br></pre></td></tr></table></figure>


  27

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


  28

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


  29

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct AdjLGraph</span><br></pre></td></tr></table></figure>


  30

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>


  31

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VNode vertices[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>


  32

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int vexnum;</span><br></pre></td></tr></table></figure>


  33

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int arcnum;</span><br></pre></td></tr></table></figure>


  34

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int kind;</span><br></pre></td></tr></table></figure>


  35

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


  36

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ALGraph</span><br></pre></td></tr></table></figure>


  37

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>


  38

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private:</span><br></pre></td></tr></table></figure>


  39

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AdjLGraph algraph;</span><br></pre></td></tr></table></figure>


  40

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool visited[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>


  41

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


  42

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public:</span><br></pre></td></tr></table></figure>


  43

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALGraph(/* args */);</span><br></pre></td></tr></table></figure>


  44

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~ALGraph();</span><br></pre></td></tr></table></figure>


  45

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CreateGraph();</span><br></pre></td></tr></table></figure>


  46

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int LocateVex(string u);</span><br></pre></td></tr></table></figure>


  47

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ALGraphDisplay();</span><br></pre></td></tr></table></figure>


  48

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void FindInDegree(int indegree[]);</span><br></pre></td></tr></table></figure>


  49

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool TopologicalSort();</span><br></pre></td></tr></table></figure>


  50

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li>十字链表 十字链表是有向图的一种链式存储方式。 十字链表将邻接表和逆邻接表结合起来得到的</li>
</ol>
<pre><code>  弧结点中共五个域：

  - tailevex：弧尾结点，即弧尾在顶点表的下标
  - headvex：弧头结点，即弧头在顶点表的下标
  - hlink：指向弧头相同的下一条弧
  - tlink：指向弧尾相同的下一条弧
  - info：存储该弧的相关信息

  顶点结点即链表的头结点：

  - data：存储和该顶点相关的信息
  - firstin：指向该顶点的第一个弧结点
  - firstout：指向该顶点为弧尾的第一个弧结点

  1

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//十字链表</span><br></pre></td></tr></table></figure>

  2

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  3

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MAX_INFO 10</span><br></pre></td></tr></table></figure>

  4

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  5

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct ArcBox</span><br></pre></td></tr></table></figure>

  6

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  7

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int tailvex, headvex;</span><br></pre></td></tr></table></figure>

  8

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArcBox *hlink, *tlink;</span><br></pre></td></tr></table></figure>

  9

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *info;</span><br></pre></td></tr></table></figure>

  10

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  11

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  12

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct VexNode</span><br></pre></td></tr></table></figure>

  13

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  14

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string data;</span><br></pre></td></tr></table></figure>

  15

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArcBox *firstin, *firstout;</span><br></pre></td></tr></table></figure>

  16

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  17

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  18

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct OLGraph</span><br></pre></td></tr></table></figure>

  19

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  20

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VexNode xlist[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>

  21

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int vexnum, arcnum;</span><br></pre></td></tr></table></figure>

  22

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  23

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  24

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class OrListGraph //有向图的十字链表表示</span><br></pre></td></tr></table></figure>

  25

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  26

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private:</span><br></pre></td></tr></table></figure>

  27

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OLGraph olgraph;</span><br></pre></td></tr></table></figure>

  28

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool visited[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>

  29

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  30

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public:</span><br></pre></td></tr></table></figure>

  31

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OrListGraph(/* args */) &#123;&#125;</span><br></pre></td></tr></table></figure>

  32

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~OrListGraph() &#123;&#125;</span><br></pre></td></tr></table></figure>

  33

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CreateGraph();</span><br></pre></td></tr></table></figure>

  34

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int LocateVex(string u);</span><br></pre></td></tr></table></figure>

  35

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Display();</span><br></pre></td></tr></table></figure>

  36

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li>邻接多重表 邻接多重表是无向图的一种链式存储方式。</li>
</ol>
<pre><code>  - mark：标志域，可以标记改边是否被搜索过
  - ivex、jvex：与该边依附的两个顶点在顶点表的下标
  - ilink、jlink：指针域，指向下一条依附于顶点ivex和jvex的边
  - info：存储和边相关的信息
  - data：存储和该点相关的信息
  - firstedge：指示第一条依附于该顶点的边
</code></pre><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><ol>
<li><p>深度优先搜索 类似树的先根遍历。 从图中的某个点v出发，作为当前顶点，访问此顶点，并设置该顶点的访问标志，接着从v的为被访问的邻接点中找出一个作为下一步探查的当前顶点。倘若当前顶点的所有邻接顶点都被访问过，则退回一步，将前一步访问的顶点重新取出，作为当前探查顶点，重复上述过程，直至图中最初指定起点的所有邻接顶点都被访问到。</p>
<p>深度优先搜索的过程中所有访问过的顶点和经过的边，构成一个连通的无环图，也就是深度优先搜索树，简称DFS树</p>
<p>深度优先搜索的递归实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Graph::DFSTraverse(int v)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; mgraph.vertex[v];</span><br><span class="line">    visited[v]=1;</span><br><span class="line">    for(j=0;j&lt;mgraph.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(mgraph.arcs[v][j]==1 &amp;&amp; visited[j]==0)</span><br><span class="line">            DFSTraverse(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>广度优先搜索</p>
<p>类似树的层次遍历</p>
<p>无向连通图广度优先搜索的实现</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Graph::BFSTraverse(int v)</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">front = rear = -1;</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; mgraph.vertex[v];</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">visited[v]=1;</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Q[++rear]=v;</span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(front!=rear)</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v=Q[++front];</span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(mgraph.arcs[v][j]==1 &amp;&amp; visited[j]==0)</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DFSTraverse(j);</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; mgraph.vertex[j];</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">visited[j]=1;</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Q[++rear]=j;</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>连通分量和重连通分量</p>
<ul>
<li>连通分量：当无向图为非连通图时，利用或,无法遍历图中的所有顶点，而只能遍历到该顶点所在的最大连通子图的所有顶点，这些顶点构成一个连通分量。</li>
<li>关节点:在无向连通图中，当且仅当删去一个点及其依附于它的边，图被分为两个连通分量。</li>
<li>重连通图：没有关节点的连通图</li>
</ul>
</li>
</ol>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>设是一个无向连通网</p>
<ul>
<li>代价：的生成树上任一条边的权值称为该边的代价</li>
<li>最小生成树：一棵生成树的代价就是树上各边代价之和，代价最小的生成树就是最小代价生成树，简称最小生成树。</li>
</ul>
<p>根据生成树的定义，若连通带权图由个顶点组成，其生成树必含个顶点，条边，因此构造最小代价生成树的准则有3条：</p>
<ol>
<li>只能使用该网络中的边来构造最小生成树</li>
<li>能且只能使用条边来连接网络中的n个顶点</li>
<li>选用的条边不能产生回路</li>
</ol>
<p>构造最小生成树的方法多数利用了最小生成树的一种性质，简称MST</p>
<ul>
<li>:假设是一个连通网，是顶点集的一个非空子集。若是一条具有最小权值的边，其中，，则必存在一棵包含边的最小生成树。</li>
</ul>
<p>构造最小生成树的典型算法：</p>
<ul>
<li>算法</li>
<li>算法</li>
</ul>
<p>都利用了性质，采用逐步求解的策略，亦称<strong>贪心策略</strong></p>
<ol>
<li><p>算法(适用于稀疏图)</p>
<p>基本思想：设一个有个顶点的连通网络。</p>
<ul>
<li>首先构造一个由个顶点组成，不含任何边的图，其中每个顶点自成一个连通分量</li>
<li>不断从中去除代价最小的一条边（若有多条，任选其一）,若该边的两个顶点来自T的不同的连通分量，则将此边加入到T中，否则舍去此边选择下一条代价最小的边。</li>
<li>依次类推，直到T中所有的顶点在同一个连通分量为止。</li>
</ul>
</li>
</ol>
<ol>
<li><p>算法(适用于稠密图)</p>
<p>基本思想：</p>
<ul>
<li>给定任意带权连通网络是的最小生成树。</li>
<li>算法始终将顶点集合分成没有元素重叠的两部分，，的初始状态为,然后重复执行一下操作：</li>
<li>在所有的边中找出一条代价最小的边并入集合,同时并入，直至为止。</li>
</ul>
</li>
</ol>
<h3 id="有向无环图及其应用"><a href="#有向无环图及其应用" class="headerlink" title="有向无环图及其应用"></a>有向无环图及其应用</h3><ul>
<li><p>有向无环图：一个无环的有向图，简称图</p>
<ul>
<li><p>有向无环图是描述含有公共子式的表达式的有效工具。例如：</p>
</li>
<li><p>有向无环图也是描述一项工程或系统的有效工具</p>
<p>关心的问题：</p>
<ol>
<li>工程是否能够顺利进行</li>
<li>估算整个工程完成所必须的最短时间 对应于有向图，则进行拓扑排序和求关键路径的操作。</li>
</ol>
</li>
</ul>
</li>
<li><p>网与拓扑排序</p>
<ul>
<li>活动：所有工程或某种流程可以分成若干个小的工程或阶段，这些小的工程或阶段就是活动</li>
<li>网：用顶点表示活动，有向边表示活动的优先关系</li>
<li>若顶点到顶点之间存在一条有向路径，则称顶点是顶点的前驱或顶点是顶点的后继</li>
<li>拓扑排序：就是由某个集合的一个偏序得到该集合上的一个全序的操作<ul>
<li>若集合的关系满足自反、反对称和传递性，则称是集合上的偏序</li>
<li>若是集合上的偏序，如果对每个必有或，则称是上的全序关系 对一个有向无环图进行拓扑排序，是将G中所有顶点排成一个线性序列， 使得图中任意一对顶点u和v,若边，则u在线性序列中出现在v之前。 通常，这样的线性序列称为满足拓扑次序的序列，简称拓扑序列。</li>
</ul>
</li>
</ul>
</li>
<li><p>网与关键路径(重点)</p>
<ul>
<li>网：边表示活动的网。网是一个带权的有向无环图。顶点表示事件，弧表示活动，权表示活动持续的时间，网可以用来表示工程的进度计划</li>
<li>在正常情况下(无环)下：网中只有一个入度为0的点,称之为源点；一个出度为0的点，称之为汇点</li>
</ul>
<p>用于工程估算：</p>
<ol>
<li>完成整个工程所需的时间(假设网中无环)？</li>
<li>那些活动是影响工程进度的关键？</li>
</ol>
<ul>
<li>关键路径：完成整个工程所需的时间取决于从源点到汇点的最长路径的长度，即在这条路径上所有活动的持续时间之和，这条最长的路径即关键路径</li>
<li>关键活动：不按时完成就会影响整个工程的活动。关键路径上的活动就是关键活动</li>
</ul>
</li>
</ul>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><ul>
<li><p>最短路径：由于从一个顶点到另一个顶点可能存在多条路径，每条路径上所经过的边数可能不同，即路径长度不同，则称路径长度最短即边数最少的路径为最短路径</p>
</li>
<li><p>带权图路径长度：若图是带权图，则把一个顶点到图中其余任一个顶点的一条路径所经过边上的权值之和定义为带权图路径长度</p>
</li>
<li><p>最短路径问题包括：</p>
<ul>
<li>求图中一个顶点到其余顶点的最短路径</li>
<li>求图中每对顶点之间的最短路径</li>
</ul>
</li>
<li><p>单源最短路径 利用算法解决单源最短路径问题：给定带权有向图和源点,求到中其余个点的最短路径，其时间复杂度为</p>
<p><strong> 搞清执行过程</strong></p>
</li>
<li><p>每对顶点间的最短路径 求各个顶点之间最短路径的算法，其时间复杂度也是：</p>
<p>通过计算图中各个顶点的最短路径时，需要引入两个矩阵，- 矩阵中的元素表示顶点(第个顶点)到顶点(第个顶点)的距离。</p>
<ul>
<li>矩阵中的元素，表示顶点到顶点经过了记录的值所表示的顶点。</li>
</ul>
<p>假设图G中顶点个数为，则需要对矩阵和矩阵进行次更新。初始时，矩阵中顶点的距离为顶点到顶点的权值; 如果和不相邻，则，矩阵的值为顶点的的值。接下来开始，对矩阵进行次更新。 第1次更新时，如果”的距离”“”(表示”与之间经过第1个顶点的距离”)，则更新为””,更新。 同理，第次更新时，如果”的距离”“”，则更新为””,。更新次之后，操作完成！</p>
<p><a href="https://blog.csdn.net/qq_35644234/article/details/60875818" target="_blank" rel="noopener">最短路径问题—-Floyd算法详解</a></p>
</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h3><ul>
<li><p><strong>静态查找表</strong>：仅对查找表进行查找操作，不进行插入和删除操作的查找表</p>
</li>
<li><p><strong>动态查找表</strong>：可以查找表进行查找、插入和删除操作的表。</p>
</li>
<li><p>面向查找操作的数据结构称为<strong>查找结构</strong></p>
<ul>
<li><strong>线性表</strong>：适用于静态查找，主要采用顺序查找技术、折半查找技术</li>
<li><strong>树表</strong>：适用于动态查找，主要采用二叉排序树的查找技术；</li>
<li><strong>散列表</strong>：静态和动态查找均适用，主要采用<strong>散列技术</strong>。</li>
</ul>
<p>以“关键字与给定值的比较次数”作为衡量算法效率的方法，该比较次数的期望值，称为查找成功的<strong>平均查找长度</strong></p>
<p>对于含有n个记录的表，查找成功的平均查找长度为：</p>
</li>
</ul>
<p>  是查找第个记录的概率，且表示找到给定关键字与给定值相等的第个记录，已和给定值进行过比较的关键字个数。</p>
<h3 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h3><ol>
<li><p>顺序查找</p>
<ul>
<li><p>又称线性查找。</p>
</li>
<li><p>基本思想</p>
<p>首先将顺序表中的第一个存储单元(即下标为0的单元)设置为“监视哨”，即把待查值放入该单元，查找时从顺序表的最后一个单元开始，依次向前搜索进行查找</p>
</li>
<li><p>算法分析</p>
<ul>
<li>查找成功的情况下： 若每个记录的查找概率相等，即，则为：</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code> - 查找失败和查找成功的可能性相同，且每个记录的查找概率相等，则 在查找失败的情况下，不管查找的关键字为何值，其比较次数都为。在该条件下的平均查找长度为：
</code></pre><ul>
<li><p>优点：算法简单，对表的结构没有任何要求</p>
</li>
<li><p>缺点：当很大，查找效率很低</p>
</li>
</ul>
<ol>
<li><p>有序表的查找</p>
<ul>
<li><p>当查找表中的数据元素无序，选择顺序查找简单又实用。但但查找表中的数据元素在顺序存储时是有序的情况下，可以采用<strong>折半查找</strong>，又称<strong>二分查找</strong></p>
</li>
<li><p>基本思想</p>
<p>给定有序表ST,在表ST中取位于中间的记录作为比较对象，若中间记录和关键字与给定值相等，则查找成功；若中间记录的关键字大于给定值，则在中间记录的左半区继续查找；若中间记录的关键字小于给定值，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功或所查找的区域无记录即查找失败</p>
</li>
<li><p>折半查找算法的非递归实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Search_Bin(int key)</span><br><span class="line">&#123;</span><br><span class="line">    int low=0;high=st.length-1;</span><br><span class="line">    int mid;</span><br><span class="line">    while(low&lt;=hight)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/2;</span><br><span class="line">        if(st.elem[mid]==key)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;查找成功，处于第&quot;&lt;&lt;mid+1&lt;&lt;&quot;位置&quot;&lt;&lt;endl;</span><br><span class="line">            return mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(st.elem[mid]&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(st.elem[mid]&lt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;未找到！&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造折半查找判定树</p>
<ol>
<li>确定下标范围：0-10</li>
<li>L[(0+10)/2]=5 —&gt; 根结点为6 左子树的下标为0-4 右子树的下标范围为 6-10</li>
<li>L[(0+4)/2]=2 ,…..</li>
<li>L[(6+10)/2]=8 ,…..</li>
</ol>
</li>
<li><p>算法分析</p>
<p>对于折半查找，查找成功时进行的关键字比较次数至多为。 查找成功的平均查找长度为</p>
</li>
</ul>
</li>
</ol>
<pre><code> 当比较大时， 查找失败时的平均查找长度的量级为：
</code></pre><ol>
<li><p>分块查找</p>
<ul>
<li><p>分块查找又称索引顺序查找</p>
</li>
<li><p>前提：查找表，满足分块有序，分块有序即整个查找表无序，但把查找表看做几个子表时，每个子表的关键字是有序的。</p>
</li>
<li><p>基本思想</p>
<p>在查找时，首先用待查值key在索引表中进行区间查找(即查找key所在的子表，由于索引表按最大关键字项有序，因此可采用折半查找或者顺序查找)，然后在对应的子表进行顺序查找</p>
</li>
<li><p>算法分析</p>
<p>设对索引表查找的平均查找长度为,对待查子表中查找元素的平均查找长度为，则分块查找的平均查找长度可以通过两种算法的平均查找长度之和表示：</p>
</li>
</ul>
</li>
</ol>
<pre><code> 采用分块查找：长度为n的表分为b块，每个块m个记录，则。

 - 采用顺序查找确定块的位置

   块的查找概率为，块中每个记录的查找概率为，该条件下分块查找的平均查找长度为：



   当时，平均查找厂区取最小值为。

 - 采用折半查找确定块
</code></pre><ol>
<li><p>二叉排序树</p>
<ul>
<li><p>二叉排序树又称二叉查找树</p>
</li>
<li><p>性质</p>
<ol>
<li>若左子树不空，则左子树上的所有结点的值均小于根结点的值</li>
<li>若右子树不空，则右子树上的所有结点的值均大于根结点的值</li>
<li>它的左右子树也分别是二叉排序树</li>
</ol>
</li>
<li><p>查找方法</p>
<p>首先将给定值key与根结点的关键字进行比较，若相等，则查找成功；若根结点的关键字大于key，则在根结点的左子树上进行查找，否则在根结点的右子树上进行查找</p>
</li>
<li><p>查找代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int key;</span><br><span class="line">&#125;;</span><br><span class="line">struct BTSNode</span><br><span class="line">&#123;</span><br><span class="line">    Node data;</span><br><span class="line">    BTSNode *lchild,*rchild;</span><br><span class="line">&#125;;</span><br><span class="line">void SearchBST(BTSNode *T,int key)</span><br><span class="line">&#123;</span><br><span class="line">    if((!T)||(key==T-&gt;data.key))</span><br><span class="line">    &#123;</span><br><span class="line">        if(!T)</span><br><span class="line">            cout &lt;&lt; &quot;找不到&quot;&lt;&lt;key&lt;&lt;“的结点”&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;找到&quot;&lt;&lt;key&lt;&lt;“的结点”&lt;&lt;endl;</span><br><span class="line">        else if(key&lt;T-&gt;data.key)</span><br><span class="line">            SearchBST(T-&gt;lchild,key);</span><br><span class="line">        else</span><br><span class="line">            SearchBST(T-&gt;rchild,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int SearchBST(BTSNode *T,int key,BTSNode *f,BTSNode* &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    if(!T)//查找不成功</span><br><span class="line">    &#123;</span><br><span class="line">        p=f;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(key==T-&gt;data.key)//查找成功</span><br><span class="line">    &#123;</span><br><span class="line">        p=T;</span><br><span class="line">        return = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(key&lt;T-&gt;data.key)</span><br><span class="line">        return SearchBST(T-&gt;lchild,key,T,p);</span><br><span class="line">    else</span><br><span class="line">        return SearchBST(T-&gt;rchild,key,T,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉排序树的插入(插入的位置为查找失败的位置)</p>
<ul>
<li><p>插入方法</p>
<p>首先在树中查找是否已有关键字为key的结点，若查找成功，则说明待插入结点已经存在，不能插入重复结点。只有当查找失败，才能在树中插入关键字为key的新节点。</p>
</li>
<li><p>插入代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int InsertBST(int e)</span><br><span class="line">&#123;</span><br><span class="line">    int key =e;</span><br><span class="line">    BTSNode *p = new BTSNode;</span><br><span class="line">    BTSNode *T = BT;</span><br><span class="line">    if(!SearchBST(T,key,NULL,p))</span><br><span class="line">    &#123;</span><br><span class="line">        BTSNode *s = new BTSNode;</span><br><span class="line">        s-&gt;data.key = e;</span><br><span class="line">        s-&gt;lchild=s-&gt;rchild=NULL:</span><br><span class="line">        if(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            BT=s;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(key&lt;p-&gt;data.key)</span><br><span class="line">            p-&gt;lchild=s;</span><br><span class="line">        else</span><br><span class="line">            p-&gt;rchild=s;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>二叉排序树的删除</p>
<ul>
<li><p>删除代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int DeleteBST(BSTNode* &amp;T，int key)</span><br><span class="line">&#123;</span><br><span class="line">    if(!T)</span><br><span class="line">        return 0;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if(key==T-&gt;data.key)</span><br><span class="line">            return Delete(T);</span><br><span class="line">        else if(key&lt;T-&gt;data.key)</span><br><span class="line">            return DeleteBST(T-&gt;lchild,key);</span><br><span class="line">        else</span><br><span class="line">            return DeleteBST(T-&gt;rchild,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>平衡二叉树的构造（AVL）首先是一个二叉树排序树(重点，补充平衡二叉树的调整)</p>
</li>
</ul>
</li>
<li><p>B_树</p>
<p>上述介绍的查找方法都是适用于内部查找的方法，称为<strong>内部查找法</strong>。适用于数据集不大，可以放入内存中，适用于对较小的文件进行查找，而不适用于对较大的存放在外存储器中文件。</p>
<ul>
<li><p>B_树：特点是插入、删除时易于保持平衡，外部查找效率高，适用于组织磁盘文件的动态索引结构。</p>
<p>B_树是一种平衡的多路查找树，作为索引组织文件，用以提高访问速度。</p>
</li>
<li><p>一棵m阶的B_树，可以为空树，或者是一棵满足下列性质的m叉树：</p>
<ol>
<li>树中的每个结点至多有m棵子树</li>
<li>若根结点不是叶子结点，则至少有两棵子树</li>
<li>除根结点之外所有非叶子结点至少有棵子树</li>
<li>有s个子树的非叶子结点具有s-1个关键字，所有非叶子结点包含下列信息： ，其中为关键字个数，为关键字，为指向子树根结点的指针，且指针所指子树中所有结点的关键字均小于，所指子树中所有结点的关键字均大于 </li>
<li>B_树总是树高平衡的，所有的叶子结点都在同一层，且不包含任何关键字信息。通常叶子结点也被称为失败结点。</li>
</ol>
</li>
<li><p>B树的构造(补充)</p>
</li>
</ul>
</li>
</ol>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>在查找时，如果给定值在表中存在，则需根据并通过对应关系，即可的到在表中的存储位置。因此不需要比较，仅通过的计算，就能获得要查找的记录。称这样的对应关系为<strong>哈希函数</strong>或<strong>散列函数</strong>或<strong>杂凑函数</strong>，根据这个思想建立的表称为<strong>哈希表</strong>或<strong>散列表</strong>或<strong>杂凑表</strong>，根据哈希函数所得到的存储位置称为<strong>哈希地址</strong>或<strong>散列地址</strong>，而这种映像过程被称为<strong>哈希造表</strong>或<strong>散列</strong>。</p>
<p>根据函数的性质可知，对于某个函数，不同的通过获得的可能是相同的。</p>
<ul>
<li><strong>冲突</strong>：不同的关键字有可能的到相同的哈希地址的现象</li>
<li><strong>同义词</strong>：相同函数值的关键字称为函数上的同义词。</li>
</ul>
<p>采用散列技术需要考虑的两个问题：</p>
<ul>
<li>哈希函数的设计</li>
<li>冲突的处理</li>
</ul>
<ol>
<li><p>哈希函数</p>
<p>设计哈希函数应该遵循的原则</p>
<ul>
<li>计算简单，否则会降低查找效率</li>
<li>每个关键字所对应的哈希地址分布均匀。</li>
</ul>
<p>常见的几种哈希函数的构造方法：</p>
<ol>
<li><p>直接定址法</p>
<ul>
<li>定义 直接定义一个线性函数，取关键字对于该函数的函数值作为哈希地址，即：</li>
</ul>
</li>
</ol>
</li>
</ol>
<pre><code>    其中a和b是常数。

  - 特点 这类函数是一一对应函数，因此不会产生冲突，但要求地址集合和关键字集合的大小相同，并且当关键字跨度非常大时并不适用。该方法在实际生活中并不常用
</code></pre><ol>
<li><p>数学分析法</p>
<ul>
<li><p>定义 在关键字集合中，若每个关键字均由位组成，而每位上都有中不同的取值，通过分析中不同符号在每一位上的分布情况，选择其中某几位分布较为均匀的符号组成哈希地址。</p>
</li>
<li><p>Example 例如：一组关键字进行关键字分析</p>
<p>| 第一位 | 第二位 | 第三位 | 第四位 | 第五位 | 第六位 | 第七位 |<br>| ——— | ——— | ——— | ——— | ——— | ——— | ——— |<br>| 6      | 5      | 3      | 7      | 6      | 8      | 5      |<br>| 6      | 5      | 3      | 3      | 2      | 5      | 1      |<br>| 6      | 5      | 3      | 6      | 5      | 4      | 3      |<br>| 6      | 5      | 4      | 2      | 0      | 1      | 9      |<br>| 6      | 5      | 3      | 9      | 8      | 3      | 4      |<br>| 6      | 5      | 4      | 1      | 2      | 3      | 4      |<br>| 6      | 5      | 4      | 5      | 4      | 3      | 7      |</p>
<p>其中所有关键字的第一、二位均为6/5，而第三位也只有3和4，因此 这三位不用作哈希地址，剩余4位的取值分布比较均匀，可以作为哈希地址，因此可选取者四位中任意两位组合成哈希地址，也可以对这四位进行适当的处理来获得哈希地址。</p>
</li>
</ul>
</li>
<li><p>平方取中法</p>
<ul>
<li><p>定义 取关键字平方后的中间几位作为哈希地址。</p>
</li>
<li><p>Example 例如：关键字集合</p>
<p>| 关键字 | 关键字平方 | 所选取哈希地址 |<br>| ——— | ————— | ——————— |<br>| 3456   | 11943936   | 43             |<br>| 2564   | 6574096    | 40             |<br>| 3466   | 12013156   | 13             |<br>| 3454   | 11930116   | 30             |</p>
<p>平方后可取地中第4、5位作为哈希地址</p>
</li>
</ul>
</li>
<li><p>折叠法</p>
<ul>
<li><p>定义 将关键字按位数分割成几部分(其中最后一部分的长度会较小)，然后将这些部分按一定的方式进行求和，按哈希表表长取后几位作为哈希地址</p>
</li>
<li><p>形式</p>
<ul>
<li>位移法：将各部分按最后一维对齐相加</li>
<li>间接折叠法：从一端向另一端沿分割界来回折叠，然后对齐相加</li>
</ul>
</li>
<li><p>Example 例子：一个关键字为83950661436，哈希表长为3 首先将关键字表长分割成若干部分：</p>
<p>位移法： 间接折叠法：</p>
<p>由于哈希表长度为3，分别取后三位991和721作为关键地对应的哈希地址。</p>
</li>
</ul>
</li>
<li><p>除留余数法</p>
<ul>
<li>定义 选择一个常数，取关键字除以所得的余数作为哈希地址，即</li>
</ul>
</li>
</ol>
<pre><code>    该方法对的选取非常重要，若哈希表长度为，则要求小于等于且接近，并且一般选质数作为，或者是一个不包含小于20质因子的合数。
</code></pre><ol>
<li><p>处理冲突的方法</p>
<ol>
<li><p>开放定址法</p>
<ul>
<li>定义 开放地址，即一旦根据关键字所得到的哈希地址发生冲突，则按照某种规则寻找下一个空闲单元的哈希地址，只要哈希地址足够大，空的哈希地址总是能找到的。 其函数定义为：</li>
</ul>
</li>
</ol>
</li>
</ol>
<pre><code>    其中，为哈希函数，为哈希表长，的所取的增量序列。每种再散列的方法区别在于的取值不同。

  - 常用的方法

    - 线性探测再散列 取增量序列为的方法。 其过程描述为：当哈希地址发生冲突时，查看哈希地址是否为空，若为空则将数据放入，否则查看是否为空，依次类推
    - 二次探测在散列 取增量序列为 其过程描述为：当哈希地址发生冲突时，查看哈希地址是否为空，若为空则将数据放入，否则查看是否为空，若为空则将数据放入，否则查看是否为空，依次类推
    - 伪随机探测在散列 取增量序列为一个伪随机数 其过程描述为：当哈希地址发生冲突时，产生一个伪随机数，查找哈希地址是否为空，若为空则将数据放入，否则重新产生一个伪随机数查看是否为空，依次类推。
</code></pre><ol>
<li><p>再哈希法</p>
<ul>
<li>定义 再哈希法用数学表达式可以描述为:</li>
</ul>
</li>
</ol>
<pre><code>    其中，均为不同的哈希函数。 在哈希法的本质是使用个哈希函数，若第一个函数发生冲突，则利用第二个函数再生生成一个地址，直到产生的地址不冲突为止。
</code></pre><ol>
<li><p>链地址法</p>
<ul>
<li>定义 将每个哈希地址都作为一个指针，指向一个链表。 若哈希表长为，则建立个空链表，将哈希函数对关键字进行转换为后，映射到统一哈希地址的同义词均加入到地址指向的链表中</li>
</ul>
</li>
<li><p>建立一个公共溢出区</p>
<ul>
<li>定义 设哈希函数产生的哈希地址集为，则分配两个表。一个表作为基本表，其每个存储单元仅存放一个数据元素；另一个表为溢出表，只要关键字对应的哈希地址在基本表上发生了冲突，则将发生冲突的元素一律放入该表中。</li>
</ul>
<p>查找时，对应给定关键字，通过哈希函数计算出哈希地址为，则先与基本表中的地址为的数据元素进行比较，若相等则查找成功；否则再在溢出表中进行查找。</p>
</li>
</ol>
<ol>
<li><p>哈希查找算法及分析</p>
<p>查找元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define p 13//MOD 13</span><br><span class="line">struct HashTable</span><br><span class="line">&#123;</span><br><span class="line">    int *elem;//数据元素基址</span><br><span class="line">    int count;//当前数据元素个数</span><br><span class="line">    int size;//哈希表长度</span><br><span class="line">&#125;ht;</span><br><span class="line">int SearchHash(int key,int &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    s = CalHash(key);</span><br><span class="line">    while((ht.elem[s]!=-1)&amp;&amp;(ht.elem[s]!=key))//发生冲突</span><br><span class="line">        Collision(s);</span><br><span class="line">    if(ht.elem[s]==key)</span><br><span class="line">        return 1;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算哈希地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int CalHash(int key)//由哈希函数求哈希地址</span><br><span class="line">&#123;</span><br><span class="line">    return key % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发生冲突，计算下一地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Collision(int &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    s=s++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int InsertHash(int e)</span><br><span class="line">&#123;</span><br><span class="line">    int s;</span><br><span class="line">    if(ht.count == ht.size)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;表满，不能插入！&quot; &lt;&lt; endl;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        s = CalHash(e);</span><br><span class="line">        int r = SearchHash(e,s);</span><br><span class="line">        if(r)//表中已有和e的关键字相同的元素，不能插入操作</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;元素已经存在，不能插入！&quot; &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ht.elem[s]=e;</span><br><span class="line">            ht.count++;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找过程中，关键字的比较次数取决于产生冲突的次数，冲突产生越少，查找效率就越高。</p>
<p>影响冲突产生的因素有：</p>
<ol>
<li><p>哈希函数是否均匀</p>
</li>
<li><p>冲突的处理方法</p>
</li>
<li><p>哈希表的<strong>装填因子</strong> 将哈希表中元素的个数和哈希长度的比值最为哈希表的装填因子，即</p>
</li>
</ol>
</li>
</ol>
<pre><code>  是哈希表装满程度的指标，即装填因子。 与填入表中的元素的个数成正比，填入表中元素越多越大，冲突产生的可能性越大。
</code></pre><h2 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h2><h3 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h3><ul>
<li><p>排序</p>
<p>设有记录序列，其相应的关键字序列为， 若存在某种确定的关系，其中且各不相同，则将记录序列排成按关键字有序的序列的操作。</p>
</li>
<li><p>正序：若待排序序列中的记录已按关键字排序，此序列为正序</p>
</li>
<li><p>逆序和反序：若待排序序列中的记录的排序顺序与排序后的排列顺序正好相反</p>
</li>
<li><p>一趟：指在排序过程中，将待排序的记录序列扫描一遍</p>
</li>
<li><p>单关键字排序：根据一个关键字进行的排序</p>
</li>
<li><p>多关键字排序：根据多个关键字进行的排序，多关键字排序主要针对关键字有重复的情况下。</p>
</li>
<li><p>按照排序过程中数据元素是否完全在内存，分为：</p>
<ol>
<li>内部排序：在排序的整个过程，待排序的所有记录全部放置在内存中的排序方法，也称内排序</li>
<li>外部排序：指待排序的记录个数太多，不能同时放置在内存，需要将一部分记录放置在内存中，另一部分放置在外存中，整个排序过程需要在内外存之间多次交换数据才能得到排序结果的方法，也称外排序</li>
</ol>
</li>
<li><p>按照是否建立在关键字比较的基础上，分为：</p>
<ol>
<li>基于比较的排序方法：通过关键字之间的比较、记录的移动者两种操作来实现的方法 如：插入排序、交换排序、选择排序和归并排序</li>
<li>不基于比较的排序方法：根据待排序数据的特点所采取的其他方法，通常没有大量的关键字之间的比较和记录的移动这两种操作的排序 如：基数排序</li>
</ol>
</li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li>插入排序的工作原理：每次将一个待排序的数据按其关键字的大小<strong>插入</strong>到一个已经完成排序的<strong>有序序列</strong>中，直到所有记录排序结束。</li>
<li>根据排序的执行过程分为<ul>
<li>直接插入排序</li>
<li>折半插入排序</li>
<li>表插入排序</li>
<li>Shell排序</li>
</ul>
</li>
</ul>
<ol>
<li><p>直接插入排序</p>
<ul>
<li><p>算法思路</p>
<p>通过构建有序序列，对于未排序数据，在已排序序列中从后往前扫描，从而找到相应的位置并插入。 在从后往前扫描过程中，需要反复把已排序逐步往后挪位，为待插入的新元素提供插入空间</p>
</li>
<li><p>步骤</p>
<ol>
<li>设置</li>
<li>将待插入记录放入编号为0的结点(即下标为0的结点)，即;并令，从第个记录开始向前查找插入位置</li>
<li>若,执行5；否则执行4</li>
<li>将第个记录后移，即；并令;执行3</li>
<li>完成插入记录：。若，则排序结束，否则执行2</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SInsertSort(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=2;i&lt;=L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(L.r[i]&lt;=L.r[i-1])</span><br><span class="line">        &#123;</span><br><span class="line">            L.r[0]=L.r[i];</span><br><span class="line">            L.r[i]=L.r[i-1];</span><br><span class="line">            for(int j=i-2;L.r[0]&lt;=L.r[j];j--)</span><br><span class="line">                L.r[j+1]=L.r[j];</span><br><span class="line">            L.r[j+1]=L.r[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：两层嵌套循环结构，其外层循环n-1次，而内层循环执行次数取决于待排序列记录初始的排列情况。<ul>
<li>最好情况：待排序序列为正序，算法时间复杂度为</li>
<li>最坏情况：待排序序列为逆序，算法时间复杂度为</li>
<li>平均情况：算法的平均时间复杂度为</li>
</ul>
</li>
<li>空间复杂度：由于只需一个作为暂存待插入记录的存储单元，空间复杂度为</li>
<li>稳定性：该算法是稳定的排序算法</li>
</ul>
</li>
</ul>
<ol>
<li><p>折半插入排序</p>
<blockquote>
<p>当待排序记录数量很小时，直接插入排序方法是一种效率较高的排序算法。当记录数量较大，不宜用直接插入排序。</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>既然在有序表中确定插入位置，可以不断二分有序表来确定插入位置，即在一次比较中，通过比较待插入记录和有序表中中间记录的关键字，将有序表一分为二，而下一次比较则在其中一个有序子表中进行，将子表再次一分为二。这样继续下去，直到要比较的子表中只有一个记录时，做最后一次比较以确定插入位置。</p>
</li>
<li><p>步骤</p>
<ol>
<li>设置</li>
<li>顺序表中前个记录有序，将第个记录插入。令，，</li>
<li>若,得到插入位置；执行6；否则执行4</li>
<li>则取有序子表的中点</li>
<li>若,则插入位置在低半区，令；否则插入位置在高半区，令;执行3</li>
<li>即为待插入位置，从到的记录，逐个后移，。若，则排序结束，否则执行2</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void BInsertSort(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">    int high,low,m;</span><br><span class="line">    for(int i=2;i&lt;=L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.r[0]=L.r[i];</span><br><span class="line">        low = 1;</span><br><span class="line">        high = i-1;</span><br><span class="line">        while(low&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            m = (low+high)/2;</span><br><span class="line">            if(L.r[0]&lt;=L.r[m])</span><br><span class="line">                high=m-1;</span><br><span class="line">            else</span><br><span class="line">                low=m+1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=i-1;j&gt;high+1;j--)</span><br><span class="line">            L.r[j+1]=r[j];</span><br><span class="line">        L.r[high+1]=L.r[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：关键字比较次数最多为因此时间复杂度为</li>
<li>空间复杂度：</li>
<li>稳定性：折半插入排序是稳定的排序方法</li>
</ul>
</li>
</ul>
<ol>
<li><p>表插入排序</p>
<blockquote>
<p>前面介绍的两种插入排序算法都要大量移动记录，表插入排序则是一种不移动记录而是通过改变存储结构来进行排序的算法</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>表插入排序是通过链接指针、按关键字的大小实现从小到大的链接过程，为此需增设一个指针项。</p>
<p>具体的操作方法与直接插入排序类似，不同的是表插入排序是直接修改链接指针来完成记录的排序。</p>
<p>所需结点定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define SIZE 150</span><br><span class="line">struct SLNode</span><br><span class="line">&#123;</span><br><span class="line">    int rc;//记录项</span><br><span class="line">    int next;//指针项</span><br><span class="line">&#125;;</span><br><span class="line">struct SLinkList</span><br><span class="line">&#123;</span><br><span class="line">    SLNode node[size];//0号单元为表头结点</span><br><span class="line">    int curlen;//链表实际长度</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>具体思想：</p>
<p>首先设置空循环链表，即头结点指针置0，并在头结点数据中存放比所有记录的关键字都大的整数，然后把结点逐个向链表中插入即可。</p>
</li>
<li><p>步骤</p>
<ol>
<li>进行初始化操作。令</li>
<li>若，调整结束；否则根据对静态链表进行遍历：<ol>
<li>当时停止遍历，令执行2</li>
<li>当时，，执行2.1</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SLInsertSort(SlinkList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">    int min,max;</span><br><span class="line">    L.node[0].next = 1;</span><br><span class="line">    L.node[1].next = 0;//初始化形成指头头结点的循环链表</span><br><span class="line">    max = min = 1;</span><br><span class="line">    for(int i=2;i&lt;=L.curlen;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(L.node[i].rc&lt;=L.node[min].rc)</span><br><span class="line">        &#123;</span><br><span class="line">            L.node[0].next = i;</span><br><span class="line">            L.node[i].next = i-1;</span><br><span class="line">            min = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(L.node[i].rc&gt;=L.node[max].rc)</span><br><span class="line">        &#123;</span><br><span class="line">            L.node[i].next = 0;</span><br><span class="line">            L.node[max].next = i;</span><br><span class="line">            max = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(L.node[i].rc&lt;L.node[max].rc &amp;&amp; L.node[i].rc &gt; L.node[min].rc)</span><br><span class="line">        &#123;</span><br><span class="line">            int index1=min,index2;//index2标记index1的前一个下标</span><br><span class="line">            while(L.node[i].rc&gt;=L.node[index1].rc)</span><br><span class="line">            &#123;</span><br><span class="line">                index2=index1;</span><br><span class="line">                index1=L.node[index1].next;</span><br><span class="line">            &#125;</span><br><span class="line">            L.node[i].next=index1;</span><br><span class="line">            L.node[index2].next=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;表插入排序结果如下：&quot; &lt;&lt; endl;</span><br><span class="line">    int index = L.node[0].next;</span><br><span class="line">    while(index!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; L.node[index].rc &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        index = L.node[index].next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：</li>
<li>空间复杂度：</li>
<li>稳定性：表插入排序是稳定的排序方法</li>
</ul>
</li>
</ul>
<ol>
<li><p>希尔排序</p>
<blockquote>
<p>希尔排序又称缩小增量排序，是1969年D.L.Shell提出的，它是对直接插入排序的一种改进</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<ul>
<li><p>先将待排序记录分成若干个子序列，在子序列内分别进行直接插入排序；</p>
</li>
<li><p>直到整个序列基本有序时，在对全体记录进行一次直接插入排序。</p>
</li>
<li><p>与直接插入排序的区别</p>
<p>希尔排序不是每次一个元素挨着一个元素比较，而是初期选用大跨步(增量较大)间隔比较，使记录跳跃式的接近它的排序位置；然后增量逐步缩小，最后增量为1.</p>
</li>
</ul>
</li>
<li><p>步骤</p>
<ol>
<li>选择一个步长序列，其中且当时，</li>
<li>按步长序列个数，对序列执行次3</li>
<li>每次排序，根据对应的步长，将待排序列分成若干个子序列，分别对各子序列进行直接插入排序。当步长为1时，整个序列作为一个表来处理，表长度即为整个序列的长度</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述</p>
<ul>
<li><p>子程序(一趟希尔排序)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ShellInsert(SqList &amp;L,int dk)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=dk+1;i&lt;=L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.r[0]=L.r[i];</span><br><span class="line">        for(int j=i-dk;j&gt;0 &amp;&amp; L.r[0]&lt;=L.r[j];j-=dk)</span><br><span class="line">            L.r[j+dk]=L.r[j];</span><br><span class="line">        L.r[j+dk]=L.r[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主程序(按照增量序列对顺序表调用子程序)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ShellSort(SqList &amp;L,int dlta[],int t)</span><br><span class="line">&#123;</span><br><span class="line">    for(int k=0;k&lt;t;k++)</span><br><span class="line">        ShellInsert(L,dlta[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：时间性能在，当在某个特定范围，希尔排序算法的时间复杂度约为</li>
<li>空间复杂度：</li>
<li>稳定性：不稳定，以为例，该序列经过步长序列的希尔排序得到有序序列为</li>
</ul>
</li>
</ul>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><blockquote>
<p>交换排序是一类借助比较和交换进行排序的犯法。其中交换是指对序列中两个记录的关键字进行比较，如果排序不对则对换两个记录在序列中的位置。交换排序的特点是：将关键字较大的记录向序列的一端移动，而关键字较小的记录向序列的另一端移动。</p>
</blockquote>
<ol>
<li><p>冒泡排序</p>
<blockquote>
<p>冒泡排序也称为起泡排序，是交换排序中常用的排序方法</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>通过对排序元素中相邻元素间的关键字的比较和交换，是关键字最大的元素如气泡一样逐渐“上浮”。</p>
</li>
<li><p>步骤</p>
<ol>
<li>从存储个待排序元素的表尾开始，并令</li>
<li>若，则排序结束</li>
<li>从第一个元素开始进行两两比较，令</li>
<li>若，则冒泡排序结束，；待排序表记录数为-1，转2</li>
<li>比较与，若，则不交换，转7</li>
<li>当时，将和交换</li>
<li>，转4继续比较</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void BubbleSort(SqList &amp;L)</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i = 1; i &lt; L.length; i++)</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int j = 0; j &lt; L.length - i; j++)</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (L.r[j] &gt; L.r[j + 1])</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int t = L.r[j];</span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[j] = L.r[j + 1];</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[j + 1] = t;</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度 总需要进行次冒泡，对个记录的表进行一趟冒泡排序需要次关键字比较，平均的总比较次数为:</li>
</ul>
</li>
</ul>
<pre><code>   - 平均时间复杂度为：
   - 最好情况：
   - 最坏情况：

 - 稳定性：冒泡排序是一种稳定的排序方法。比较是相邻单元进行的，如果关键字值相同则不进行交换。
</code></pre><ol>
<li><p>快速排序</p>
<blockquote>
<p>快速排序也称分区交换排序</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>通过对关键字的比较和交换，以待排序列中的某个数据为支点(或称枢轴量)，将待排序列分成两个部分，其中左半部分小于等于支点，右半部分大于等于支点。然后对左右两部分分别进行快速排序的递归处理，直到整个序列按关键字有序为止。</p>
<p>其中将待排序列按关键字以支点分成两个部分的过程称为<strong>一次划分</strong></p>
</li>
</ul>
</li>
</ol>
<pre><code> 冒泡排序中，元素的比较和移动是在相邻位置进行的，元素比较次数和移动次数较多。 而在快速排序中，元素的比较和移动是从两端向中间进行的，关键字较大的记录一次就能从前面移动到后面，关键字较小的记录一次移动到前面，记录移动的距离较远，从而减少了总的比较次数和移动次数。 可将快速排序看做对冒泡排序的一种改进。
</code></pre><ul>
<li><p>步骤</p>
<ol>
<li>如果待排序子序列中元素的个数等于1，则排序结束；否则以为支点，按如下方法进行一次划分：<ol>
<li>设置两个搜索指针：是向后搜索指针，初始指向序列第一个结点；是向前搜索指针，初始指向最后一个结点；取第一个记录为支点，位暂时取值为支点。</li>
<li>若,枢轴空位确定为，一次划分结束。</li>
<li>若且，则从所指定的位置向前搜索：，重新执行1.3； 否则若有并且有，则设置为新的支点位置。 并交换和，然后令,执行1.4；若，则执行1.2</li>
<li>若且。则从所指的位置开始向后搜索：，重新执行1.4； 否则若由并且有，则设置为新的支点位置， 并交换和，然后令，执行1.3；若，则执行1.2</li>
</ol>
</li>
<li>对支点左半子序列重复1</li>
<li>对支点右半子序列重复1</li>
</ol>
</li>
<li><p>语言描述</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int QSort::Partition(SqList &amp;L, int low, int high)/对序列的一次划分</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int pivotkey;</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[0] = L.r[low];   //用子表的第一个记录作枢轴记录</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pivotkey = L.r[low]; //关键字</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (low &lt; high) //从表的两边交替向中间扫描</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (low &lt; high &amp;&amp; L.r[high] &gt;= pivotkey)</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--high;</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[low] = L.r[high]; //将比枢轴小的记录移至低端</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>16</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (low &lt; high &amp;&amp; L.r[low] &lt;= pivotkey)</span><br></pre></td></tr></table></figure>
<p>17</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>18</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">++low;</span><br></pre></td></tr></table></figure>
<p>19</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>20</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[high] = L.r[low]; //将比枢轴大的记录移至高端</span><br></pre></td></tr></table></figure>
<p>21</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>22</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[low] = L.r[0]; //枢轴记录到位</span><br></pre></td></tr></table></figure>
<p>23</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return low;        //返回枢轴位置</span><br></pre></td></tr></table></figure>
<p>24</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>25</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void QSort::QuickSort1(SqList &amp;L, int low, int high) //按分区对子程序进行调用</span><br></pre></td></tr></table></figure>
<p>26</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>27</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int mid;</span><br></pre></td></tr></table></figure>
<p>28</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (low &lt; high)</span><br></pre></td></tr></table></figure>
<p>29</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>30</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mid = Partition(L, low, high);</span><br></pre></td></tr></table></figure>
<p>31</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QuickSort1(L, low, mid - 1);</span><br></pre></td></tr></table></figure>
<p>32</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QuickSort1(L, mid + 1, high);</span><br></pre></td></tr></table></figure>
<p>33</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>34</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度<ul>
<li>最好情况：每次支点都将待排序划分成两个长度相等的子列时，</li>
<li>最坏情况：每次划分都只得到一个子列时，快速排序的过程类似冒泡排序，</li>
<li>为了避免最坏情况，对快速排序进行一定的改进，改进方法是选取支点时选最左、最右和中间三个元素取值处于中间的元素作为支点。</li>
</ul>
</li>
<li>空间复杂度：</li>
<li>稳定性：以为例，经过快速排序得到有序序列为，因此快速排序是<strong>不稳定</strong>的排序方法</li>
</ul>
</li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote>
<p><strong>选择排序</strong>是一类借助”选择”进行排序的方法</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>每一趟从待排序列中选取一个关键字最小的记录，也即第一趟从个记录中选取关键字最小的记录，第二趟从剩下的个记录中选取关键字最小的记录，直到全部元素排序完毕。</p>
<p>适用于从大量元素中选择一部分排序元素的应用，如从50000个元素中选择前10个关键字最小的元素等。</p>
</li>
</ul>
<ol>
<li><p>简单选择排序</p>
<ul>
<li><p>算法思想</p>
<p>第一趟从个记录中选出关键字最小的记录和第一个记录交换；第二趟从第二个记录开始的个记录中选出关键字最小的记录与第二个记录交换；如此第趟则从第个记录开始的个记录中选出关键字最小的记录与第个记录交换，直到整个序列按关键字有序。</p>
</li>
<li><p>步骤</p>
<blockquote>
<p>注：书上的设置i=1，因为书上默认列表的第一个元素即用来暂存待移动的下标</p>
</blockquote>
<ol>
<li>创建一个辅助变量用于存放每次遍历关键字最小记录的下标，设指变量</li>
<li>遍历第个记录到第个记录。选这一个关键字最小的记录，将其下标保存指中</li>
<li>若第个记录的关键字小于中保存的记录的关键字，则交换这两个记录</li>
<li>，若，则执行2；否则排序结束</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void QSort::SSelectionSort(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">    int t, j;</span><br><span class="line">    for (int x = 0; x &lt;= L.length - 1; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = x;</span><br><span class="line">        for (int y = x; y &lt;= L.length - 1; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (L.r[y] &lt; L.r[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (x != j)</span><br><span class="line">        &#123;</span><br><span class="line">            t = L.r[x];</span><br><span class="line">            L.r[x] = L.r[j];</span><br><span class="line">            L.r[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：总比较次数为：，</li>
<li>空间复杂度：</li>
<li>稳定性：简单选择排序是稳定的排序方法</li>
</ul>
</li>
</ul>
<ol>
<li><p>树形选择排序</p>
<blockquote>
<p><strong>树形选择排序</strong>又称<strong>锦标赛排序</strong>，它是一种按照锦标赛的思想设计的选择排序方法</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>将个参赛选择完全视为完全二叉树的叶子结点，则该完全二叉树有或个结点。首先，叶子结点进行两两比较，胜出(关键字较小者胜出)的结点在在兄弟结点之间再两两比较，直至产生第一名；接下来将作为第一名的结点视为最差的，并从该结点开始，沿该结点到根路径上，依次进行各分支结点孩子之间的比较，胜出的就是第二名(因为和它比赛的均是刚刚输给第一名的结点)。这样继续下去，直到所有选手的名次排定。</p>
</li>
<li><p>步骤</p>
<ol>
<li>从底层的叶子结点开始，逐层进行兄弟间的比较，关键字较小者上升为双亲结点，直到树根为止。</li>
<li>将树的根结点输出，并将底层叶子结点中的一个值与输出结点值相同的结点设为.</li>
<li>如果输出的结点总数小于初始树的叶子结点个数，则重复步骤1；否则结束排序。</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：树的深度为，进行了次比较，</li>
<li>空间复杂度：</li>
<li>稳定性：树形选择排序是稳定的排序方法</li>
</ul>
</li>
</ul>
<ol>
<li><p>堆排序</p>
<blockquote>
<p>堆排序利用堆的特性进行排序的方法。 堆排序适用于从1000个数据中选出较小的十个数据</p>
</blockquote>
<p>堆：设有个元素的序列,当且仅当满足下述关系之一时：</p>
</li>
</ol>
<p>   其中，，分别称为小顶堆和大顶堆。</p>
<p>   根据堆的性质，它也是完全二叉树，且具有下列性质之一：</p>
<ol>
<li>每个结点的值都小于或等于其左右孩子的值，称之为<strong>小顶堆</strong></li>
<li>每个结点的值都大于或等于其左右孩子的值，称之为<strong>大顶堆</strong></li>
</ol>
<ul>
<li><p>算法思想</p>
<p>首先用待排序列的记录序列构造出一个堆，此时选出了堆中所有记录的最小者为堆顶，随后将它从堆中移走(通常是将堆顶记录和堆中最后一个记录交换)，并将剩余记录在调整成堆，这样又找出了次小的记录，依次类推，直到堆中只有一个记录位置。</p>
</li>
<li><p>步骤</p>
<ol>
<li>i=1，基于顺序表中的元素先建一个小顶堆</li>
<li>将堆顶元素和交换</li>
<li>，若，则再对进行调整，形成新的小顶堆，执行2； 若，则排序结束</li>
</ol>
</li>
</ul>
<pre><code> &gt; 图片的内容没有过关联，只是在网上找的图片示例，便于理解堆排序的过程。

 堆的创建：(按照二叉树顺序放好，对第一个有孩子的结点进行比较)
</code></pre><ul>
<li><p>语言描述</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//堆的建立</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void HeapAdjust(SqList &amp;L, int s, int m) //对顺序表做查找，从值最小的孩子结点向下筛选，找到最小值</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int rc = L.r[s];</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int j = 2 * s; j &lt;= m; j *= 2)</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (j &lt; m &amp;&amp; L.r[j] &gt;= L.r[j + 1])</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">j++;</span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (rc &lt; L.r[j])</span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">break;</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[s] = L.r[j];</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = j;</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[s] = rc;</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//完整的堆排序</span><br></pre></td></tr></table></figure>
<p>17</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void HeapSort(SqList &amp;L) //对顺序表L进行堆排序</span><br></pre></td></tr></table></figure>
<p>18</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>19</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int value;</span><br></pre></td></tr></table></figure>
<p>20</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i;</span><br></pre></td></tr></table></figure>
<p>21</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (i = L.length / 2; i &gt; 0; i--) //把L.r[1...L.length]调整为小顶堆</span><br></pre></td></tr></table></figure>
<p>22</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HeapAdjust(L, i, L.length);</span><br></pre></td></tr></table></figure>
<p>23</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (i = L.length; i &gt; 1; i--)</span><br></pre></td></tr></table></figure>
<p>24</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>25</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value = L.r[1];</span><br></pre></td></tr></table></figure>
<p>26</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[1] = L.r[i];</span><br></pre></td></tr></table></figure>
<p>27</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[i] = value;</span><br></pre></td></tr></table></figure>
<p>28</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HeapAdjust(L, 1, i - 1);</span><br></pre></td></tr></table></figure>
<p>29</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>30</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：建堆需要，每次取完顶堆进行调整需要的时间为，且过程经过次，总的时间复杂度：</li>
<li>空间复杂度：</li>
<li>稳定性：不稳定的排序方法</li>
</ul>
</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><strong>归并排序</strong>是借助归并进行排序的方法。</p>
<p>归并的含义：将两个或两个以上的有序序列归并成一个有序序列的过程。</p>
<p>归并排序按所合并的表的个数分为：二路归并排序和多路归并排序</p>
<ul>
<li><p>二路归并排序</p>
<ul>
<li><p>算法思想</p>
<p>将待排序的个元素看成是个有序的子序列，每个子序列的长度为1，然后两两归并，得到个长度为2或1(最后一个有序序列长度可能为1)的有序子序列；再两两归并，得到个长度为4或小于4(最后一个有序序列长度可能小于4)的有序子序列;再两两归并，直至得到一个长度为的有序序列</p>
</li>
<li><p>步骤</p>
<ol>
<li>将待排序序列划分为两个长度相当的子序列</li>
<li>若子序列长度大于1，则对子序列执行一次归并排序</li>
<li>执行下列步骤对子序列两两合并成有序序列<ol>
<li>创建一个辅助数组。假设两个子列的长度分别为，两个子列的下标为。设置两个子表的起始下标和辅助数组的起始下标：</li>
<li>若h或，说明其中一个子表已经合并完毕，直接执行3.4</li>
<li>选取和中关键字较小的存入辅助数组:若，则否则，返回执行3.2</li>
<li>尚未处理完的子表元素与此存入，结束合并，并将结果返回。</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>语言描述</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//一趟归并排序</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Merge(int *SR, int *TR, int i, int m, int n)</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int j, k;</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (j = m + 1, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++) //将SR中的记录由大到小并入TR</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (SR[i] &lt;= SR[j])</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TR[k] = SR[i++];</span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">else</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TR[k] = SR[j++];</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>17</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (i &lt;= m) //将剩余的SR[i...m]赋值到TR</span><br></pre></td></tr></table></figure>
<p>18</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>19</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int a = i; a &lt;= m; a++)</span><br></pre></td></tr></table></figure>
<p>20</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>21</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TR[k++] = SR[a];</span><br></pre></td></tr></table></figure>
<p>22</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>23</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>24</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">else if (j &lt;= n) //将剩余的SR[j...n]赋值到TR</span><br></pre></td></tr></table></figure>
<p>25</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>26</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int b = j; b &lt;= n; b++)</span><br></pre></td></tr></table></figure>
<p>27</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>28</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TR[k++] = SR[b];</span><br></pre></td></tr></table></figure>
<p>29</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>30</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>31</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>32</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//归并排序递归算法</span><br></pre></td></tr></table></figure>
<p>33</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void MergeSort(int *SR, int *TR1, int s, int t)</span><br></pre></td></tr></table></figure>
<p>34</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>35</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int TR2[100];</span><br></pre></td></tr></table></figure>
<p>36</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int m;</span><br></pre></td></tr></table></figure>
<p>37</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (s == t)</span><br></pre></td></tr></table></figure>
<p>38</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>39</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TR1[s] = SR[s];</span><br></pre></td></tr></table></figure>
<p>40</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>41</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">else</span><br></pre></td></tr></table></figure>
<p>42</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>43</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m = (s + t) / 2;</span><br></pre></td></tr></table></figure>
<p>44</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MergeSort(SR, TR2, s, m);</span><br></pre></td></tr></table></figure>
<p>45</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MergeSort(SR, TR2, m+1, t);</span><br></pre></td></tr></table></figure>
<p>46</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Merge(TR2,TR1,s,m,t);</span><br></pre></td></tr></table></figure>
<p>47</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>48</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：</li>
<li>空间复杂度：</li>
<li>稳定性：归并排序是稳定的排序算法</li>
</ul>
</li>
<li><p>Ex:{49,38,65,97,76,13,27}</p>
<ol>
<li>看成一个关键字的子序列</li>
<li>第一趟两两归并：{38,49}，{65,97}，{13,76}，{27}</li>
<li>第二趟：{38,49,65,97},{13,27,79}</li>
<li>第三趟：13,27,38,49,95,76,97</li>
</ol>
</li>
</ul>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><strong>基数排序</strong>不利用关键字之间的比较和移动操作来进行排序，而是通过多关键字排序的思想，根据关键字每个位上的有效数字的取值，借助分配和收集两种操作对单关键字进行排序。</p>
<ol>
<li><p>多关键字的排序</p>
<blockquote>
<p><strong>多关键字排序</strong>是应用在多关键字的序列上的排序方法，最常见的多关键字序列的排序方法是<strong>最低优先法</strong></p>
</blockquote>
<ul>
<li><p>最低优先法的算法思想</p>
<p>首先按照最低位进行排序，再对高一位关键字进行排序，一次类推直到所有关键字都排序完毕。</p>
</li>
<li><p>Example</p>
<p>代表性的例子就是扑克牌的排序。可以将扑克牌的52张牌按花色和值分成两个关键字，其关系如下：</p>
<ul>
<li>花色：梅花方块红桃黑桃</li>
<li>值： 且花色的关键字等级高于值关键字。 花色相同时，才根据值确定大小。</li>
</ul>
</li>
</ul>
</li>
<li><p>链式基数排序</p>
<blockquote>
<p>对于单关键字的序列，也可以通过将关键字拆分成若干项，每一项都看作是一个新的关键字，则可以利用上述多关键字排序的方法对单关键字的序列进行排序。如对于一个2位的整数，可以将其按照位数拆分为2项。这样拆分后，每个关键字的范围都相同，这样关键字可以出现的符号个数称为”基”,例如，二进制数的基是2，十进制数的基是10。基于这样的设定，可以通过多关键字排序的方法方便地进行单关键字序列排序。</p>
</blockquote>
<p>链式基数排序：采用单链表作为分配的”容器”.</p>
<ul>
<li><p>步骤</p>
<ol>
<li>建立待排序序列的静态链表和分配记录用的若干个单链表</li>
<li>从最低位关键字开始，按关键字将中记录分配到各个单链表中</li>
<li>按照关键字的值从小到大从各个单链表中收集记录到静态链表中，重复Step2直至排序完成。</li>
</ol>
</li>
<li><p>Example</p>
<p>例如：给定8个2位的十进制数序列：49,39,65,97,76,13,27,69，采用链式基数排序的过程如下。</p>
</li>
</ul>
</li>
</ol>
<pre><code> 方法：设置若干桶，因十进制分别有数字：，因此其基为10。设置十个桶，分别用进行标识。排序分两步：位数字相同的数放入同一个桶。

 1. 分配：将右起第位数字相同的数放入同一桶。比如数字为1者(若位数不同则左边补0),将其看成01，放入桶。其余类推
 2. 收集：按的顺序进行收集。 重复1,2从最右位直到最左位共2次。
</code></pre><ul>
<li><p>语言描述</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RADIX 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ArrType[RADIX];</span><br><span class="line">ArrType f, e;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLCell</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *keys; <span class="comment">//关键字</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SLCell *SList;</span><br><span class="line">    <span class="keyword">int</span> keynum; <span class="comment">//记录当前关键字个数</span></span><br><span class="line">    <span class="keyword">int</span> recnum; <span class="comment">//记录当前静态链表的长度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Distrbute</span><span class="params">(SLCell *r, <span class="keyword">int</span> i, ArrType &amp;f, ArrType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; RADIX; j++)</span><br><span class="line">        f[j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = r[<span class="number">0</span>].next; a; a = r[a].next)</span><br><span class="line">    &#123;</span><br><span class="line">        j = r[a].keys[i];</span><br><span class="line">        <span class="keyword">if</span> (!f[j])</span><br><span class="line">            f[j] = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r[e[j]].next = a;</span><br><span class="line">        e[j] = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//收集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Collect</span><span class="params">(SLCell *r, <span class="keyword">int</span> i, ArrType &amp;f, ArrType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; !f[j]; j++)</span><br><span class="line">        ;             <span class="comment">//找到第一个非空子集</span></span><br><span class="line">    r[<span class="number">0</span>].next = f[j]; <span class="comment">//r[0].next 指向第一个非空子表中第一个结点</span></span><br><span class="line">    <span class="keyword">int</span> t = e[j];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; RADIX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j++; j &lt; RADIX - <span class="number">1</span> &amp;&amp; !f[j]; j++)</span><br><span class="line">            ; <span class="comment">//找下一个非空子集</span></span><br><span class="line">        <span class="keyword">if</span> (f[j])</span><br><span class="line">        &#123;</span><br><span class="line">            r[t].next = f[j];</span><br><span class="line">            t = e[j]; <span class="comment">//链接两个非空子表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r[t].next = <span class="number">0</span>; <span class="comment">//t指向最后一个非空子表的左后一个结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(SLList &amp;SL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = SL.keynum; i &gt;= <span class="number">1</span>; i--) <span class="comment">//按最高位优先依次对各关键字进行分配收集</span></span><br><span class="line">    &#123;</span><br><span class="line">        Distrbute(SL.SList, i, f, e); <span class="comment">//第i趟分散</span></span><br><span class="line">        Collect(SL.SList, i, f, e);   <span class="comment">//第i趟收集</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：设待排序列有个记录，个关键字，每个关键字的取值范围(基)为,进行一趟分配的时间复杂度为，一趟收集的时间复杂度为，总共要进行趟分配和收集，因此链式基数排序的时间复杂度为</li>
<li>空间复杂度：链式基数排序需要个指向队列的辅助空间，且需要个用于静态链表的指针，因此空间复杂度</li>
<li>稳定性：链式基数排序是稳定的排序方法</li>
</ul>
</li>
</ul>
<h3 id="各种内部排序方法的比较"><a href="#各种内部排序方法的比较" class="headerlink" title="各种内部排序方法的比较"></a>各种内部排序方法的比较</h3><ol>
<li>快速排序、堆排序、归并排序的平均时间复杂度最好。</li>
<li>直接插入排序思路明了、算法简单，是一种常用的排序算法。</li>
<li>基数排序的时间复杂度为，因此党待排序列的记录数量很大且关键字长度很小时，其时间性能好。</li>
<li>从空间复杂度上看，大多数排序算法的辅助空间为。但快速排序和归并排序例外，分别为和。而基数排序的空间复杂度和关键字的数量和基有关。</li>
<li>从稳定性上讲，属于稳定性算法的有直接插入排序、简单选择排序、归并排序和基数排序，属于不稳定排序算法的有希尔排序、快速排序和堆排序。</li>
<li>从算法本身的复杂度上看，直接插入排序、简单选择排序比较容易理解，属于简单算法，其时间性能理论上较差；而另一类像希尔排序、快速排序、堆排序和归并排序这样较为复杂的算法，属于改进算法，时间性能理论上较好。</li>
<li>从待排记录个数来看，当越小，采用简单排序算法更为合适，当很大时，采用改进算法更为合适。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>排序算法</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>平均情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>希尔排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>快速排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>简单选择排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>堆排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>归并排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基数排序</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><blockquote>
<p>对于一个规模为n的问题，若问题比较容易解决(比如规模n较小)，则直接解决，否则将该问题分割为k个规模较小的子问题，这些子问题互相独立且与原问题的形式相同，递归的解决这些子问题，然后将各个子问题的解合并到原问题的解，这就是分治法。</p>
</blockquote>
<ul>
<li><p>基本思想</p>
<p>“分治”就是“分而治之”，即将一个难以解决的大问题分割成若干个规模较小的子问题，以便各个击破，分而治之。</p>
<p>分治法是很多算法的基础，如快速排序、归并排序等排序算法，以及傅里叶变换。</p>
</li>
</ul>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><blockquote>
<p><strong>回溯法</strong>可以系统地搜索问题的所有解，是一个具有系统性和跳跃性的算法。</p>
</blockquote>
<p>如搜索问题和优化问题，它们的解分布在一个<strong>解空间</strong>里，求解这些问题的算法就是一种遍历搜索解空间的系统方法，所以解空间又称为<strong>搜索空间</strong>。</p>
<p>回溯法将搜索空间看成树形结构，一个问题的解对应树中的一个叶子结点。</p>
<ul>
<li>基本思想<ul>
<li>回溯法在问题的解空间中，按照深度优先策略，从根结点出发搜索解空间树。</li>
<li>算法搜索至解空间的任一结点，先判断该结点是否包含问题的解。<ul>
<li>如果不包含，则跳过对该结点为根的子树的搜索，逐层向其祖先结点回溯；</li>
<li>否则，进入该子树，继续进行深度优先策略搜索。</li>
</ul>
</li>
<li>回溯法求问题的所有解时，要回溯到根结点，且根结点所有子树都被搜索完才算结束。</li>
</ul>
</li>
</ul>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><blockquote>
<p><strong>贪心算法</strong>是一种通用的算法设计方法，在许多<strong>最优化问题</strong>求解中得到了广泛应用，例如求图的最小生成树的Prim算法和Kruskal算法，单源最短路径的Dijkstra算法，数据压缩的Huffman算法</p>
</blockquote>
<p>贪心算法和动态规划算法一样，常用于求解最优化问题，即量的最大化或最小化。</p>
<ul>
<li><p>基本思想</p>
<p>贪心算法的求解是一个多步决策的过程，每步决策不考虑子问题的计算结果，而是经过少量的计算，根据当前情况做出取舍，这样一步步地构筑解，每一步均建立在局部最优解的基础上，同时又扩大了局部解的规模。</p>
<p>贪心选择：每一个选择都是当前状态下局部的最好选择</p>
</li>
<li><p>贪心算法的性质</p>
<p>贪心算法求解问题，一般具有两个性质：贪心选择性质和最优子结构性质</p>
<ul>
<li><p>贪心选择性质</p>
<p>贪心选择性质是指所求问题的整体最优解可以通过一系列的局部最优的选择(贪心选择)来达到，它采用自顶向下的方式将所求问题简化为规模更小的子问题。</p>
</li>
<li><p>最优子结构性质</p>
<p>当一个问题的最优解包括其子问题的最优解时，称此问题具有最优子结构性质</p>
</li>
</ul>
</li>
</ul>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><blockquote>
<p>动态规划：是一种将问题实例分解为更小的、相似的子问题，并存储子问题的解而避免重复计算的子问题，以解决最优化问题的算法策略。</p>
</blockquote>
<ul>
<li><p>基本思想</p>
<p>与分治法类似，将带求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适用于动态规划求解的问题，经分割得到的子问题往往不是互相独立的。若用分治法解决这些问题，分割的子问题数目太多，以致最后解决原问题需要耗费的指数时间。</p>
<p>在使用分治法求解时，有些子问题被重复计算多次。若保存已解决的子问题的答案，在需要时找出已求出的答案，可以避免大量重复计算，从而得到多项式时间的算法，这就是动态规划的基本思想。</p>
</li>
<li><p>设计步骤</p>
<ol>
<li>找出最优解的性质，并刻画其结构特征</li>
<li>递归的定义最优值</li>
<li>自底向上的方式计算得出最优值</li>
<li>根据计算最优值时得到的信息构造最优解</li>
</ol>
<p>步骤1-3是动态规划算法的基本步骤。</p>
<p>若只需求出最优值，则步骤4可以省略。 若需求出问题的最优解，则必须执行步骤4，此时，在步骤3中计算最优值，通常需要记录更多的信息，以便在步骤4中，能够根据记录的信息快速构造出最优解。</p>
</li>
</ul>
<p>动态规划算法解决的问题需要一定条件：最优化原理(最优子结构性质)和子问题的重叠性。</p>
<ul>
<li><p>条件</p>
<ul>
<li><p>最优化原理(最优子结构性质)</p>
<p>一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理称起具有最优子结构性质。</p>
</li>
<li><p>子问题的重叠性</p>
<p>对于重复出现的子问题，只在第一次遇到时加以求解，并把答案保存起来，让以后再遇到时直接引用，不必重新求解。</p>
</li>
</ul>
</li>
</ul>
<h3 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h3><blockquote>
<p><strong>分支限界法</strong>类似回溯法，都是在解空间树上搜索问题的解，也可以看做是回溯法的改进。回溯法是在整个状态空间树中搜索解，并用约束条件判断搜索过程，一旦发生不可能产生问题的不分解，就终止对相应子树的搜索，从而避免不必要的工作。</p>
</blockquote>
<p>分支限界法和回溯在两个方法存在差异：控制条件和搜索方式</p>
<ul>
<li><p>控制条件</p>
<p>回溯法一般使用约束条件产生部分解。若满足约束条件，则继续扩大解；否则丢弃，重新搜索。 分支限界法中，除了使用约束函数外，还使用更有效的评判函数——目标函数控制搜索进行，从而能够尽快得到最优解。</p>
</li>
<li><p>搜索方式</p>
<p>回溯法中的搜索一般是以深度优先的方式进行，而分支限界法中一般以广度优先方式进行搜索。</p>
</li>
<li><p>基本思想</p>
<p>略</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>动态时间调整</title>
    <url>/2019/11/26/DTW%E5%8A%A8%E6%80%81%E6%97%B6%E9%97%B4%E8%B0%83%E6%95%B4/</url>
    <content><![CDATA[<h1 id="动态时间调整"><a href="#动态时间调整" class="headerlink" title="动态时间调整"></a>动态时间调整</h1><blockquote>
<p><code>DTW</code>能够衡量这两个序列的相似程度，或者说两个序列的距离。同时<code>DTW</code>能够对两个序列的延展或者压缩能够有一定的适应性，举个例子，不同人对同一个词语的发音会有细微的差别，特别在时长上，有些人的发音会比标准的发音或长或短，<code>DTW</code>对这种序列的延展和压缩不敏感，所以给定标准语音库，<code>DTW</code>能够很好得识别单个字词，这也是为什么<code>DTW</code>一直被认为是语音处理方面的专门算法。实际上，<code>DTW</code>虽然老，但简单且灵活地实现模板匹配，能解决很多离散时间序列匹配的问题，视频动作识别，生物信息比对等等诸多领域都有应用。</p>
</blockquote>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ol>
<li>根据给定样本序列和比对序列，计算序列点之间的欧式距离，生成序列距离矩阵。</li>
<li>根据距离矩阵生成损失矩阵（累积距离矩阵）<ol>
<li>第一行第一列元素为 距离矩阵的第一行第一列元素；</li>
<li>其他位置的元素 $(M_c(i,j)M_c(i,j))$的值则需要逐步计算，具体值的计算方法为 $M_c(i,j)=M(i,j)+\min(M_c(i−1,j−1),M_c(i−1,j),M_c(i,j−1))$。</li>
<li>两个序列的距离为损失矩阵最后一行最后一列给出。</li>
</ol>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 动态时间调整</span></span><br><span class="line">X = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">1</span>]</span><br><span class="line">Y = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">n, m = len(X), len(Y)</span><br><span class="line"></span><br><span class="line">matrix = [[<span class="number">0</span>]*m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">        matrix[i][j] = abs(X[i]-Y[j])</span><br><span class="line">        </span><br><span class="line">mat_coss = [[<span class="number">0</span>]*m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    mat_coss[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">    mat_coss[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">        mat_coss[i][j] = matrix[i][j] + min(mat_coss[i<span class="number">-1</span>][j<span class="number">-1</span>],mat_coss[i<span class="number">-1</span>][j],mat_coss[i][j<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">print(<span class="string">f'X和Y之间的距离为:<span class="subst">&#123;mat_coss[n<span class="number">-1</span>][m<span class="number">-1</span>]&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>编辑距离算法</title>
    <url>/2019/11/26/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="编辑距离-Edit-Distance"><a href="#编辑距离-Edit-Distance" class="headerlink" title="编辑距离 Edit Distance"></a>编辑距离 Edit Distance</h1><blockquote>
<p>指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。又称<code>Levenshtein</code>距离</p>
</blockquote>
<p>三种基本操作：插入，删除，替换</p>
<h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><ol>
<li>A和B的长度为0返回另一个字符串的长度。</li>
<li>初始化矩阵，shape：(n+1)(m+1)，第一行和第一列从0开始增长，如果A[i]==B[j]，temp=0，否则为1.然后在矩阵<code>mat[i][j]</code>中赋值为<code>mat[i-1][j]+1,mat[i][j-1]+1,mat[i-1][j-1]+temp</code>三者中的最小值，这三个操作分别对应插入、删除、替换。</li>
</ol>
<p>3.扫描完后，返回矩阵的最后一个值<code>mat[n][m]</code>即是它们的距离。</p>
<p>相似度公式:$\frac{1-mat[n][m]}{\max(n,m)}$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>C</th>
<th>o</th>
<th>w</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>C</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>a</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>t</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑距离算法</span></span><br><span class="line">A = <span class="string">'Cat'</span></span><br><span class="line">B = <span class="string">'Cow'</span></span><br><span class="line"></span><br><span class="line">n, m = len(A)+<span class="number">1</span>, len(B)+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">matrix = [[<span class="number">0</span>]*m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    matrix[i][<span class="number">0</span>] = i</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">    matrix[<span class="number">0</span>][j] = j</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">        tmp = <span class="number">0</span> <span class="keyword">if</span> A[i<span class="number">-1</span>] == B[j<span class="number">-1</span>] <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        matrix[i][j] = min(matrix[i<span class="number">-1</span>][j]+<span class="number">1</span>, matrix[i]</span><br><span class="line">                           [j<span class="number">-1</span>]+<span class="number">1</span>, matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]+tmp)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'编辑距离:<span class="subst">&#123;matrix[n<span class="number">-1</span>][m<span class="number">-1</span>]&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'相似度:<span class="subst">&#123;<span class="number">1</span>-matrix[n<span class="number">-1</span>][m<span class="number">-1</span>]/max(n<span class="number">-1</span>,m<span class="number">-1</span>)&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://blog.csdn.net/chichoxian/article/details/53944188" target="_blank" rel="noopener">https://blog.csdn.net/chichoxian/article/details/53944188</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>DSP基础知识</title>
    <url>/2019/11/26/DSP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="数字信号处理"><a href="#数字信号处理" class="headerlink" title="数字信号处理"></a>数字信号处理</h1><blockquote>
<p>记录DSP的一些概念和理论知识</p>
</blockquote>
<ul>
<li><p>信号：随着时间、空间或其他自变量而变化的物理量。</p>
<p>数学描述：</p>
<script type="math/tex; mode=display">
s_1(t) = 5t \\
s_2(t)=20t^2 \\
s(x,y)=3x+2xy+10y^2</script><p>可以存在多个自变量，如表示平面空间上的坐标。</p>
<p>上面描述的信号属于一类准确定义的信号，指定了对于自变量的函数依赖关系。</p>
<p>但是有些情况下的函数关系是未知的或太复杂以至于难以使用。</p>
<p>例如，某种语音信号无法用上面的表达式函数进行描述。</p>
<p>一般来说，一段语音可被高精度的表示为几种不同幅度和频率的总和，即</p>
<script type="math/tex; mode=display">
\sum_{i=1}^N A_i(t) \sin[2\pi F_i(t)t+\theta_i(t)]</script><p>其中，$|A_i(t)|,|F_i(t)|,|\theta_i(t)|$分别是正弦信号的(可能时变的)幅度、频率和相位的集合。</p>
</li>
<li><p>生成信号：通常和某系统相关联，以对某些刺激或压力作出响应。</p>
</li>
<li><p>信号处理的含义从有用信号中对噪声和干扰信号进行滤波。</p>
</li>
<li><p>模数(A/D)转换器：模拟信号和数字处理器之间的接口，输出数字信号，作为数字处理器的输入。</p>
</li>
<li><p>数模(D/A)转换器：数字域到模拟域的接口，将信号以模拟的形式提供给用户。</p>
</li>
<li><p>数字信号处理的优点：灵活配置、精度高、存储方便、价格便宜。</p>
</li>
<li><p>数字处理的局限性：受限于A/D转换器和数字信号处理器的运算速度。</p>
</li>
<li><p>多通道信号：采用矢量表示信号。</p>
</li>
<li><p>多维信号：多个自变量的函数。单个自变量的函数称为一维信号。</p>
</li>
<li><p>连续时间信号：模拟信号，在每个时间值上有定义且在一个连续的区间内取值的信号。数学上可采用一个连续变量的函数描述。</p>
</li>
<li><p>离散时间信号：定义在某些特定的时间值上，时间点不需要是等距的，实际上为了简单和数学易于处理，通常等间隔取值。</p>
</li>
<li><p>采样：在离散时间点上选择模拟信号值。</p>
</li>
<li><p>连续值信号：信号的值是连续的。信号在一个有限或无限范围内取所有可能的值。</p>
</li>
<li><p>离散值信号：信号的值是离散的。信号只在可能取值的有限集上取值。</p>
</li>
<li><p>量化：将连续值信号转化为离散值信号的过程，基本上是一个近似过程。量化可以只通过四舍五入或截断完成。</p>
</li>
<li><p>确定性信号：任何可以被一个显式数学表达式、一个数据表或者一个定义好的规则所唯一描述的信号。强调信号的过去、现在、将来的所有取值可以准确知道，不存在任何不确定性。</p>
</li>
<li><p>随机信号：无法被数学公式显式表达到一个合理的精度或这描述太复杂以至于没有实际用处，在时间轴上以不可知的方式展开。例如噪声生成器的输出、地震信号、语音信号。</p>
</li>
<li><p>随机信号的理论分析基于概率论和随机过程。</p>
</li>
<li><p>欧拉公式：$e^{ix}=\cos x + i\sin x$，i是复数单位。</p>
</li>
<li><p>能量信号和功率信号</p>
<ul>
<li>离散时间信号$x(n)$的能量$E \equiv \sum_{n=-\infty}^\infty |x(n)|^2$</li>
<li>离散时间信号的平均功率：$P=\lim<em>{N \rightarrow \infty} \frac{1}{2N+1} \sum</em>{n=-N}^N |x(n)|^2$</li>
<li>有限区间$-N \le n \le N$内定义的信号能量$E<em>N= \sum</em>{n=-N}^N |x(n)|^2$</li>
</ul>
</li>
<li><p>周期信号和非周期信号</p>
<ul>
<li>信号$x(n)$是周期为$N(N\gt 0)$的周期信号当且仅当$x(n+N)=x(n)$</li>
</ul>
</li>
<li><p>对称(偶)和反对称(奇)信号</p>
<ul>
<li>$x(-n)=x(n)$</li>
<li>$x(-n)=-x(n)$</li>
</ul>
</li>
<li><p>因果系统和非因果系统</p>
</li>
<li><p>稳定系统与不稳定系统</p>
</li>
</ul>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>pacman常用命令</title>
    <url>/2019/11/26/pacman%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="pacman-常用命令"><a href="#pacman-常用命令" class="headerlink" title="pacman 常用命令"></a>pacman 常用命令</h1><h2 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h2><p>在 Archlinux 中，使用一条命令即可对整个系统进行更新：<br> <code>pacman -Syu</code><br> 如果你已经使用<code>pacman -Sy</code>将本地的包数据库与远程的仓库进行了同步，也可以只执行：<code>pacman -Su</code></p>
<h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><ul>
<li><code>pacman -S 包名</code>：例如，执行 <code>pacman -S firefox</code> 将安装 Firefox。你也可以同时安装多个包，只需以空格分隔包名即可。</li>
<li><code>pacman -Sy</code> 包名：与上面命令不同的是，该命令将在同步包数据库后再执行安装。</li>
<li><code>pacman -Sv 包名</code>：在显示一些操作信息后执行安装。</li>
<li><code>pacman -U</code>：安装本地包，其扩展名为 pkg.tar.gz。</li>
<li><code>pacman -U http://www.example.com/repo/example.pkg.tar.xz</code> 安装一个远程包（不在 pacman 配置的源里面）</li>
</ul>
<h2 id="删除包"><a href="#删除包" class="headerlink" title="删除包"></a>删除包</h2><ul>
<li><code>pacman -R 包名</code>：该命令将只删除包，保留其全部已经安装的依赖关系</li>
<li><code>pacman -Rs 包名</code>：在删除包的同时，删除其所有没有被其他已安装软件包使用的依赖关系</li>
<li><code>pacman -Rsc 包名</code>：在删除包的同时，删除所有依赖这个软件包的程序</li>
<li><code>pacman -Rd 包名</code>：在删除包时不检查依赖。</li>
</ul>
<h2 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h2><ul>
<li><code>pacman -Ss 关键字</code>：在仓库中搜索含关键字的包。</li>
<li><code>pacman -Qs 关键字</code>： 搜索已安装的包。</li>
<li><code>pacman -Qi 包名</code>：查看有关包的详尽信息。</li>
<li><code>pacman -Ql 包名</code>：列出该包的文件。</li>
</ul>
<h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><ul>
<li><code>pacman -Sw 包名</code>：只下载包，不安装。</li>
<li><code>pacman -Sc</code>：清理未安装的包文件，包文件位于 <code>/var/cache/pacman/pkg/</code> 目录。</li>
<li><code>pacman -Scc</code>：清理所有的缓存文件。</li>
</ul>
<h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h2><ul>
<li><a href="https://www.jianshu.com/p/ea651cdc5530" target="_blank" rel="noopener">https://www.jianshu.com/p/ea651cdc5530</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>基础机器学习公式</title>
    <url>/2019/11/25/%E5%9F%BA%E7%A1%80%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="机器学习-Formula"><a href="#机器学习-Formula" class="headerlink" title="机器学习 Formula"></a>机器学习 Formula</h1><h2 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h2><ol>
<li><p>The Least Mean Square (<strong>LMS</strong>) Algorithm</p>
<script type="math/tex; mode=display">
h_\theta(x) = \sum_{i=1}^{n}\theta_i x_i = \theta^T xParameters</script><ul>
<li>Parameters <script type="math/tex; mode=display">
\theta</script></li>
</ul>
</li>
</ol>
<ul>
<li>Cost function</li>
</ul>
<script type="math/tex; mode=display">
   \begin{split}
   J_l(\theta) & = \frac{1}{2} \sum_{i=1}^{m} (h_\theta(x^{(i)})-y^{(i)})^2 \\
   & = \frac{1}{2} \sum_{i=1}^{m} (\theta^T x^{(i)}-y^{(i)})^2
   \end{split}</script><ul>
<li>Goal</li>
</ul>
<script type="math/tex; mode=display">
   \theta^*=arg_\theta \; minJ_l(\theta)</script><ol>
<li><p>Close-form Solution of LMS</p>
<script type="math/tex; mode=display">
J_l(\theta) = \frac{1}{2} \sum_{i=1}^{m} (h_\theta(x^{(i)})-y^{(i)})^2 = \frac{1}{2}(X\theta - y)^T(X\theta - y)</script><script type="math/tex; mode=display">
\begin{split}
\nabla_\theta J(\theta) &= \nabla_\theta \frac{1}{2} (X\theta - y)^T(X\theta - y)\\
& = \frac{1}{2} \nabla_\theta (\theta^TX^TX\theta - \theta^TX^Ty - y^TX\theta + y^Ty) \\
& = \frac{1}{2} \nabla_\theta tr(\theta^TX^TX\theta - \theta^TX^Ty - y^TX\theta + y^Ty) \\
& = \frac{1}{2} \nabla_\theta (tr\theta^TX^TX\theta - 2tr\theta^TX\theta) \\
& = X^TX\theta - X^Ty
\end{split}</script><script type="math/tex; mode=display">
\theta^* = (X^TX)^{-1}X^Ty</script></li>
<li><p>Gradient Descent for Linear Regression</p>
<ul>
<li>Gradient<script type="math/tex; mode=display">
\begin{split}
\frac{\partial J_l(\theta)}{\partial \theta} & = \frac{1}{2}\frac{\partial}{\partial \theta}\sum_{i=1}^{n} (h_\theta (x^{(i)}) - y^{(i)})^2 \\
& = \frac{1}{2} 2 \sum_{i=1}^n (h_\theta (x^{(i)}) - y^{(i)}) \frac{\partial}{\partial \theta}(h_\theta (x^{(i)}) - y^{(i)}) \\
& = \sum_{i=1}^n (h_\theta (x^{(i)}) - y^{(i)}) \frac{\partial}{\partial \theta}(\theta^T x^{(i)}) \\
& = \sum_{i=1}^n (h_\theta (x^{(i)}) - y^{(i)})x^{(i)}
\end{split}</script></li>
</ul>
</li>
</ol>
<ul>
<li>Gradient Descent (GD) Optimization<script type="math/tex; mode=display">
   \theta: = \theta - \alpha\frac{\partial}{\partial \theta} J_l(\theta) = \theta - \alpha \sum_{i=1}^n (h_\theta (x^{(i)}) - y^{(i)})x^{(i)}</script></li>
</ul>
<h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><ul>
<li><p>Sigmoid Function:</p>
<script type="math/tex; mode=display">
\begin{split}
& \delta(z) = \frac{1}{1+e^{-z}} \\
& \frac{d\delta}{dz} = \delta(z)(1-\delta(z))
\end{split}</script></li>
<li><p>Hypothesis</p>
<script type="math/tex; mode=display">
\begin{split}
& p(y=1 | x;\theta) = h_\theta(x) = \delta(\theta^Tx) = \frac{1}{1+e^{-\theta^Tx}} \\
& p(y=0 | x;\theta) = 1 - h_\theta(x)
\end{split}</script><p>or</p>
<script type="math/tex; mode=display">
p(y|x;\theta) = (h_\theta(x))^y(1-h_\theta(x))^{1-y} = (\frac{1}{1+e^{-\theta^Tx}})^y(1-\frac{1}{1+e^{-\theta^Tx}})^{1-y}</script></li>
<li><p>Conditional Likelihood Function</p>
<script type="math/tex; mode=display">
\begin{split}
L(\theta) & = \prod_{i=1}^N p(y^{(i)}|x^{(i)};\theta)\\
& = \prod_{i=1}^N (h_\theta(x^{(i)}))^{y^{(i)}}(1-h_\theta(x^{(i)}))^{(1-y)^{(i)}} \\
& = \prod_{i=1}^N (\frac{1}{1+e^{-\theta^Tx^{(i)}}})^{y^{(i)}}(1-\frac{1}{1+e^{-\theta^Tx^{(i)}}})^{(1-y)^{(i)}}
\end{split}</script></li>
<li><p>Maximum Likelihood Estimation</p>
<script type="math/tex; mode=display">
\max_{\theta} L(\theta) \Leftrightarrow = \max_{\theta} \sum_{i=1}^{n}y^{(i)}\log{}{h_\theta(x^{(i)}) + (1-y^{(i)})\log{}{}}1-h_\theta(x^{(i)})</script><blockquote>
<p> The neg log-likelihood function is also known as the <strong>Cross-Entropy</strong> cost function</p>
</blockquote>
</li>
<li><p>Unconstraint Optimization Methods</p>
<ul>
<li>Gradient Descent</li>
</ul>
</li>
<li><p>Stochastic Gradient Descent</p>
<ul>
<li>Newtom Method</li>
</ul>
</li>
<li><p>Quasi-Newtom Method</p>
<ul>
<li>Conjugate Gradient</li>
</ul>
</li>
<li>waiting….</li>
</ul>
<h2 id="Softmax-Regression"><a href="#Softmax-Regression" class="headerlink" title="Softmax Regression"></a>Softmax Regression</h2><ul>
<li>Softmax Regression is a multi-class classification model, also called Multi-class Logistic Regression;</li>
<li>It is also known as the Maximum Entropy Model (in NLP);</li>
<li>It is one of the most used classification algorithms</li>
</ul>
<h3 id="Model-Description"><a href="#Model-Description" class="headerlink" title="Model Description"></a>Model Description</h3><ul>
<li><p>Model Hypothesis</p>
<script type="math/tex; mode=display">
\begin{split}
& p(y=j|x;\theta) = h_j(x) = \frac{e^{\theta_j^Tx}}{1+\sum_{j^{'}=1}^{c-1}e^{\theta_{j^{'}}^Tx}}, j=1,\dots,C-1 \\
& p(y=C|x;\theta) = h_C(x) = \frac{1}{1+\sum_{j^{'}=1}^{c-1}e^{\theta_{j^{'}}^Tx}}
\end{split}</script></li>
<li><p>Model Hypothesis (Compact Form)</p>
<script type="math/tex; mode=display">
p(y=j|x;\theta) = h_j(x) = \frac{e^{\theta_j^Tx}}{\sum_{j^{'}=1}^{c-1}e^{\theta_{j^{'}}^Tx}}, j=1,\dots,C \quad where \; \theta_C =  \vec{0}</script></li>
<li><p>Parameters</p>
<script type="math/tex; mode=display">
\theta_{C \times M}</script></li>
</ul>
<h3 id="Maximun-Likelihood-Estimation"><a href="#Maximun-Likelihood-Estimation" class="headerlink" title="Maximun Likelihood Estimation"></a>Maximun Likelihood Estimation</h3><p>(Conditional) Log-likelihood</p>
<script type="math/tex; mode=display">
\begin{split}
l(\theta) & = \sum_{i=1}^N \log{p(y^{(i)}|x^{(i)};\theta)} \\
& = \sum_{i=1}^N \log \prod_{j=1}^C \big(\frac{e^{\theta_j^Tx}}{\sum_{j^{'}=1}^{C}e^{\theta_{j^{'}}^Tx}}\big)^{1\{y^{(i)}=j\}} \\
& = \sum_{i=1}^{N}\sum_{j=1}^{C}\bold{1}\{y^{(i)}=j\}\log \big(\frac{e^{\theta_j^Tx}}{\sum_{j^{'}=1}^{C}e^{\theta_{j^{'}}^Tx}}\big)\\
& = \sum_{i=1}^{N}\sum_{j=1}^{C}\bold{1}\{y^{(i)}=j\}\log h_j(x^{(i)})
\end{split}</script>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>矩阵分析与计算</title>
    <url>/2019/11/23/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="矩阵分析与计算回顾"><a href="#矩阵分析与计算回顾" class="headerlink" title="矩阵分析与计算回顾"></a>矩阵分析与计算回顾</h1><blockquote>
<p>回顾矩阵和分析重点知识点和内容</p>
</blockquote>
<h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><ul>
<li>向量范数 $L_1,L_2,L_p$</li>
<li>矩阵范数 $m1,m_\infty,F$</li>
<li>算子范数：极大列和范数，极大行和范数，谱范数</li>
<li>算子范数和矩阵范数的关系</li>
<li>条件范数$cond(A)$在误差估计的应用</li>
<li>正规矩阵，Hermite矩阵（对称举证的推广），酉矩阵（正交矩阵的推广），正定举证</li>
<li>距离，赋范线性空间</li>
</ul>
<h2 id="矩阵的特征值"><a href="#矩阵的特征值" class="headerlink" title="矩阵的特征值"></a>矩阵的特征值</h2><ul>
<li><p>Smith标准型</p>
</li>
<li><p>$\lambda$-矩阵，不变因子，行列式因子，初等因子</p>
</li>
<li><p>Jordan标准型</p>
</li>
<li><p>盖尔圆，特征值的隔离</p>
</li>
<li><p>幂迭代法，逆幂迭代法 求主特征值和特征向量，以下为幂迭代法的公式</p>
<script type="math/tex; mode=display">
\begin{split}
& u_0 = v_0\\
& v_k = Av_{k-1}\\
& m_k = \max v_k\\
& u_k = \frac{v_k}{m_k}\\
\end{split}</script></li>
</ul>
<h2 id="矩阵分解和广义逆"><a href="#矩阵分解和广义逆" class="headerlink" title="矩阵分解和广义逆"></a>矩阵分解和广义逆</h2><ul>
<li>三角分解，Doolittle 分解</li>
<li>Chomlesky 分解</li>
<li>QR分解</li>
<li>满秩分解</li>
<li>奇异值分解</li>
<li>广义逆</li>
<li>Moore-Penrose 逆的直接解法：满秩分解，奇异值分解</li>
</ul>
<h2 id="矩阵的数值计算"><a href="#矩阵的数值计算" class="headerlink" title="矩阵的数值计算"></a>矩阵的数值计算</h2><ul>
<li>Gauss 消元法，选列主元。</li>
<li>三角分解</li>
<li>平方根，改进平方跟</li>
<li>…</li>
<li>J迭代法，G-S迭代法，SOR迭代法</li>
<li>极小化方法：（将矩阵计算转为泛函极值问题）最速下降法，共轭梯度法</li>
</ul>
<h2 id="最优化方法"><a href="#最优化方法" class="headerlink" title="最优化方法"></a>最优化方法</h2><ul>
<li>单纯形法</li>
<li>K-K-T点求解</li>
<li>最速下降法，牛顿法，阻尼牛顿法，共轭梯度法</li>
<li>罚函数法：外点罚函数，内点罚函数</li>
<li>广义乘子法</li>
</ul>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>常用IDE快捷键</title>
    <url>/2019/11/15/%E5%B8%B8%E7%94%A8IDE%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="常用IDE快捷键"><a href="#常用IDE快捷键" class="headerlink" title="常用IDE快捷键"></a>常用IDE快捷键</h1><h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><ul>
<li>Trigger Suggestion: <code>Ctrl+Space</code></li>
<li>Format document: <code>Ctrl+Shift+I</code></li>
<li>Show Command Palette: <code>Ctrl+Shift+P</code> </li>
<li>Quick Open,Go to File… : <code>Ctrl+P</code></li>
<li>New Window/instance: <code>Ctrl+Shift+N</code></li>
<li>Close Window/instance: <code>Ctrl+W</code></li>
<li>Cut line: <code>Ctrl+X</code></li>
<li>Copy line: <code>Ctrl+C</code></li>
<li>Rename Symbol: <code>F2</code></li>
</ul>
<h2 id="the-Series-of-JetBrains-IDE"><a href="#the-Series-of-JetBrains-IDE" class="headerlink" title="the Series of JetBrains IDE"></a>the Series of JetBrains IDE</h2><ul>
<li>代码自动完成提示：<code>Ctrl+Space</code></li>
<li>显示意图和快速修复：<code>Alt+Enter</code></li>
<li>参数信息：<code>Ctrl+P</code></li>
<li>快速查找文件：<code>Ctrl+Q</code></li>
<li>生成代码：<code>Alt+Insert</code></li>
<li>格式化带啊：<code>Ctrl+Alt+L</code></li>
<li>删除光标所在行：<code>Ctrl+Y</code></li>
<li>复制当前行或选定的块：<code>Ctrl+D</code></li>
<li>开始新行：<code>Shift+Enter</code></li>
<li>历史粘贴：<code>Ctrl+Shift+V</code></li>
<li>运行：<code>Shift+F10</code></li>
<li>从编辑器运行上下文配置：<code>Ctrl+Shift+F10</code></li>
<li>在命令行运行：<code>Ctrl+Shift+X</code></li>
<li>查找/替换：<code>Ctrl+F/R</code></li>
<li>跳转到指定类：<code>Ctrl+N</code></li>
<li>跳转到文件：<code>Ctrl+Shift+N</code></li>
<li>跳转到符号：<code>Ctrl+Alt+Shift+N</code></li>
<li>跳转到第几行：<code>Ctrl+G</code></li>
<li>切换编辑器：<code>Alt+Right/Left</code></li>
<li>弹出最近编辑文件：<code>Ctrl+E</code></li>
<li>搜索任何地方：<code>Shift+Shift</code></li>
<li>查找Action：<code>Ctrl+Shift+A</code></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>优化方法</title>
    <url>/2019/11/14/%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="最优化方法"><a href="#最优化方法" class="headerlink" title="最优化方法"></a>最优化方法</h1><h2 id="最速下降法"><a href="#最速下降法" class="headerlink" title="最速下降法"></a>最速下降法</h2><p>原理：</p>
<p>设目标函数$f(x)$在$x^{(k)}$附近连续可微，令$\nabla f(x^{(k)}) \ne 0$。将$f(x)$在$x^{(k)}$处$Taylor$展开</p>
<script type="math/tex; mode=display">
f(x) = f(x^{(k)})+(\nabla f(x^{(k)})^T(x-x^{(k)})) + o(||x-x^{(k)}||)</script><p>令$x-x^{(k)}=\alpha d^{(k)}$，有</p>
<script type="math/tex; mode=display">
f(x) = f(x^{(k)})+\alpha(\nabla f(x^{(k)})^T d^{(k)} + o(\alpha d^{(k)})</script><p>若$(\nabla f(x^{(k)})^T d^{(k)}\lt 0$，则$d^{(k)}$为下降方向。且由$Cauchy-Schwartz$不等式</p>
<script type="math/tex; mode=display">
|(\nabla f(x^{(k)})^T d^{(k)}| \le \Vert \nabla f(x^{(k)}) \Vert \Vert d^{(k)} \Vert</script><p>有且当且仅当$d^{(k)}=- \nabla f(x^{(k)})$时，$-(\nabla f(x^{(k)})^T d^{(k)}$最大。因而以$-\nabla f(x^{(k)})^T $为下降方向的方法称为最速下降法。其中$\alpha _k$由精确线搜索策略选取。</p>
<p>算法流程：</p>
<ol>
<li><p>给定初始点$x^{(1)} \in R^n$，允许误差$\varepsilon \gt 0$，置$k=1$</p>
</li>
<li><p>计算搜索方向$d^{(k)} = - \nabla f(x^{(k)})$，如果$||\nabla f(x^{(k)})|| \le \epsilon$，停止计算</p>
</li>
<li><p>由精确线搜索计算步长$\alpha _k$，使得</p>
<script type="math/tex; mode=display">
f(x^{(k)}+\alpha_kd^{(k)}) = \min_{\alpha \ge 0}f(x^{(k)}+\alpha d^{(k)})</script></li>
<li><p>令$x^{(k+1)} = x^{(k)} + \alpha_k d^{(k)}$，令$k = k +1$，转步骤2</p>
</li>
</ol>
<p>特点：</p>
<ul>
<li><p>计算工作量小，存储量小等优点。</p>
</li>
<li><p>最速下降方向仅是函数的局部性质，对于整体求解，最速下降法下降非常缓慢。</p>
<p>原因是：</p>
<ul>
<li><p>精确线搜索使得$\nabla f(x^{(k+1)})^Td^{(k)} =0$，即最速下降法中前后两次迭代的搜索方向是正交的。</p>
</li>
<li><p>所以在靠近极小点附近的路径呈现锯齿形，下降十分缓慢。</p>
</li>
</ul>
</li>
</ul>
<h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><p>原理：</p>
<p>设目标函数$f(x)$二次连续可微，$f(x)$在当前迭代点$x^{(k)}$处作$Taylor$展开，并取二阶近似得</p>
<script type="math/tex; mode=display">
f(x) \approx f(x^{(k)}) + \nabla f(x^{(k)})^T(x-x^{(k)}) + \frac{1}{2}^T(x-x^{(k)})^T \nabla^2 f(x^{(k)}) (x-x^{(k)})</script><p>极小化上式右端有</p>
<script type="math/tex; mode=display">
\nabla f(x^{(k)}) + \nabla^2f(x^{(k)})(x-x^{(k)}) = 0</script><p>若$Hessian$矩阵$\nabla^2 f(x^{(k)})$正定，则得到右端二次函数的极小点，并将它作为无约束问题最优值的第$k+1$次近似，即</p>
<script type="math/tex; mode=display">
x^{(k+1)} = x^{(k)} - (\nabla^2f(x^{(k)}))^{-1}\nabla f(x^{(k)})</script><p>这就是牛顿法迭代公式，其中</p>
<script type="math/tex; mode=display">
d^{(k)} = - (\nabla^2f(x^{(k)}))^{-1}\nabla f(x^{(k)}),\; \alpha_k=1</script><p>算法流程：</p>
<ol>
<li>给定初始点$x^{(1)} \in R^n$，允许误差$\varepsilon \gt 0$，置$k=1$</li>
<li>计算$\nabla f(x^{(k)})$，如果$||\nabla f(x^{(k)})|| \le \epsilon$，停止计算。否则，转步骤3</li>
<li>构造牛顿方向$d^{(k)} = - (\nabla^2f(x^{(k)}))^{-1}\nabla f(x^{(k)})$</li>
<li>令$x^{(k+1)} = x^{(k)} + d^{(k)}$，令$k = k +1$，转步骤2</li>
</ol>
<p>特点：</p>
<ul>
<li>牛顿法下降速度快，尤其对于二次凸函数，一次迭代就可以得到全局极小点。</li>
<li>对于一般非二次函数，牛顿法无法保证有限次迭代获得最优解，但初始点十分靠近极小点，牛顿法一定条件下可以达到二阶收敛速度。</li>
</ul>
<h2 id="阻尼牛顿法"><a href="#阻尼牛顿法" class="headerlink" title="阻尼牛顿法"></a>阻尼牛顿法</h2><p>算法流程：</p>
<ol>
<li><p>给定初始点$x^{(1)} \in R^n$，允许误差$\varepsilon \gt 0$，置$k=1$</p>
</li>
<li><p>计算$\nabla f(x^{(k)})$，如果$||\nabla f(x^{(k)})|| \le \epsilon$，停止计算。否则，转步骤3</p>
</li>
<li><p>构造牛顿方向$d^{(k)} = - (\nabla^2f(x^{(k)}))^{-1}\nabla f(x^{(k)})$。由精确线搜索计算步长$a_k$，使得</p>
<script type="math/tex; mode=display">
f(x^{(k)}+\alpha_kd^{(k)}) = \min_{\alpha \ge 0}f(x^{(k)}+\alpha d^{(k)})</script></li>
<li><p>令$x^{(k+1)} = x^{(k)} + d^{(k)}$，令$k = k +1$，转步骤2</p>
</li>
</ol>
<h2 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h2><p>算法流程：</p>
<ol>
<li><p>给定初始点$x^{(1)} \in R^n$，允许误差$\varepsilon \gt 0$，令$d^{(1)}=-\nabla f(x^{(1)})$。置$k=1$</p>
</li>
<li><p>如果$||\nabla f(x^{(k)})|| \le \epsilon$，停止计算。否则，转步骤3</p>
</li>
<li><p>由精确线搜索计算步长$a_k$，使得</p>
<script type="math/tex; mode=display">
f(x^{(k)}+\alpha_kd^{(k)}) = \min_{\alpha \ge 0}f(x^{(k)}+\alpha d^{(k)})</script><p>令$x^{(k+1)} = x^{(k)}+\alpha _k d^{(k)}$</p>
</li>
<li><p>计算$\beta _k= \frac{||\nabla f(x^{(k+1)})||^2}{||\nabla f(x^{(k)})||^2}$，$d^{(k+1)}=-\nabla f(x^{(k+1)})+\beta _k d^{(k)}$</p>
</li>
<li><p>令$k = k +1$，转步骤2</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>已知语言构建文法</title>
    <url>/2019/11/14/%E5%B7%B2%E7%9F%A5%E8%AF%AD%E8%A8%80%E6%9E%84%E5%BB%BA%E6%96%87%E6%B3%95/</url>
    <content><![CDATA[<h1 id="已知语言构建文法"><a href="#已知语言构建文法" class="headerlink" title="已知语言构建文法"></a>已知语言构建文法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>常用方法</p>
<ul>
<li>对称法</li>
<li>逐步求精法（分解法）</li>
<li>等价法</li>
<li>电路状态转换法</li>
<li>混合法（混合上面的方法）</li>
</ul>
<h2 id="对称法"><a href="#对称法" class="headerlink" title="对称法"></a>对称法</h2><p>适用于存在对称性的语言。</p>
<p>两点：</p>
<ol>
<li>找出对称轴</li>
<li>找出对称性</li>
</ol>
<p>例题：$L={a^{2n}b^n | n\gt 1 \; and \;a,b\in V_T}$</p>
<p>观察语言：</p>
<script type="math/tex; mode=display">
\begin{split}
& when \; n=1, L=aab \\
& when \; n=2, L=aaaabb \rightarrow \; L=aa\;aab\;b
\end{split}</script><p>所以推出文法：</p>
<script type="math/tex; mode=display">
\begin{split}
& S \rightarrow aaSb \\
& S \rightarrow aab
\end{split}</script><h2 id="逐步求精法（分解法）"><a href="#逐步求精法（分解法）" class="headerlink" title="逐步求精法（分解法）"></a>逐步求精法（分解法）</h2><p>两种：自上而下 或者从左向右</p>
<p>前提：语言中各成分之间没有关联。</p>
<p>例题：$L={a^ib^jc^k|i,j,k \ge 1 \; and \; a,b,c \in V_T}$</p>
<ol>
<li><p>自上而下求精法</p>
<script type="math/tex; mode=display">
S\rightarrow ABC,\; A \rightarrow aA|a,\; B \rightarrow bB|b,\; C  \rightarrow cC|c</script><p>分析：将$a^i,b^j,c^k$各自看成一个整体，由$i \ge 1$，语言中最少存在一个$a$，所以可以写成这样的文法：$A \rightarrow aA|a$。同理可以得到其他两个$B \rightarrow bB|b,\; C \rightarrow cC|c$。所以$S \rightarrow ABC$。</p>
</li>
<li><p>从左向右求精法</p>
<script type="math/tex; mode=display">
S \rightarrow aS|aA,\; A\rightarrow bA|bB,\; B\rightarrow cB|c</script><p>分析：$a^ib^jc^k=a^*a^{i-1}b^jc^k$，其中$i-1 \ge 0$。</p>
<p>当$i-1\ge 1$时，$S \rightarrow aS$；当$i-1=0$时，$S \rightarrow aA$。</p>
<p>$A$对应的语言是$b^jc^k$，同理推出$A\rightarrow bA|bB$。</p>
</li>
</ol>
<h2 id="等价法"><a href="#等价法" class="headerlink" title="等价法"></a>等价法</h2><p>产生式两边具有相同的特性</p>
<p>例题：$L={\omega | \omega \in (a,b)^* \;and\; there\; are\; as\; many\; a’s\; as\; b’s\; in \; \omega}$</p>
<p>在语言中，a和b的数量一样多。</p>
<p>首先写出下面三个产生式：</p>
<p>当以a开头时，$S \rightarrow aA$；</p>
<p>当以b开头时，$S \rightarrow bB$；</p>
<p>$S$可以为空：$S \rightarrow \varepsilon$</p>
<p>在$S、A、B$中，a和b的数量满足：</p>
<script type="math/tex; mode=display">
\begin{split} 
& S \quad |a|=|b| \\
& A \quad |a|+1 = |b| \\
& B \quad |b|+1 = |a|
\end{split}</script><p>在$A$中</p>
<ul>
<li><p>若以b开头：$A\rightarrow bS|b$</p>
</li>
<li><p>若以a开头：$A \rightarrow aAA \quad (aA == S)$</p>
</li>
</ul>
<p>同理 $B \rightarrow bS|b|bBB$</p>
<p>所以最后得到的文法是：</p>
<script type="math/tex; mode=display">
S \rightarrow aA|bB|\varepsilon \\
A \rightarrow bS|b|aAA \\
B \rightarrow aS|a|bBB</script><h2 id="电路状态转换法"><a href="#电路状态转换法" class="headerlink" title="电路状态转换法"></a>电路状态转换法</h2><p>适用于语言对元素的奇偶有要求的。</p>
<p>电路状态的概念：0代表偶数，1代表奇数。</p>
<p>比如000代表语言中的a,b,c的个数都是偶数。</p>
<p><img src="/images/电路转换图.png" alt="电路转换图"></p>
<p>解题步骤：</p>
<ol>
<li><p>构建电路状态转换图</p>
<ul>
<li>确定状态，如果有n个元素，则存在$2^n$个状态。</li>
<li>然后链接状态</li>
</ul>
</li>
<li><p>确定开始状态和结束状态</p>
<p>开始状态和结束状态是相对的，根据题目情况确定。</p>
<ol>
<li>以全是0为结束状态，以题目要求为开始状态。</li>
<li>以题目要求作为结束状态，以全是0为开始状态。</li>
</ol>
<p>比如对于某种L，以a或b开头，c结尾，abc数量皆为偶数，则开始状态不唯一，所以不能用 全是0作为开始状态，而结束状态是唯一的，所以可拿全是0作为结束状态。</p>
</li>
<li><p>命名各个状态</p>
<p>初始状态用S，其他状态用A、B、C…..命名。</p>
</li>
<li><p>写出相应的产生式</p>
<p>每条边的变化对应一条产生式</p>
<p>对结束状态要增加一条产生式$S \rightarrow \varepsilon$</p>
<p>严格的说最后可以写出$2^{n(n+1)}+1$条产生式。</p>
</li>
</ol>
<p>例题：$L={\omega| \omega \in (0,1)^*, 1的数量是偶数}$</p>
<p>电路状态转换图如下所示：</p>
<p><img src="/images/电路状态转换图2.png" alt="电路状态转换图2"></p>
<p>本题中，只有两个状态：</p>
<p>S：1的数量是偶数，A：1的数量是奇数。</p>
<p>S组作为终止状态。</p>
<p>根据状态转换图写出产生式：</p>
<script type="math/tex; mode=display">
S \rightarrow 0S|1A|\varepsilon \\
A \rightarrow 0A|1S</script><h2 id="混合法（混合上面的方法）"><a href="#混合法（混合上面的方法）" class="headerlink" title="混合法（混合上面的方法）"></a>混合法（混合上面的方法）</h2><p>常用的如：分解法+对称法/分解法+电路转换法等。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/Follower_JC/article/details/84036349" target="_blank" rel="noopener">https://blog.csdn.net/Follower_JC/article/details/84036349</a></li>
</ol>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>vim快捷键篇</title>
    <url>/2019/11/12/vim%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%AF%87/</url>
    <content><![CDATA[<h1 id="vim-快捷键"><a href="#vim-快捷键" class="headerlink" title="vim 快捷键"></a>vim 快捷键</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>normal 模式下 按下 <code>/</code> 进入查找模式，输入带查找的字符串按下回车，跳转到第一个匹配。使用<code>n</code>和<code>N</code>进行上下查找。查找支持正则表达式，如<code>/vim$</code>匹配行尾。特殊字符需要转义。</p>
<blockquote>
<p>查找回车用<code>\n</code>，替换回车用<code>\r</code></p>
</blockquote>
<p>在查找模式中加入<code>\c</code>表示大小写不敏感，<code>\C</code>表示大小写敏感查找</p>
<p>查找当前单词：在normal模式下按下<code>*</code>即可查找光标所在单词，要求前后为空白字符或标点符号。按下<code>g*</code>即可查找光标所在单词的单词序列，每次对前后字符无要求。</p>
<ul>
<li><code>/string</code>：向下搜索</li>
<li><code>？string</code>：向上搜索</li>
<li><code>/&lt;word\&gt;</code>：搜索单词，而不是字符串</li>
<li><code>n</code>：向下搜索，<code>N</code>：向上搜索</li>
</ul>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p><code>:s(substitute)</code>命令用于查找和替换字符串，语法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:&#123;作用范围&#125;s/&#123;目标&#125;/&#123;替换&#125;/&#123;替换标志&#125;</span><br></pre></td></tr></table></figure>
<p>作用范围</p>
<ul>
<li>当前行：<code>:s/foo/bar/g</code> <code>/g</code>所以匹配都被替换</li>
<li>全文：<code>:%s/foo/bar/g</code></li>
<li>选区，在Visual模式下选择区域后输入<code>:</code>，<code>:&#39;&lt;,&#39;&gt;s/foo/bar/g</code></li>
<li>2-11行：<code>5,12s/foo/bar/g</code></li>
<li>当前行和接下来两行：<code>:.,+2s/foo/bar/g</code></li>
</ul>
<p>替换标志</p>
<ul>
<li><code>g</code>表示全局替换</li>
<li>无标志表示替换第一次出现</li>
<li><code>i</code>和<code>I</code>分别表示大小写不敏感和敏感：<code>:%s/foo/bar/i</code> &lt;==&gt; <code>:%s/foo\c/bar</code></li>
<li><code>c</code>表示需要确认：<code>:%s/foo/bar/gc</code></li>
</ul>
<p>大小写替换</p>
<ul>
<li><code>-</code>：将光标下的字母改变大小写</li>
<li><code>3~</code>：将光标位置开始的三个字母该变其大小写</li>
<li><code>g~~</code>：改变当前行字母的大小写</li>
<li><code>U</code> 将可视模式下选择的字母全改成大写字母</li>
<li><code>u</code> 将可视模式下选择的字母全改成小写</li>
<li><code>gUU</code> 将当前行的字母改成大写</li>
<li><code>3gUU</code> 将从光标开始到下面3行字母改成大写</li>
<li><code>guu</code> 将当前行的字母全改成小写</li>
<li><code>gUw</code> 将光标下的单词改成大写。</li>
<li><code>guw</code> 将光标下的单词改成小写。</li>
</ul>
<p>折叠命令</p>
<ul>
<li><code>zc</code> 关闭当前打开的折叠</li>
<li><code>zo</code> 打开当前的折叠</li>
<li><code>zm</code> 关闭所有折叠</li>
<li><code>zM</code> 关闭所有折叠及其嵌套的折叠</li>
<li><code>zr</code> 打开所有折叠</li>
<li><code>zR</code> 打开所有折叠及其嵌套的折叠</li>
<li><code>zd</code> 删除当前折叠</li>
<li><code>zE</code> 删除所有折叠</li>
<li><code>zj</code> 移动至下一个折叠</li>
<li><code>zk</code> 移动至上一个折叠</li>
<li><code>zn</code> 禁用折叠</li>
<li><code>zN</code> 启用折叠</li>
</ul>
<h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><ul>
<li><a href="https://harttle.land/2016/08/08/vim-search-in-file.html" target="_blank" rel="noopener">https://harttle.land/2016/08/08/vim-search-in-file.html</a></li>
<li><a href="https://blog.csdn.net/xzz_hust/article/details/72731307" target="_blank" rel="noopener">https://blog.csdn.net/xzz_hust/article/details/72731307</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2019/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><hr>
<h2 id="create-创建型设计模式"><a href="#create-创建型设计模式" class="headerlink" title="create 创建型设计模式"></a>create 创建型设计模式</h2><h3 id="Abstract-Factory-抽象工厂"><a href="#Abstract-Factory-抽象工厂" class="headerlink" title="Abstract Factory 抽象工厂"></a>Abstract Factory 抽象工厂</h3><ol>
<li><p>意图</p>
<blockquote>
<p>提供一个创建一系列相关或相互依赖对象的接口,而无需指定他们具体的类</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>一个系统要独立于它的产品的创建,组合和表示.</li>
<li>一个系统要由多个产品系列中的一个来配置时.</li>
<li>当要强调一系列相关的产品对象的设计以便进行联合使用时.</li>
<li>当提供一个产品类库,只想显示他们的接口而不是实现的时候.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/abstract_factory.png" alt="抽象工厂"></p>
<h3 id="Builder-生成器"><a href="#Builder-生成器" class="headerlink" title="Builder 生成器"></a>Builder 生成器</h3><ol>
<li><p>意图</p>
<blockquote>
<p>将一个复杂对象的构建与它的表示进行分离,使得同样的构建过程可以创建不同的表示.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时.</li>
<li>当构造过程必须允许被构造的对象有不同的表示时.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/builder.png" alt="生成器"><br><img src="/images/diagram/builder_seq.png" alt="生成器"></p>
<p>​    </p>
<h3 id="Factory-工厂方法"><a href="#Factory-工厂方法" class="headerlink" title="Factory 工厂方法"></a>Factory 工厂方法</h3><ol>
<li><p>意图</p>
<blockquote>
<p>定义一个用于创建对象的接口,让子类决定事例化那一个类,Factory Method<br> 使一个类的实例化延迟要子类.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>当一个类不知道所必须创建的对象的类的时候.</li>
<li>当一个类希望由它的子类来指定它所创建的对象的时候.</li>
<li>当类将创建对象的职责委托给多个帮助子类中的某一个,并且你希望将哪一个帮助子类是代理<br>者这一信息局部化的时候.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/factory.png" alt="工厂方法"></p>
<p>​    </p>
<h3 id="Prototype-原型"><a href="#Prototype-原型" class="headerlink" title="Prototype 原型"></a>Prototype 原型</h3><ol>
<li><p>意图</p>
<blockquote>
<p>用原型实例指定创建类的种类,并且通过拷贝这些原型创建新的对象.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>当一个系统应该独立于它的产品的创建.构成和表示的时候.</li>
<li>当要实例化的类是在运行时刻指定的时,如动态加载</li>
<li>当要避免创建一个与产品类层次平行的工厂类层次时.</li>
<li>当一个类的实例只能有几个不同状态组合中的一种时.建立相应数目的原型并克隆他们可能比每次用何时的状态手工实例化<br>该类更加方便一些. </li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/prototype.png" alt="原型"></p>
<h3 id="Singleton-单件"><a href="#Singleton-单件" class="headerlink" title="Singleton 单件"></a>Singleton 单件</h3><ol>
<li><p>意图</p>
<blockquote>
<p>保证一个类仅有一个实例,并提供一个全局访问它的全局访问点.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>当类只能有一个实例,而且用户可以从一个众所周知的访问点访问它.</li>
<li>当这个唯一的实例应该是通过子类化可以拓展的,并且用户应该无需更改代码就能使用一个扩展的实例.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/singleton.png" alt="单件"></p>
<h3 id="创建性模式总结"><a href="#创建性模式总结" class="headerlink" title="创建性模式总结"></a>创建性模式总结</h3><blockquote>
<p>用一个系统创建的那些对象的类对系统进行参数化有两种常用方法:</p>
</blockquote>
<ol>
<li><p>一种生产创建对象的子类,对应工厂方法模式.缺点是为了改变产品类,就可能需要创建一个新类.这样的改变可能是级联的.</p>
</li>
<li><p>另一种对系统进行参数化的方法更多依赖于对象复合,定义一个对象负责明确产品对象的<br> 类,并将它作为系统的参数.这就是抽象工厂,Builder,Prototype的关键特征.<br> 所以这三个模式都涉及到创建一个新的负责创建产品对象的””工厂对象”</p>
<ol>
<li>Abstract Factory 由这个工厂对象产生多个类对象.</li>
<li>Builder 由这个工厂对象使用一个相对复杂的协议,逐步创建一个复杂产品.</li>
<li>Prototype 由该工厂对象通过拷贝原型对象来创建产品对象.因为由原型返回对象,<br> 所有工厂对象和原型是同一个对象. </li>
</ol>
</li>
</ol>
<h2 id="structure-结构性模式"><a href="#structure-结构性模式" class="headerlink" title="structure 结构性模式"></a>structure 结构性模式</h2><blockquote>
<p>结构型设计模式涉及到如何组合类和对象以获得更大的结构,结构型类模式采用继承机制来组合接口或实现.</p>
</blockquote>
<h3 id="Adapter-适配器"><a href="#Adapter-适配器" class="headerlink" title="Adapter 适配器"></a>Adapter 适配器</h3><ol>
<li><p>意图</p>
<blockquote>
<p>将一个类的接口转换成客户希望的另一个接口,Adapter模式使得原本由于接口不兼容而不能一起<br> 工作的那些类可以一起工作.</p>
</blockquote>
</li>
<li><p>别名</p>
<blockquote>
<p>包装器 Wrapper</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>你想使用一个已经存在的类,而它的接口不符合你的要求.</li>
<li>你想创建一个可以复用的类,该类可以和其他不相关的类或不可预见的类协同工作.</li>
<li>你想使用一些已经存在的子类,但是不可能对每一个都进行子类化以匹配它们的接口.对象适配器可以适配<br>它的父类接口.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/adapter.png" alt="适配器"></p>
<h3 id="Bridge-桥接"><a href="#Bridge-桥接" class="headerlink" title="Bridge 桥接"></a>Bridge 桥接</h3><ol>
<li><p>意图</p>
<blockquote>
<p>将抽象部分与它的实现部分分离,使它们都可以独立的变化</p>
</blockquote>
</li>
<li><p>别名</p>
<blockquote>
<p>Handle/Body</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>不希望在抽象和它的实现部分之间有一个固定的绑定关系.</li>
<li>类的抽象以及它的实现都应该可以 生成子类的方法加以扩充.</li>
<li>对一个抽象的实现部分的修改对客户不产生影响</li>
<li>想对客户隐藏抽象的实现部分.</li>
<li>有许多类要生成的类层次结构</li>
<li>想在多个对象间共享实现,但客户不知道这一点.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/bridge.png" alt="桥接"><br><img src="/images/diagram/bridge_seq.png" alt="桥接"></p>
<h3 id="Composite-组合"><a href="#Composite-组合" class="headerlink" title="Composite 组合"></a>Composite 组合</h3><ol>
<li><p>意图</p>
<blockquote>
<p>将对象组合成树形结构以表示””部分-整体”的层次结构,Composite使用户对单个对象和组合对象的<br> 使用具有一致性.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>想表示对象部分—整体层次结构</li>
<li>希望用户忽略组合对象和单个对象的不同,用户将统一的使用组合结构中的所有对象</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/composite.png" alt="组合"></p>
<h3 id="Decorator-装饰"><a href="#Decorator-装饰" class="headerlink" title="Decorator 装饰"></a>Decorator 装饰</h3><ol>
<li><p>意图</p>
<blockquote>
<p>动态的给一个对象添加一些额外的职责.就增加功能而言,装饰者模式比生成子类<br> 更加灵活</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>在不影响其他对象的情况下,以动态,透明的方式给单个对象添加职责</li>
<li>处理那些可以撤销的职责.</li>
<li>当不能采用子类进行扩充的时候.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/decorator.png" alt="装饰者"></p>
<h3 id="Facade-外观"><a href="#Facade-外观" class="headerlink" title="Facade 外观"></a>Facade 外观</h3><ol>
<li><p>意图</p>
<blockquote>
<p>为子系统中的一组接口提供一致的界面,Facade 模式定义了一个高层接口,<br> 这个接口使得子系统更加容易使用.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>要为一个复杂子系统提供一个简单接口时,子系统往往因为不断演化而变得越来越复杂.</li>
<li>客户程序与抽象类的实现部分存在很大的依赖性.</li>
<li>当需要构建一个层次结构的子系统时,使用facade,模式定义子系统的入口点.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/facade.png" alt="外观"></p>
<h3 id="Flyweight-享元"><a href="#Flyweight-享元" class="headerlink" title="Flyweight 享元"></a>Flyweight 享元</h3><ol>
<li><p>意图</p>
<blockquote>
<p>运用共享技术有效地支持大量细粒度的对象.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>一个应用程序使用了大量的对象.</li>
<li>完全由于使用了大量的对象,造成很大的存储开销.</li>
<li>对象的大多数状态都可变为外部状态.</li>
<li>如果删除对象的外部状态,那么可以用相对较少的共享对象取代很多对象.</li>
<li>应用程序不依赖对象标识.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/flyweight.png" alt="享元"></p>
<h3 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h3><ol>
<li><p>意图</p>
<blockquote>
<p>对其他对象提供一种代理以供其他对象访问</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li></li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/proxy.png" alt="代理"></p>
<h3 id="结构型模式总结"><a href="#结构型模式总结" class="headerlink" title="结构型模式总结"></a>结构型模式总结</h3><ol>
<li><p>Adapter 模式主要解决两个一游接口之间的不匹配问题,不考虑接口如何实现,<br>也不考虑接口如何演化.</p>
</li>
<li><p>Bridge 模式对抽象接口与它的实现部分进行桥接.</p>
</li>
<li><p>Decorator 旨在不需要生成子类即可给对象添加职责.</p>
</li>
<li><p>Composite 旨在构造类,使多个相关的对象能够以统一的方式处理,多重对象可以被<br>当成一个对象来处理.</p>
</li>
<li><p>Proxy 模式构成一个对象并为用户提供一致的接口.</p>
</li>
</ol>
<h2 id="行为设计模式"><a href="#行为设计模式" class="headerlink" title="行为设计模式"></a>行为设计模式</h2><hr>
<blockquote>
<p>行为设计模式设计算法和对象间职责的分配.行为模式不仅描述类和对象的模式,<br>还描述它们之间的通信模式.</p>
</blockquote>
<h3 id="Chain-of-Responsibility-责任链"><a href="#Chain-of-Responsibility-责任链" class="headerlink" title="Chain of Responsibility 责任链"></a>Chain of Responsibility 责任链</h3><ol>
<li><p>意图</p>
<blockquote>
<p>使多个对象都有机会处理请求,从而避免请求的发送者和接受者的耦合关系.<br> 将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它为止.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>有多个的对象可以处理一个请求,那个对象处理请求运行时刻自动确定.</li>
<li>想在不明确指定接受者的情况下想多个对象中的一个提交请求.</li>
<li>可以处理一个请求的对象集合被动态指定.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/chain.png" alt="责任链"></p>
<h3 id="Command-命令"><a href="#Command-命令" class="headerlink" title="Command 命令"></a>Command 命令</h3><ol>
<li><p>意图</p>
<blockquote>
<p>将一个请求封装成一个对象,从而使得可以用不同的请求对客户进行参数化,对请求<br> 排队或记录请求日志,以及支持可撤销操作.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>抽象出待执行的动作以参数化某对象.</li>
<li>在不同的时刻指定,排列和执行请求.</li>
<li>支持取消操作.</li>
<li>支持修改日志.</li>
<li>用构建在原语操作上的高层操作构造一个系统.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/command.png" alt="命令"></p>
<h3 id="Interpreter-解释器"><a href="#Interpreter-解释器" class="headerlink" title="Interpreter 解释器"></a>Interpreter 解释器</h3><ol>
<li><p>意图</p>
<blockquote>
<p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示<br> 来解释语言的句子.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<blockquote>
<p>解释器模式适用于当有一个语言需要解释执行，并且可将该语言的句子表示为一个抽象<br> 语法树时一下情况最好。</p>
</blockquote>
<ul>
<li>该文法简单.</li>
<li>效率不是关键问题.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/Interpreter.png" alt="解释器"></p>
<h3 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h3><ol>
<li><p>意图</p>
<blockquote>
<p>提供一种方法顺序访问一个聚合对象的各个元素，且不需要暴露该对象的内部表示。</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>访问一个聚合对象的内容而无须暴露它的内部表示.</li>
<li>支持对聚合对象的多种遍历.</li>
<li>为遍历不同的聚合结构提供一个统一的接口。</li>
</ul>
</li>
</ol>
<h3 id="Mediator-中介者"><a href="#Mediator-中介者" class="headerlink" title="Mediator 中介者"></a>Mediator 中介者</h3><ol>
<li><p>意图</p>
<blockquote>
<p>用一个中介对象来封装一系列对象的交互。中介者使各对象不需要显示地互相<br> 引用，从而使其耦合松散，可以独立地改变它们之间的交互</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解.</li>
<li>一个对象引用其他 很多对象并且与这些对象通信，导致难以复用该对象。</li>
<li>想定制一个分布在多个类中的行为，而不想生成太多的子类。</li>
</ul>
</li>
</ol>
<h3 id="Memento-备忘录"><a href="#Memento-备忘录" class="headerlink" title="Memento 备忘录"></a>Memento 备忘录</h3><ol>
<li><p>意图</p>
<blockquote>
<p>在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。<br> 这样以后就可以将对象恢复到原先保存的状态。</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li><p>必须保存一个对象在某一个时刻的（部分）状态，这样以后需要时它才能恢复<br>到先前的状态。</p>
</li>
<li><p>如果一个用接口让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Observer-观察者"><a href="#Observer-观察者" class="headerlink" title="Observer 观察者"></a>Observer 观察者</h3><ol>
<li><p>意图</p>
<blockquote>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li><p>当一个抽象模型有两个方面，一个方面依赖另一个方面。将这两者封装在独立的对象中以使他们可以<br>各自独立的改变和使用。</p>
</li>
<li><p>当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。</p>
</li>
<li><p>当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。</p>
</li>
</ul>
</li>
</ol>
<h3 id="State-状态"><a href="#State-状态" class="headerlink" title="State 状态"></a>State 状态</h3><ol>
<li><p>意图</p>
<blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为。对象似乎修改了它的类。</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li><p>一个对象的行为决定于它的状态，并且它必须在运行时刻根据状态改变它的行为。</p>
</li>
<li><p>一个操作中含有庞大的多分支的条件语句，并且这些分支依赖于该对象的状态。这个状态常用一个或多个枚举常量表示<br>。</p>
</li>
</ul>
</li>
</ol>
<p>​    </p>
<h3 id="Strategy-策略"><a href="#Strategy-策略" class="headerlink" title="Strategy 策略"></a>Strategy 策略</h3><ol>
<li><p>意图</p>
<blockquote>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li><p>许多相关的类仅仅行为有异。</p>
</li>
<li><p>需要使用一个算法的不同变体。</p>
</li>
<li><p>算法使客户不应该知道的数据。</p>
</li>
<li><p>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，<br>将相关条件的分支移入它们各自的Strategy类中，以替代这些条件语句。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Template-Method-模板方法"><a href="#Template-Method-模板方法" class="headerlink" title="Template Method 模板方法"></a>Template Method 模板方法</h3><ol>
<li><p>意图</p>
<blockquote>
<p>定义一个操作的算法骨架，而将一些步骤延迟到子类。</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li><p>一次性实现一个算法中不变的部分，将可变的部分留给子类实现。</p>
</li>
<li><p>各子类的公共的行为应该被提取出来并集中到一个公共父类中，避免代码的重复。</p>
</li>
<li><p>控制子类的扩展。模板方法旨在特点调用“hook”操作（默认的行为，子类可以在必要的时候进行重定义扩展），<br>这就只允许在这些点进行扩展。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Visitor-访问者"><a href="#Visitor-访问者" class="headerlink" title="Visitor  访问者"></a>Visitor  访问者</h3><ol>
<li><p>意图</p>
<blockquote>
<p>表示一个作用于某对象结构的各元素的操作，它允许在不改变各元素的类的前提下定义作用于这些元素<br> 的新操作。</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li><p>一个对象结构包含很多类对象，它们有不同的接口，而用户想对这些对象实施一些依赖于其具体类的操作。</p>
</li>
<li><p>需要对一个对象结构中的对象进行很多不同并且 不相关的操作，而又想要避免这些操作“污染”这些对象的类。</p>
</li>
<li><p>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。</p>
</li>
</ul>
</li>
</ol>
<h3 id="行为模式比较"><a href="#行为模式比较" class="headerlink" title="行为模式比较"></a>行为模式比较</h3><ul>
<li>一个Strategy 对象封装一个算法：</li>
<li>一个State对象封装一个与状态相关的行为：</li>
<li>一个Mediator 对象封装对象间的协议：</li>
<li>一个Iterator对象封装访问和遍历一个聚合对象中的各个组件的方法。</li>
<li>Chain of  Responsibility 可以处理任意数目的对象（一条链）</li>
<li>一个Visitor对象是一个多态的Accept操作的参数</li>
<li>在Command 中，令牌代表一个请求</li>
<li>在Memento 中，两台代表一个对象在某个特定时刻的内部状态 </li>
</ul>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
  </entry>
  <entry>
    <title>Chomsky文法</title>
    <url>/2019/11/06/Chomsky%E6%96%87%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Chomsky-文法"><a href="#Chomsky-文法" class="headerlink" title="Chomsky 文法"></a>Chomsky 文法</h1><p>定义：四元组 $G(V,T,P,S)$</p>
<ul>
<li>$V$: 变量的非空有穷集合，是一个语法范畴，$V$的元素叫做语法变量或非终结符。</li>
<li>$T$：终结符的非空有限集，$T$的元素叫做终结符，满足$V\cap T = \varnothing $</li>
<li>$P$：产生式的非空有穷集合，$P$中的产生式形式为$\alpha \to \beta$，产生式左部$\alpha \in (V \cup T)^+ - T^+$，产生式右部$\beta \in (V \cup T)^*$</li>
<li>$S$：文法的开始符号，也叫识别符号，$S \in V$</li>
</ul>
<h2 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h2><p>也叫短语结构文法，对应的语言叫0型语言，短语结构语言或者递归可枚举集。</p>
<h2 id="1型文法"><a href="#1型文法" class="headerlink" title="1型文法"></a>1型文法</h2><p>在0型文法的基础上，如果对于$\forall  \alpha \to \beta \in P$，且$|\beta| \ge |\alpha|$，或如果对于$\forall xUy  \to xuy \in P$，且$|xuy| \ge |xUy|$，其中$U \in V,\quad x,y \in V^*,\quad u\in V^*$，则该文法为1型文法，或上下文有关文法，对应的语言叫1型语言，或上下文有关语言。</p>
<h2 id="2型文法"><a href="#2型文法" class="headerlink" title="2型文法"></a>2型文法</h2><p>在1型文法的基础上，如果对于$\forall \alpha \to \beta \in P$，且$\alpha \in V$，则该文法为2型文法或上下文无关文法，其对应的语言为2型语言或上下文无关的语言。</p>
<h2 id="3型文法"><a href="#3型文法" class="headerlink" title="3型文法"></a>3型文法</h2><p>在2型文法的基础上，如果$\forall \alpha \to \beta \in P$，且$\alpha \to \beta$均具有形式</p>
<script type="math/tex; mode=display">
A \to w \\ A \to wB \\ A \to \varepsilon</script><p>其中，$A,B \in V,\; w \in T$，则该文法为3型文法，也称正则文法或正规文法，其对应的语言为3型语言，或正则语言或正规语言。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>0型文法无限制</li>
<li>1型文法产生式左边长度大于右边</li>
<li>2型文法产生式左边为单个非终结符</li>
</ol>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>C++快速教程</title>
    <url>/2019/11/02/CPP%E5%BF%AB%E9%80%9F%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="The-Tutorial-about-C"><a href="#The-Tutorial-about-C" class="headerlink" title="The Tutorial about C++"></a>The Tutorial about C++</h1><h2 id="Part-One"><a href="#Part-One" class="headerlink" title="Part One"></a>Part One</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is a comment</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Multi-line comment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tells the compiler iostream library which contains the function cout</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allows us to use vectors</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allows us to use strings</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow us to work with files</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allows functions in the std namespace to be used without their prefix</span></span><br><span class="line"><span class="comment">// std::cout becomes cout</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- FUNCTIONS ----------</span></span><br><span class="line"><span class="comment">// The function has return type, function name and attributes with </span></span><br><span class="line"><span class="comment">// their data types</span></span><br><span class="line"><span class="comment">// The attribute data types must match the value passed in</span></span><br><span class="line"><span class="comment">// This data is passed by value</span></span><br><span class="line"><span class="comment">// You can define default values to attributes as long as they come last</span></span><br><span class="line"><span class="comment">// This is known as a function prototype</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addNumbers</span><span class="params">(<span class="keyword">int</span> firstNum, <span class="keyword">int</span> secondNum = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> combinedValue = firstNum + secondNum;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> combinedValue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An overloaded function has the same name, but different attributes</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addNumbers</span><span class="params">(<span class="keyword">int</span> firstNum, <span class="keyword">int</span> secondNum, <span class="keyword">int</span> thirdNum)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> firstNum + secondNum + thirdNum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A recursive function is one that calls itself</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFactorial</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> sum;</span><br><span class="line">	<span class="keyword">if</span>(number == <span class="number">1</span>) sum = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> sum = (getFactorial(number - <span class="number">1</span>) * number);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// getFactorial(2) [Returns 2] * 3</span></span><br><span class="line">	<span class="comment">// getFactorial(1) [Returns 1] * 2 &lt;This value goes above&gt;</span></span><br><span class="line">	<span class="comment">// 2 * 3 = 6</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Doesn't have a return type so use void</span></span><br><span class="line"><span class="comment">// Since I'm getting a pointer use int*</span></span><br><span class="line"><span class="comment">// Refer to the referenced variable with *age</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeMeYoung</span><span class="params">(<span class="keyword">int</span>* age)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"I used to be "</span> &lt;&lt; *age &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">	*age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A function that receives a reference can manipulate the value globally</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">actYourAge</span><span class="params">(<span class="keyword">int</span>&amp; age)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	age = <span class="number">39</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- END OF FUNCTIONS ----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- CLASSES ----------</span></span><br><span class="line"><span class="comment">// classes start with the name class</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// private variables are only available to methods in the class</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> height;</span><br><span class="line">	<span class="keyword">int</span> weight;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A static variable shares the same value with every object in the class</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> numOfAnimals;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Public variables can be accessed by anything with access to the object</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> height;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> weight;&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> cm)</span></span>&#123; height = cm; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> kg)</span></span>&#123; weight = kg; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="built_in">string</span> dogName)</span></span>&#123; name = dogName; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Declared as a prototype</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAll</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">string</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Declare the constructor</span></span><br><span class="line">	Animal(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Declare the deconstructor</span></span><br><span class="line">	~Animal();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// An overloaded constructor called when no data is passed</span></span><br><span class="line">	Animal();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// protected members are available to members of the same class and </span></span><br><span class="line">	<span class="comment">// sub classes</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Static methods aren't attached to an object and can only access</span></span><br><span class="line">	<span class="comment">// static member variables</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumOfAnimals</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numOfAnimals; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This method will be overwritten in Dog</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Animal::numOfAnimals = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the protoype method setAll</span></span><br><span class="line"><span class="keyword">void</span> Animal::setAll(<span class="keyword">int</span> height, <span class="keyword">int</span> weight, <span class="built_in">string</span> name)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This is used to refer to an object created of this class type</span></span><br><span class="line">	<span class="keyword">this</span> -&gt; height = height;</span><br><span class="line">	<span class="keyword">this</span> -&gt; weight = weight;</span><br><span class="line">	<span class="keyword">this</span> -&gt; name = name;</span><br><span class="line">	Animal::numOfAnimals++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A constructor is called when an object is created</span></span><br><span class="line">Animal::Animal(<span class="keyword">int</span> height, <span class="keyword">int</span> weight, <span class="built_in">string</span> name) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span> -&gt; height = height;</span><br><span class="line">	<span class="keyword">this</span> -&gt; weight = weight;</span><br><span class="line">	<span class="keyword">this</span> -&gt; name = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The destructor is called when an object is destroyed</span></span><br><span class="line">Animal::~Animal() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Animal "</span> &lt;&lt; <span class="keyword">this</span> -&gt; name &lt;&lt; <span class="string">" destroyed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A constructor called when no attributes are passed</span></span><br><span class="line">Animal::Animal() &#123;</span><br><span class="line">	numOfAnimals++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method prints object info to screen and will be overwritten</span></span><br><span class="line"><span class="keyword">void</span> Animal::toString()&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> -&gt; name &lt;&lt; <span class="string">" is "</span> &lt;&lt; <span class="keyword">this</span> -&gt; height &lt;&lt; <span class="string">" cms tall and "</span></span><br><span class="line">		&lt;&lt; <span class="keyword">this</span> -&gt; weight &lt;&lt; <span class="string">" kgs in weight"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can inherit the variables and methods of other classes</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">string</span> sound = <span class="string">"Woof"</span>;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">getSound</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; sound &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Declare the constructor</span></span><br><span class="line">		Dog(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">string</span>, <span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Declare the default constructor and call the default superclass</span></span><br><span class="line">		<span class="comment">// constructor</span></span><br><span class="line">		Dog() : Animal()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Overwrite toString</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog constructor passes the right attributes to the superclass</span></span><br><span class="line"><span class="comment">// constructor and then handles the attribute bark that remains</span></span><br><span class="line">Dog::Dog(<span class="keyword">int</span> height, <span class="keyword">int</span> weight, <span class="built_in">string</span> name, <span class="built_in">string</span> bark) : </span><br><span class="line">Animal(height, weight, name)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span> -&gt; sound = bark;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toString method overwritten</span></span><br><span class="line"><span class="keyword">void</span> Dog::toString()&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Because the attributes were private in Animal they must be retrieved </span></span><br><span class="line">	<span class="comment">// by called the get methods</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> -&gt; getName() &lt;&lt; <span class="string">" is "</span> &lt;&lt; <span class="keyword">this</span> -&gt; getHeight() &lt;&lt; </span><br><span class="line">		<span class="string">" cms tall and "</span> &lt;&lt; <span class="keyword">this</span> -&gt; getWeight() &lt;&lt; <span class="string">" kgs in weight and says "</span> &lt;&lt; </span><br><span class="line">		<span class="keyword">this</span> -&gt; sound &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- END OF CLASSES ----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This is where execution begins. Attributes can be sent to main</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cout outputs text and a carriage return with endl</span></span><br><span class="line">	<span class="comment">// Statements must end with a semicolon</span></span><br><span class="line">	<span class="comment">// Strings must be surrounded by "</span></span><br><span class="line">	<span class="comment">// &lt;&lt; sends the text via standard output to the screen</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello Internet"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- VARIABLES / DATA TYPES ----------</span></span><br><span class="line">	<span class="comment">// Variables start with a letter and can contain letters, numbers and _</span></span><br><span class="line">	<span class="comment">// They are case sensitive</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// A value that won't change is a constant</span></span><br><span class="line">	<span class="comment">// Starts with const and it should be uppercase</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926535</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// chars can contain 1 character that are surrounded with ' and is one byte in size</span></span><br><span class="line">	<span class="keyword">char</span> myGrade = <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// bools have the value of (true/1) or (false/0)</span></span><br><span class="line">	<span class="keyword">bool</span> isHappy = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ints are whole numbers</span></span><br><span class="line">	<span class="keyword">int</span> myAge = <span class="number">39</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// floats are floating point numbers accurate to about 6 decimals</span></span><br><span class="line">	<span class="keyword">float</span> favNum = <span class="number">3.141592</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// doubles are floating point numbers accurate to about 15 digits</span></span><br><span class="line">	<span class="keyword">double</span> otherFavNum = <span class="number">1.6180339887</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can output a variable value like this</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Favorite Number "</span> &lt;&lt; favNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Other types include</span></span><br><span class="line">	<span class="comment">// short int : At least 16 bits</span></span><br><span class="line">	<span class="comment">// long int : At least 32 bits</span></span><br><span class="line">	<span class="comment">// long long int : At least 64 bits</span></span><br><span class="line">	<span class="comment">// unsigned int : Same size as signed version</span></span><br><span class="line">	<span class="comment">// long double : Not less then double</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can get the number of bytes for a data type with sizeof</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of int "</span> &lt;&lt; <span class="keyword">sizeof</span>(myAge) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of char "</span> &lt;&lt; <span class="keyword">sizeof</span>(myGrade) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of bool "</span> &lt;&lt; <span class="keyword">sizeof</span>(isHappy) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of float "</span> &lt;&lt; <span class="keyword">sizeof</span>(favNum) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of double "</span> &lt;&lt; <span class="keyword">sizeof</span>(otherFavNum) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> largestInt = <span class="number">2147483647</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Largest int "</span> &lt;&lt; largestInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- ARITHMETIC ----------</span></span><br><span class="line">	<span class="comment">// The arithmetic operators are +, -, *, /, %, ++, --</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 + 2 = "</span> &lt;&lt; <span class="number">5</span>+<span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 - 2 = "</span> &lt;&lt; <span class="number">5</span><span class="number">-2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 * 2 = "</span> &lt;&lt; <span class="number">5</span>*<span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 / 2 = "</span> &lt;&lt; <span class="number">5</span>/<span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 % 2 = "</span> &lt;&lt; <span class="number">5</span>%<span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> five = <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5++ = "</span> &lt;&lt; five++ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"++5 = "</span> &lt;&lt; ++five &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5-- = "</span> &lt;&lt; five-- &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"--5 = "</span> &lt;&lt; --five &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Shorthand assignment operators</span></span><br><span class="line">	<span class="comment">// a += b == a = a + b</span></span><br><span class="line">	<span class="comment">// There is also -=, *=, /=, %=</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Order of Operation states * and / is performed before + and -</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 + 2 - 3 * 2 = "</span> &lt;&lt; <span class="number">1</span> + <span class="number">2</span> - <span class="number">3</span> * <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"(1 + 2 - 3) * 2 = "</span> &lt;&lt; (<span class="number">1</span> + <span class="number">2</span> - <span class="number">3</span>) * <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- CASTING ----------</span></span><br><span class="line">	<span class="comment">// You convert from one data type to another by casting</span></span><br><span class="line">	<span class="comment">// char, int, float, double</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"4 / 5 = "</span> &lt;&lt; <span class="number">4</span> / <span class="number">5</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"4 / 5 = "</span> &lt;&lt; (<span class="keyword">float</span>) <span class="number">4</span> / <span class="number">5</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- IF STATEMENT ----------</span></span><br><span class="line">	<span class="comment">// Executes different code depending upon a condition</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Comparison operators include ==, !=, &gt;, &lt;, &gt;=, &lt;=</span></span><br><span class="line">	<span class="comment">// Will return true (1) if the comparison is true, or false (0)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Logical operators include &amp;&amp;, ||, !</span></span><br><span class="line">	<span class="comment">// Used to test 2 or more conditionals</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> age = <span class="number">70</span>;</span><br><span class="line">	<span class="keyword">int</span> ageAtLastExam = <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">bool</span> isNotIntoxicated = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((age &gt;= <span class="number">1</span>) &amp;&amp; (age &lt; <span class="number">16</span>))&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"You can't drive"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(!isNotIntoxicated)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"You can't drive"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(age &gt;= <span class="number">80</span> &amp;&amp; ((age &gt; <span class="number">100</span>) || ((age - ageAtLastExam) &gt; <span class="number">5</span>)))&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"You can't drive"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"You can drive"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- SWITCH STATEMENT ----------</span></span><br><span class="line">	<span class="comment">// switch is used when you have a limited number of possible options</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> greetingOption = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(greetingOption)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"bonjour"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hola"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span> :</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hallo"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span> :</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- TERNARY OPERATOR ----------</span></span><br><span class="line">	<span class="comment">// Performs an assignment based on a condition</span></span><br><span class="line">	<span class="comment">// variable = (condition) ? if true : if false</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> largestNum = (<span class="number">5</span> &gt; <span class="number">2</span>) ? <span class="number">5</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The biggest number is "</span> &lt;&lt; largestNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- ARRAYS ----------</span></span><br><span class="line">	<span class="comment">// Arrays store multiple values of the same type</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// You must provide a data type and the size of the array</span></span><br><span class="line">	<span class="keyword">int</span> myFavNums[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can declare and add values in one step</span></span><br><span class="line">	<span class="keyword">int</span> badNums[<span class="number">5</span>] = &#123;<span class="number">4</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">24</span>, <span class="number">34</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The first item in the array has the label (index) of 0</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad Number 1: "</span> &lt;&lt; badNums[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can create multidimensional arrays</span></span><br><span class="line">	<span class="keyword">char</span> myName[<span class="number">5</span>][<span class="number">5</span>] = &#123;&#123;<span class="string">'D'</span>,<span class="string">'e'</span>,<span class="string">'r'</span>,<span class="string">'e'</span>,<span class="string">'k'</span>&#125;,&#123;<span class="string">'B'</span>,<span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'a'</span>,<span class="string">'s'</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"2nd Letter in 2nd Array: "</span> &lt;&lt; myName[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can change a value in an array using its index</span></span><br><span class="line">	myName[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">'e'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"New Value "</span> &lt;&lt; myName[<span class="number">0</span>][<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- FOR LOOP ----------</span></span><br><span class="line">	<span class="comment">// Continues to execute code as long as a condition is true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can also cycle through an array by nesting for loops</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; myName[j][k];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- WHILE LOOP ----------</span></span><br><span class="line">	<span class="comment">// Use a while loop when you don't know ahead of time when a loop will end</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Generate a random number between 1 and 100</span></span><br><span class="line">	<span class="keyword">int</span> randNum = (rand() % <span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(randNum != <span class="number">100</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; randNum &lt;&lt; <span class="string">", "</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Used to get you out of the loop</span></span><br><span class="line">		randNum = (rand() % <span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can do the same as the for loop like this</span></span><br><span class="line">	<span class="comment">// Create an index to iterate out side the while loop</span></span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(index &lt;= <span class="number">10</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; index &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Increment inside the loop</span></span><br><span class="line">		index++;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- DO WHILE LOOP ----------</span></span><br><span class="line">	<span class="comment">// Used when you want to execute what is in the loop at least once</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Used to store a series of characters</span></span><br><span class="line">	<span class="built_in">string</span> numberGuessed;</span><br><span class="line">	<span class="keyword">int</span> intNumberGuessed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">	    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Guess between 1 and 10: "</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// Allows for user input</span></span><br><span class="line">	    <span class="comment">// Pass the source and destination of the input</span></span><br><span class="line">	    getline (<span class="built_in">cin</span>,numberGuessed);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// stoi converts the string into an integer</span></span><br><span class="line">	    intNumberGuessed = stoi(numberGuessed);</span><br><span class="line">	    <span class="built_in">cout</span> &lt;&lt; intNumberGuessed &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// We'll continue looping until the number entered is 4</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (intNumberGuessed != <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="built_in">cout</span> &lt;&lt; <span class="string">"You Win"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- STRINGS ----------</span></span><br><span class="line">	<span class="comment">// The string library class provides a string object</span></span><br><span class="line">	<span class="comment">// You must always surround strings with "</span></span><br><span class="line">	<span class="comment">// Unlike the char arrays in c, the string object automatically resizes</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The C way of making a string</span></span><br><span class="line">	<span class="keyword">char</span> happyArray[<span class="number">6</span>] = &#123;<span class="string">'H'</span>, <span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'p'</span>, <span class="string">'y'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The C++ way</span></span><br><span class="line">	<span class="built_in">string</span> birthdayString = <span class="string">" Birthday"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can combine / concatenate strings with +</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; happyArray + birthdayString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> yourName;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"What is your name? "</span>;</span><br><span class="line">	getline (<span class="built_in">cin</span>,yourName);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello "</span> &lt;&lt; yourName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> eulersConstant = <span class="number">.57721</span>;</span><br><span class="line">	<span class="built_in">string</span> eulerGuess;</span><br><span class="line">	<span class="keyword">double</span> eulerGuessDouble;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"What is Euler's Constant? "</span>;</span><br><span class="line">	getline (<span class="built_in">cin</span>,eulerGuess);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Converts a string into a double</span></span><br><span class="line">	<span class="comment">// stof() for floats</span></span><br><span class="line">	eulerGuessDouble = stod(eulerGuess);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(eulerGuessDouble == eulersConstant)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"You are right"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"You are wrong"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Size returns the number of characters</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of string "</span> &lt;&lt; eulerGuess.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// empty tells you if string is empty or not</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Is string empty "</span> &lt;&lt; eulerGuess.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// append adds strings together</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; eulerGuess.append(<span class="string">" was your guess"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> dogString = <span class="string">"dog"</span>;</span><br><span class="line">	<span class="built_in">string</span> catString = <span class="string">"cat"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compare returns a 0 for a match, 1 if less than, -1 if greater then</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dogString.compare(catString) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dogString.compare(dogString) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; catString.compare(dogString) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// assign copies a value to another string </span></span><br><span class="line">	<span class="built_in">string</span> wholeName = yourName.assign(yourName);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; wholeName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can get a substring as well by defining the starting index and the</span></span><br><span class="line">	<span class="comment">// number of characters to copy</span></span><br><span class="line">	<span class="built_in">string</span> firstName = wholeName.assign(wholeName, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; firstName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find returns the index for the string your searching for starting</span></span><br><span class="line">	<span class="comment">// from the index defined</span></span><br><span class="line">	<span class="keyword">int</span> lastNameIndex = yourName.find(<span class="string">"Banas"</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Index for last name "</span> &lt;&lt; lastNameIndex &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// insert places a string in the index defined</span></span><br><span class="line">	yourName.insert(<span class="number">5</span>, <span class="string">" Justin"</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; yourName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// erase will delete 6 characters starting at index 7</span></span><br><span class="line">	yourName.erase(<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; yourName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// replace 5 characters starting at index 6 with the string Maximus</span></span><br><span class="line">	yourName.replace(<span class="number">6</span>,<span class="number">5</span>,<span class="string">"Maximus"</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; yourName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- VECTORS ----------</span></span><br><span class="line">	<span class="comment">// Vectors are like arrays, but their size can change</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; lotteryNumVect(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> lotteryNumArray[<span class="number">5</span>] = &#123;<span class="number">4</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">24</span>, <span class="number">34</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add the array to the vector starting at the beginning of the vector</span></span><br><span class="line">	lotteryNumVect.insert(lotteryNumVect.begin(), lotteryNumArray, lotteryNumArray+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Insert a value into the 5th index</span></span><br><span class="line">	lotteryNumVect.insert(lotteryNumVect.begin()+<span class="number">5</span>, <span class="number">44</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// at gets the value in the specified index</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Value in 5 "</span> &lt;&lt; lotteryNumVect.at(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// push_back adds a value at the end of a vector</span></span><br><span class="line">	lotteryNumVect.push_back(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// back gets the value in the final index</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final Value "</span> &lt;&lt; lotteryNumVect.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pop_back removes the final element</span></span><br><span class="line">	lotteryNumVect.pop_back();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// front returns the first element</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"First Element "</span> &lt;&lt; lotteryNumVect.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// back returns the last element</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Last Element "</span> &lt;&lt; lotteryNumVect.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// empty tells you if the vector is empty</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Vector Empty "</span> &lt;&lt; lotteryNumVect.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// size returns the total number of elements</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of Vector Elements "</span> &lt;&lt; lotteryNumVect.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- FUNCTIONS ----------</span></span><br><span class="line">	<span class="comment">// Functions allow you to reuse and better organize your code</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; addNumbers(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can't access values created in functions (Out of Scope)</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; combinedValue &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; addNumbers(<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The factorial of 3 is "</span> &lt;&lt; getFactorial(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- FILE I/O ----------</span></span><br><span class="line">	<span class="comment">// We can read and write to files using text or machine readable binary</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> steveQuote = <span class="string">"A day without sunshine is like, you know, night"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create an output filestream and if the file doesn't exist create it</span></span><br><span class="line">	<span class="function">ofstream <span class="title">writer</span><span class="params">(<span class="string">"stevequote.txt"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Verify that the file stream object was created</span></span><br><span class="line">	<span class="keyword">if</span>(! writer)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error opening file"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Signal that an error occurred</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Write the text to the file</span></span><br><span class="line">		writer &lt;&lt; steveQuote &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Close the file</span></span><br><span class="line">		writer.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Open a stream to append to whats there with ios::app</span></span><br><span class="line">	<span class="comment">// ios::binary : Treat the file as binary</span></span><br><span class="line">	<span class="comment">// ios::in : Open a file to read input</span></span><br><span class="line">	<span class="comment">// ios::trunc : Default</span></span><br><span class="line">	<span class="comment">// ios::out : Open a file to write output</span></span><br><span class="line">	<span class="function">ofstream <span class="title">writer2</span><span class="params">(<span class="string">"stevequote.txt"</span>, ios::app)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(! writer2)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error opening file"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Signal that an error occurred</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		writer2 &lt;&lt; <span class="string">"\n- Steve Martin"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		writer2.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> letter;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read characters from a file using an input file stream</span></span><br><span class="line">	<span class="function">ifstream <span class="title">reader</span><span class="params">(<span class="string">"stevequote.txt"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(! reader)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error opening file"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Read each character from the stream until end of file</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; ! reader.eof(); i++)&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Get the next letter and output it</span></span><br><span class="line">			reader.get(letter);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; letter;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		reader.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- EXCEPTION HANDLING ----------</span></span><br><span class="line">	<span class="comment">// You can be prepared for potential problems with exception handling</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span>/number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">throw</span>(number);</span><br><span class="line"></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">catch</span>(<span class="keyword">int</span> number)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="string">" is not valid input"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- POINTERS ----------</span></span><br><span class="line">	<span class="comment">// When data is stored it is stored in an appropriately sized box based</span></span><br><span class="line">	<span class="comment">// on its data type </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> myAge = <span class="number">39</span>;</span><br><span class="line">	<span class="keyword">char</span> myGrade = <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of int "</span> &lt;&lt; <span class="keyword">sizeof</span>(myAge) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of char "</span> &lt;&lt; <span class="keyword">sizeof</span>(myGrade) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can reference the box (memory address) where data is stored with </span></span><br><span class="line">	<span class="comment">// the &amp; reference operator</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"myAge is located at "</span> &lt;&lt; &amp;myAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A pointer can store a memory address</span></span><br><span class="line">	<span class="comment">// The data type must be the same as the data referenced and it is followed</span></span><br><span class="line">	<span class="comment">// by a *</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>* agePtr = &amp;myAge;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can access the memory address and the data </span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address of pointer "</span> &lt;&lt; agePtr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// * is the dereference or indirection operator</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Data at memory address "</span> &lt;&lt; *agePtr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> badNums[<span class="number">5</span>] = &#123;<span class="number">4</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">24</span>, <span class="number">34</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span>* numArrayPtr = badNums;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can increment through an array using a pointer with ++ or --</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address "</span> &lt;&lt; numArrayPtr &lt;&lt; <span class="string">" Value "</span> &lt;&lt; *numArrayPtr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	numArrayPtr++; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address "</span> &lt;&lt; numArrayPtr &lt;&lt; <span class="string">" Value "</span> &lt;&lt; *numArrayPtr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// An array name is just a pointer to the array</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address "</span> &lt;&lt; badNums &lt;&lt; <span class="string">" Value "</span> &lt;&lt; *badNums &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When you pass a variable to a function you are passing the value</span></span><br><span class="line">	<span class="comment">// When you pass a pointer to a function you are passing a reference</span></span><br><span class="line">	<span class="comment">// that can be changed</span></span><br><span class="line"></span><br><span class="line">	makeMeYoung(&amp;myAge);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm "</span> &lt;&lt; myAge &lt;&lt; <span class="string">" years old now"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &amp; denotes that ageRef will be a reference to the assigned variable</span></span><br><span class="line">	<span class="keyword">int</span>&amp; ageRef = myAge;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"ageRef : "</span> &lt;&lt; ageRef &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// It can manipulate the other variables data</span></span><br><span class="line">	ageRef++; </span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"myAge : "</span> &lt;&lt; myAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can pass the reference to a function</span></span><br><span class="line">	actYourAge(ageRef);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"myAge : "</span> &lt;&lt; myAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When deciding on whether to use pointers or references</span></span><br><span class="line">	<span class="comment">// Use Pointers if you don't want to initialize at declaration, or if</span></span><br><span class="line">	<span class="comment">// you need to assign another variable</span></span><br><span class="line">	<span class="comment">// otherwise use a reference</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- CLASSES &amp; OBJECTS ----------</span></span><br><span class="line">	<span class="comment">// Classes are the blueprints for modeling real world objects</span></span><br><span class="line">	<span class="comment">// Real world objects have attributes, classes have members / variables</span></span><br><span class="line">	<span class="comment">// Real world objects have abilities, classes have methods / functions</span></span><br><span class="line">	<span class="comment">// Classes believe in hiding data (encapsulation) from outside code</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Declare a Animal type object</span></span><br><span class="line">	Animal fred;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the values for the Animal</span></span><br><span class="line">	fred.setHeight(<span class="number">33</span>);</span><br><span class="line">	fred.setWeight(<span class="number">10</span>);</span><br><span class="line">	fred.setName(<span class="string">"Fred"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the values for the Animal</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; fred.getName() &lt;&lt; <span class="string">" is "</span> &lt;&lt; fred.getHeight() &lt;&lt; <span class="string">" cms tall and "</span></span><br><span class="line">		&lt;&lt; fred.getWeight() &lt;&lt; <span class="string">" kgs in weight"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	fred.setAll(<span class="number">34</span>, <span class="number">12</span>, <span class="string">"Fred"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; fred.getName() &lt;&lt; <span class="string">" is "</span> &lt;&lt; fred.getHeight() &lt;&lt; <span class="string">" cms tall and "</span></span><br><span class="line">		&lt;&lt; fred.getWeight() &lt;&lt; <span class="string">" kgs in weight"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Creating an object using the constructor</span></span><br><span class="line">	<span class="function">Animal <span class="title">tom</span><span class="params">(<span class="number">36</span>, <span class="number">15</span>, <span class="string">"Tom"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tom.getName() &lt;&lt; <span class="string">" is "</span> &lt;&lt; tom.getHeight() &lt;&lt; <span class="string">" cms tall and "</span></span><br><span class="line">		&lt;&lt; tom.getWeight() &lt;&lt; <span class="string">" kgs in weight"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Demonstrate the inheriting class Dog</span></span><br><span class="line">	<span class="function">Dog <span class="title">spot</span><span class="params">(<span class="number">38</span>, <span class="number">16</span>, <span class="string">"Spot"</span>, <span class="string">"Woof"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// static methods are called by using the class name and the scope operator</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of Animals "</span> &lt;&lt; Animal::getNumOfAnimals() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	spot.getSound();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Test the toString method that will be overwritten</span></span><br><span class="line">	tom.toString();</span><br><span class="line">	spot.toString();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We can call the superclass version of a method with the class name </span></span><br><span class="line">	<span class="comment">// and the scope operator</span></span><br><span class="line">	spot.Animal::toString();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When a function finishes it must return an integer value</span></span><br><span class="line">	<span class="comment">// Zero means that the function ended with success</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Part-Two"><a href="#Part-Two" class="headerlink" title="Part Two"></a>Part Two</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Virtual Methods and Polymorphism</span></span><br><span class="line"><span class="comment">// Polymorpism allows you to treat subclasses as their superclass and yet</span></span><br><span class="line"><span class="comment">// call the correct overwritten methods in the subclass automatically</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">getFamily</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"We are Animals"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// When we define a method as virtual we know that Animal</span></span><br><span class="line">		<span class="comment">// will be a base class that may have this method overwritten</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">getClass</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm an Animal"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">getClass</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm a Dog"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GermanShepard</span> :</span> <span class="keyword">public</span> Dog&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">getClass</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm a German Shepard"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">getDerived</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm an Animal and Dog"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">whatClassAreYou</span><span class="params">(Animal *animal)</span></span>&#123; </span><br><span class="line">	animal -&gt; getClass(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Animal *animal = <span class="keyword">new</span> Animal;</span><br><span class="line">	Dog *dog = <span class="keyword">new</span> Dog;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If a method is marked virtual or not doesn't matter if we call the method</span></span><br><span class="line">	<span class="comment">// directly from the object</span></span><br><span class="line">	animal-&gt;getClass();</span><br><span class="line">	dog-&gt;getClass();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If getClass is not marked as virtual outside functions won't look for </span></span><br><span class="line">	<span class="comment">// overwritten methods in subclasses however</span></span><br><span class="line">	whatClassAreYou(animal);</span><br><span class="line">	whatClassAreYou(dog);</span><br><span class="line"></span><br><span class="line">	Dog spot;</span><br><span class="line">	GermanShepard max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A base class can call derived class methods as long as they exist </span></span><br><span class="line">	<span class="comment">// in the base class</span></span><br><span class="line">	Animal* ptrDog = &amp;spot;</span><br><span class="line">	Animal* ptrGShepard = &amp;max;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call the method not overwritten in the super class Animal</span></span><br><span class="line">	ptrDog -&gt; getFamily();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Since getClass was overwritten in Dog call the Dog version</span></span><br><span class="line">	ptrDog -&gt; getClass();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call to the super class</span></span><br><span class="line">	ptrGShepard -&gt; getFamily();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call to the overwritten GermanShepard version</span></span><br><span class="line">	ptrGShepard -&gt; getClass();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Part-Three"><a href="#Part-Three" class="headerlink" title="Part Three"></a>Part Three</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Polymorpism allows you to treat subclasses as their superclass and yet</span></span><br><span class="line"><span class="comment">// call the correct overwritten methods in the subclass automatically</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"The Animal says grrrr"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// The Animal class could be a capability class that exists</span></span><br><span class="line">		<span class="comment">// only to be derived from by containing only virtual methods</span></span><br><span class="line">		<span class="comment">// that do nothing</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"The Cat says meow"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"The Dog says woof"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An abstract data type is a class that acts as the base to other classes</span></span><br><span class="line"><span class="comment">// They stand out because its methods are initialized with zero</span></span><br><span class="line"><span class="comment">// A pure virtual method must be overwritten by subclasses</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span> : </span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getNumWheels</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getNumDoors</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StationWagon</span> :</span> <span class="keyword">public</span> Car&#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">getNumWheels</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Station Wagon has 4 Wheels"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">getNumDoors</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Station Wagon has 4 Doors"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">		StationWagon() &#123; &#125;</span><br><span class="line">		~StationWagon();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Animal* pCat = <span class="keyword">new</span> Cat;</span><br><span class="line">	Animal* pDog = <span class="keyword">new</span> Dog;</span><br><span class="line"></span><br><span class="line">	pCat -&gt; makeSound();</span><br><span class="line">	pDog -&gt; makeSound();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a StationWagon using the abstract data type Car</span></span><br><span class="line">	Car* stationWagon = <span class="keyword">new</span> StationWagon();</span><br><span class="line"></span><br><span class="line">	stationWagon -&gt; getNumWheels();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
  </entry>
  <entry>
    <title>激活函数</title>
    <url>/2019/11/01/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h1><h2 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h2><script type="math/tex; mode=display">
\begin{split}
& f(x) = \frac{1}{1+e^{-x}} \quad x\in R ,\quad f(x)\in (0,1)\\
& f^,(x) = \frac{e^x}{(1+e^{-x})^2} = f(x)(1-f(x)) \quad x\in R \quad f^,(x)\in (0,0.25\rbrack
\end{split}</script><h2 id="Tanh"><a href="#Tanh" class="headerlink" title="Tanh"></a>Tanh</h2><script type="math/tex; mode=display">
\begin{split}
& tanh(x) = \frac{sinhx}{coshx} = \frac{e^x-e^{-x}}{e^x+e^{-x}} \quad x\in R \quad tanh(x) \in (-1,1) \\
& (tanhx)^, = sech^2x = 1-tanh^2x \quad x\in R \quad (tanhx)^, \in (0,1\rbrack
\end{split}</script><h2 id="ReLu"><a href="#ReLu" class="headerlink" title="ReLu"></a>ReLu</h2><script type="math/tex; mode=display">
f(x) = max(0,x)</script><h2 id="Leaky-ReLu"><a href="#Leaky-ReLu" class="headerlink" title="Leaky ReLu"></a>Leaky ReLu</h2><script type="math/tex; mode=display">
f(x) = max(\alpha x,x) \quad  \alpha << 1, For\;most\;,\alpha = 0.01</script><h2 id="Softplus"><a href="#Softplus" class="headerlink" title="Softplus"></a>Softplus</h2><script type="math/tex; mode=display">
\zeta(x)= \ln(1+e^x)</script><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p>常见的激活函数有：<strong>sigmoid；tanh；ReLU；LReLU, PReLU, RReLU；ELU（Exponential Linear Units）；softplus；softsign,softmax等</strong></p>
<h2 id="Notion"><a href="#Notion" class="headerlink" title="Notion"></a>Notion</h2><ul>
<li>饱和：当激活函数趋于无穷，gradient 趋于 0。导致梯度消失</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul>
<li>sigmoid 激活函数:除了输出层是一个二分类问题基本不会用它。</li>
<li>tanh 激活函数:tanh 是非常优秀的,几乎适合所有场合。</li>
<li>ReLu 激活函数:最常用的默认函数,,如果不确定用哪个激活函数,就使用 ReLu 或者Leaky ReLu。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Activation Function</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Numpy实现机器学习算法</title>
    <url>/2019/11/01/ML-Based-Numpy/</url>
    <content><![CDATA[<h1 id="Realize-classical-ML-Algorithm-By-Numpy"><a href="#Realize-classical-ML-Algorithm-By-Numpy" class="headerlink" title="Realize classical ML Algorithm By Numpy"></a>Realize classical ML Algorithm By Numpy</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import packages needed for coding</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<h2 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">50</span>)</span><br><span class="line">y = <span class="number">3</span> * x + <span class="number">3</span> + np.random.randn(x.size)</span><br><span class="line">N = len(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.scatter(x, y)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Parameters</span></span><br><span class="line">LR = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line">plt.ion()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grad</span><span class="params">(w, b)</span>:</span></span><br><span class="line">    <span class="comment"># Compute Gradient</span></span><br><span class="line">    b_grad = (<span class="number">-2</span> / N * (y - (w * x + b))).sum()</span><br><span class="line">    w_grad = (<span class="number">-2</span> / N * x * (y - (w * x + b))).sum()</span><br><span class="line">    <span class="keyword">return</span> w_grad, b_grad</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimizer</span><span class="params">(w, b)</span>:</span></span><br><span class="line">    <span class="comment"># Optimizer</span></span><br><span class="line">    plt.scatter(x, y)</span><br><span class="line">    w_grad, b_grad = grad(w, b)</span><br><span class="line"></span><br><span class="line">    new_w = w - LR * w_grad</span><br><span class="line">    new_b = b - LR * b_grad</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_w, new_b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">losses = []</span><br><span class="line"></span><br><span class="line">W, B, EPOCH = <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(EPOCH):</span><br><span class="line">    W, B = optimizer(W, B)</span><br><span class="line">    P = W * x + B</span><br><span class="line"></span><br><span class="line">    plt.cla()</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    plt.scatter(x, y)</span><br><span class="line">    plt.plot(x, P, c=<span class="string">'red'</span>)</span><br><span class="line">    loss = np.abs((P - y).mean())</span><br><span class="line">    plt.xlabel(<span class="string">f"Loss: <span class="subst">&#123;loss&#125;</span>.4f"</span>)</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    losses.append(loss)</span><br><span class="line">    plt.plot(losses,<span class="string">'yo-'</span>)</span><br><span class="line">    plt.pause(<span class="number">0.01</span>)</span><br><span class="line">    print(<span class="string">f"Epoch : <span class="subst">&#123;epoch&#125;</span>, Loss : <span class="subst">&#123;loss&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">plt.ioff()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load Data</span></span><br><span class="line">LR = <span class="number">0.01</span></span><br><span class="line">MAX_EPOCH = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">theta = np.zeros((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># theta = np.array([-16.38, 0.1483, 0.1589]).reshape(3, 1)</span></span><br><span class="line"></span><br><span class="line">rx = np.fromfile(<span class="string">'ex4/ex4x.dat'</span>, sep=<span class="string">'\n'</span>).reshape(<span class="number">-1</span>, <span class="number">2</span>)</span><br><span class="line">x = (rx - rx.mean(<span class="number">0</span>))/rx.std(<span class="number">0</span>) <span class="comment"># z-score 归一化</span></span><br><span class="line">x = np.hstack((np.ones((<span class="number">80</span>, <span class="number">1</span>)), x))</span><br><span class="line">y = np.fromfile(<span class="string">'ex4/ex4y.dat'</span>, sep=<span class="string">'\n'</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">N = x.shape[<span class="number">0</span>]</span><br><span class="line">pos = (y == <span class="number">1</span>)[:, <span class="number">0</span>]</span><br><span class="line">neg = (y == <span class="number">0</span>)[:, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">L = list()</span><br><span class="line">L.clear()</span><br><span class="line"><span class="comment"># plt.scatter(x[pos, 1], x[pos, 2], marker='+', c='red')</span></span><br><span class="line"><span class="comment"># plt.scatter(x[neg, 1], x[neg, 2], marker='o', c='blue')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GD</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> theta, x, y</span><br><span class="line">    h = sigmoid(x.dot(theta))</span><br><span class="line">    grad = (x.T).dot(y - h)</span><br><span class="line">    l = np.exp((np.log(h).T.dot(y) + np.log(<span class="number">1</span> - h).T.dot(<span class="number">1</span>-y)).sum()/N)</span><br><span class="line">    <span class="keyword">return</span> grad, l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SGD</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> theta, x, y</span><br><span class="line">    r = np.random.randint(<span class="number">0</span>, x.shape[<span class="number">0</span>])</span><br><span class="line">    h = sigmoid(x[r, np.newaxis].dot(theta))</span><br><span class="line">    grad = (y[r] - h)*(x[r, np.newaxis].T)</span><br><span class="line">    l = np.exp((np.log(h).T.dot(y[r]) + np.log(<span class="number">1</span> - h).T.dot(<span class="number">1</span>-y[r])).sum())</span><br><span class="line">    <span class="keyword">return</span> grad, l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NewTon</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> theta, x, y</span><br><span class="line">    h = sigmoid(x.dot(theta))</span><br><span class="line">    grad = (x.T).dot(h-y)/N</span><br><span class="line">    H = (<span class="number">1</span>/N)*x.T.dot(np.diag(np.squeeze(h))</span><br><span class="line">                      ).dot(np.diag(np.squeeze(<span class="number">1</span>-h))).dot(x)</span><br><span class="line">    d = - np.linalg.inv(H).dot(grad)</span><br><span class="line">    l = np.exp(-(np.log(h).T.dot(y) + np.log(<span class="number">1</span> - h).T.dot(<span class="number">1</span>-y)).sum()/N)</span><br><span class="line">    <span class="keyword">return</span> d, l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimizer</span><span class="params">(way)</span>:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> way == <span class="string">'GD'</span>:</span><br><span class="line">        res, l = GD()</span><br><span class="line">    <span class="keyword">if</span> way == <span class="string">'SGD'</span>:</span><br><span class="line">        res, l = SGD()</span><br><span class="line">    <span class="keyword">if</span> way == <span class="string">'NT'</span>:</span><br><span class="line">        res, l = NewTon()</span><br><span class="line">    <span class="keyword">global</span> theta, LR, L</span><br><span class="line">    theta = theta + LR * res</span><br><span class="line">    L.append(l)</span><br><span class="line"><span class="comment">#     print(f"grad : &#123;res&#125;, theta: &#123;theta&#125;")</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = np.linspace(np.min(x[:, <span class="number">1</span>]), np.max(x[:, <span class="number">1</span>]), <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line">plt.ion()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(MAX_EPOCH):</span><br><span class="line">    optimizer(<span class="string">'NT'</span>)</span><br><span class="line">    plt.figure(figsize=(<span class="number">12</span>, <span class="number">5</span>), dpi=<span class="number">80</span>)</span><br><span class="line">    plt.subplot(<span class="number">121</span>)</span><br><span class="line">    plt.xlim(np.min(x[:,<span class="number">1</span>]), np.max(x[:,<span class="number">1</span>]))</span><br><span class="line">    plt.ylim(np.min(x[:,<span class="number">2</span>]), np.max(x[:,<span class="number">2</span>]))</span><br><span class="line">    plt.scatter(x[pos, <span class="number">1</span>], x[pos, <span class="number">2</span>], marker=<span class="string">'+'</span>, label=<span class="string">"Admitted"</span>, c=<span class="string">'red'</span>)</span><br><span class="line">    plt.scatter(x[neg, <span class="number">1</span>],</span><br><span class="line">                x[neg, <span class="number">2</span>],</span><br><span class="line">                marker=<span class="string">'o'</span>,</span><br><span class="line">                label=<span class="string">'Not Admitted'</span>,</span><br><span class="line">                c=<span class="string">'blue'</span>)</span><br><span class="line">    plt.plot(d,</span><br><span class="line">             -(theta[<span class="number">0</span>, <span class="number">0</span>] + theta[<span class="number">1</span>, <span class="number">0</span>] * d) / theta[<span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">             <span class="string">'r'</span>,</span><br><span class="line">             c=<span class="string">'green'</span>,</span><br><span class="line">             label=<span class="string">'descision boundary'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">"upper right"</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">122</span>)</span><br><span class="line">    plt.plot(L)</span><br><span class="line">    plt.pause(<span class="number">0.01</span>)</span><br><span class="line">    print(<span class="string">f'Epoch: <span class="subst">&#123;epoch&#125;</span>, Loss: <span class="subst">&#123;L[<span class="number">-1</span>]&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">if</span> L[<span class="number">-1</span>] &lt; <span class="number">0.5</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">plt.ioff()</span><br><span class="line">plt.show()</span><br><span class="line">print(theta)</span><br></pre></td></tr></table></figure>
<h2 id="Softmax-Regression"><a href="#Softmax-Regression" class="headerlink" title="Softmax Regression"></a>Softmax Regression</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load Data</span></span><br><span class="line">LR = <span class="number">0.01</span></span><br><span class="line">MAX_EPOCH = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">theta = np.zeros((<span class="number">3</span>,<span class="number">2</span> ))</span><br><span class="line"><span class="comment"># theta = np.array([-16.38, 0.1483, 0.1589]).reshape(3, 1)</span></span><br><span class="line"></span><br><span class="line">rx = np.fromfile(<span class="string">'ex4/ex4x.dat'</span>, sep=<span class="string">'\n'</span>).reshape(<span class="number">-1</span>, <span class="number">2</span>)</span><br><span class="line">x = (rx - rx.mean(<span class="number">0</span>))/rx.std(<span class="number">0</span>) <span class="comment"># z-score 归一化</span></span><br><span class="line">x = np.hstack((np.ones((<span class="number">80</span>, <span class="number">1</span>)), x))</span><br><span class="line">y = np.fromfile(<span class="string">'ex4/ex4y.dat'</span>, sep=<span class="string">'\n'</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N = x.shape[<span class="number">0</span>]</span><br><span class="line">pos = (y == <span class="number">1</span>)[:, <span class="number">0</span>]</span><br><span class="line">neg = (y == <span class="number">0</span>)[:, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">loss = list()</span><br><span class="line">loss.clear()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GD</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> theta, x, y</span><br><span class="line">    grad = np.zeros((<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(theta.shape[<span class="number">1</span>]<span class="number">-1</span>):</span><br><span class="line">        theta_k = theta[:,k]</span><br><span class="line">        grad_k = np.zeros((<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> i,xi <span class="keyword">in</span> enumerate(x):</span><br><span class="line">            j = y[i,<span class="number">0</span>] <span class="comment"># the class  of current item</span></span><br><span class="line">            t = <span class="number">1</span> <span class="keyword">if</span> k==j <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            h_k = np.exp(xi.dot(theta_k))/np.exp(xi.dot(theta)).sum()</span><br><span class="line">            l += t*np.log(h_k)</span><br><span class="line">            grad_k += (xi.T*(t - h_k))[:,np.newaxis]</span><br><span class="line">        grad[:,k]= grad_k[:,<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> grad,l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SGD</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> theta, x, y</span><br><span class="line">    grad = np.zeros((<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = np.random.randint(<span class="number">0</span>, x.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(theta.shape[<span class="number">1</span>]<span class="number">-1</span>):</span><br><span class="line">        theta_k = theta[:,k]</span><br><span class="line">        xi = x[r]</span><br><span class="line">        j = y[r,<span class="number">0</span>] <span class="comment"># the class  of current item</span></span><br><span class="line">        t = <span class="number">1</span> <span class="keyword">if</span> k==j <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        h_k = np.exp(xi.dot(theta_k))/np.exp(xi.dot(theta)).sum()</span><br><span class="line">        l += t*np.log(h_k)</span><br><span class="line">        grad_k = (xi.T*(t - h_k))[:,np.newaxis]</span><br><span class="line">        grad[:,k]= grad_k[:,<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> grad,l</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimizer</span><span class="params">(method=<span class="string">'GD'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> theta,loss</span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">'GD'</span>:</span><br><span class="line">        grad,l = GD()</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">'SGD'</span>:</span><br><span class="line">        grad,l = SGD()</span><br><span class="line">    theta = theta + LR*grad</span><br><span class="line">    loss.append(np.exp(l))</span><br><span class="line"></span><br><span class="line">d = np.linspace(np.min(x[:, <span class="number">1</span>]), np.max(x[:, <span class="number">1</span>]), <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line">plt.ion()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(MAX_EPOCH):</span><br><span class="line">    optimizer(<span class="string">'SGD'</span>)</span><br><span class="line">    plt.figure(figsize=(<span class="number">12</span>, <span class="number">5</span>), dpi=<span class="number">80</span>)</span><br><span class="line">    plt.subplot(<span class="number">121</span>)</span><br><span class="line">    plt.xlim(np.min(x[:,<span class="number">1</span>]), np.max(x[:,<span class="number">1</span>]))</span><br><span class="line">    plt.ylim(np.min(x[:,<span class="number">2</span>]), np.max(x[:,<span class="number">2</span>]))</span><br><span class="line">    plt.scatter(x[pos, <span class="number">1</span>], x[pos, <span class="number">2</span>], marker=<span class="string">'+'</span>, label=<span class="string">"Admitted"</span>, c=<span class="string">'red'</span>)</span><br><span class="line">    plt.scatter(x[neg, <span class="number">1</span>],</span><br><span class="line">                x[neg, <span class="number">2</span>],</span><br><span class="line">                marker=<span class="string">'o'</span>,</span><br><span class="line">                label=<span class="string">'Not Admitted'</span>,</span><br><span class="line">                c=<span class="string">'blue'</span>)</span><br><span class="line">    plt.plot(d,</span><br><span class="line">             -(theta[<span class="number">0</span>, <span class="number">0</span>] + theta[<span class="number">1</span>, <span class="number">0</span>] * d) / theta[<span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">             <span class="string">'r'</span>,</span><br><span class="line">             c=<span class="string">'green'</span>,</span><br><span class="line">             label=<span class="string">'descision boundary'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">"upper right"</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">122</span>)</span><br><span class="line">    plt.ylim(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    plt.plot(loss)</span><br><span class="line">    plt.pause(<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f'Epoch: <span class="subst">&#123;epoch&#125;</span>, Loss: <span class="subst">&#123;loss[<span class="number">-1</span>]&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">plt.ioff()</span><br><span class="line">plt.show()</span><br><span class="line">print(theta)</span><br></pre></td></tr></table></figure>
<h2 id="Perceptron（感知器）"><a href="#Perceptron（感知器）" class="headerlink" title="Perceptron（感知器）"></a>Perceptron（感知器）</h2><ul>
<li>二分类<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load Data</span></span><br><span class="line">LR = <span class="number">0.5</span></span><br><span class="line">MAX_EPOCH = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">theta = np.zeros((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># theta = np.array([-16.38, 0.1483, 0.1589]).reshape(3, 1)</span></span><br><span class="line"></span><br><span class="line">rx = np.fromfile(<span class="string">'ex4/ex4x.dat'</span>, sep=<span class="string">'\n'</span>).reshape(<span class="number">-1</span>, <span class="number">2</span>)</span><br><span class="line">x = (rx - rx.mean(<span class="number">0</span>)) / rx.std(<span class="number">0</span>)  <span class="comment"># z-score 归一化</span></span><br><span class="line">x = np.hstack((np.ones((<span class="number">80</span>, <span class="number">1</span>)), x))</span><br><span class="line">rank = np.arange(<span class="number">0</span>, x.shape[<span class="number">0</span>])</span><br><span class="line">np.random.shuffle(rank)</span><br><span class="line">x = x[rank]</span><br><span class="line">y = np.fromfile(<span class="string">'ex4/ex4y.dat'</span>, sep=<span class="string">'\n'</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">y = y[rank]</span><br><span class="line">N = x.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">pos = (y == <span class="number">1</span>)[:, <span class="number">0</span>]</span><br><span class="line">neg = (y == <span class="number">0</span>)[:, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">threshold = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">d = np.linspace(np.min(x[:, <span class="number">1</span>]), np.max(x[:, <span class="number">1</span>]), <span class="number">100</span>)</span><br><span class="line">plt.ion()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(MAX_EPOCH):</span><br><span class="line">    error_count = <span class="number">0</span></span><br><span class="line">    err_idx = []</span><br><span class="line">    err_value = []</span><br><span class="line">    <span class="keyword">for</span> i, xi <span class="keyword">in</span> enumerate(x):</span><br><span class="line">        result = xi.dot(theta) &gt;= threshold</span><br><span class="line">        error_i = y[i, <span class="number">0</span>] - result</span><br><span class="line">        <span class="keyword">if</span> error_i != <span class="number">0</span>:</span><br><span class="line">            error_count += <span class="number">1</span></span><br><span class="line">            err_idx.append(i)</span><br><span class="line">            <span class="comment"># theta += LR * error_i * xi.reshape(-1, 1) #性能比较差</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机选取一个修改</span></span><br><span class="line">    idx = err_idx[np.random.randint(<span class="number">0</span>, len(err_idx))]</span><br><span class="line">    xr = x[idx, :]</span><br><span class="line">    result = xr.dot(theta) &gt;= threshold</span><br><span class="line">    err_i = y[idx, <span class="number">0</span>] - result</span><br><span class="line">    theta += LR * err_i * xr.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"Epoch: <span class="subst">&#123;epoch&#125;</span>, Error Count: <span class="subst">&#123;error_count&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        plt.clf()</span><br><span class="line"></span><br><span class="line">        x1_min, x1_max = x[:, <span class="number">1</span>].min() - <span class="number">.5</span>, x[:, <span class="number">1</span>].max() + <span class="number">.5</span></span><br><span class="line">        x2_min, x2_max = x[:, <span class="number">2</span>].min() - <span class="number">.5</span>, x[:, <span class="number">2</span>].max() + <span class="number">.5</span></span><br><span class="line">        step = <span class="number">0.02</span></span><br><span class="line">        xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, step), np.arange(x2_min, x2_max, step))</span><br><span class="line">        testData = np.c_[xx1.ravel(), xx2.ravel()]</span><br><span class="line">        testData = np.hstack((np.ones((testData.shape[<span class="number">0</span>], <span class="number">1</span>)), testData))</span><br><span class="line"></span><br><span class="line">        predicted = testData.dot(theta) &gt;= threshold</span><br><span class="line">        print(predicted.shape)</span><br><span class="line">        plt.pcolormesh(xx1, xx2, predicted.reshape(xx1.shape), cmap=<span class="string">'gray'</span>)</span><br><span class="line"></span><br><span class="line">        plt.scatter(x[pos, <span class="number">1</span>], x[pos, <span class="number">2</span>], marker=<span class="string">'+'</span>, label=<span class="string">"Admitted"</span>, c=<span class="string">'red'</span>)</span><br><span class="line">        plt.scatter(x[neg, <span class="number">1</span>],</span><br><span class="line">                    x[neg, <span class="number">2</span>],</span><br><span class="line">                    marker=<span class="string">'o'</span>,</span><br><span class="line">                    label=<span class="string">'Not Admitted'</span>,</span><br><span class="line">                    c=<span class="string">'blue'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># plt.scatter(x[err_idx, 1],</span></span><br><span class="line">        <span class="comment">#             x[err_idx, 2],</span></span><br><span class="line">        <span class="comment">#             marker='^',</span></span><br><span class="line">        <span class="comment">#             label='Error',</span></span><br><span class="line">        <span class="comment">#             c='orange')</span></span><br><span class="line"></span><br><span class="line">        plt.legend(loc=<span class="string">"upper left"</span>)</span><br><span class="line">        plt.pause(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> error_count == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(theta)</span><br><span class="line"></span><br><span class="line">plt.ioff()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>分类算法</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch-Tutorial</title>
    <url>/2019/09/27/PyTorch-Tutorial/</url>
    <content><![CDATA[<h1 id="Pytorch-Tutorial"><a href="#Pytorch-Tutorial" class="headerlink" title="Pytorch Tutorial"></a>Pytorch Tutorial</h1><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.empty(<span class="number">5</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([-7.0454e+16,  4.5602e-41, -7.0454e+16,  4.5602e-41,  4.4842e-44])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.2868, -0.7095, -0.2244,  0.0359, -0.0446],
        [ 0.9009, -1.4887,  1.1688, -0.8644, -0.2834],
        [ 0.6291, -0.7237,  0.1425,  0.7541, -0.8514]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.zeros(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.long)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">5.5</span>, <span class="number">3</span>])</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([5.5000, 3.0000])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = x.new_ones(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.double)</span><br><span class="line">print(x)</span><br><span class="line">x = torch.randn_like(x, dtype=torch.float)    <span class="comment"># override dtype!</span></span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 0.5359, -0.6125,  0.4776],
        [ 1.6412, -0.6522,  1.3568],
        [ 0.5305, -1.7568,  1.7467],
        [-0.2996, -0.2183, -0.9193],
        [ 1.4179, -0.1998, -0.9144]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x.size())</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([5, 3])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.randn(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(x + y)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.7118, -0.8840,  2.0376],
        [-0.6116, -1.1469,  1.6384],
        [ 0.6491, -2.3616,  2.1900],
        [-0.7521, -1.1007, -1.9134],
        [-0.2323, -0.4377,  0.5033]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(torch.add(x, y))</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.7118, -0.8840,  2.0376],
        [-0.6116, -1.1469,  1.6384],
        [ 0.6491, -2.3616,  2.1900],
        [-0.7521, -1.1007, -1.9134],
        [-0.2323, -0.4377,  0.5033]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = torch.empty(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">torch.add(x, y, out=result)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.7118, -0.8840,  2.0376],
        [-0.6116, -1.1469,  1.6384],
        [ 0.6491, -2.3616,  2.1900],
        [-0.7521, -1.1007, -1.9134],
        [-0.2323, -0.4377,  0.5033]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># adds x to y</span></span><br><span class="line">y.add_(x)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.1759, -1.4965,  2.5152],
        [ 1.0296, -1.7991,  2.9952],
        [ 1.1797, -4.1185,  3.9367],
        [-1.0517, -1.3190, -2.8327],
        [ 1.1856, -0.6375, -0.4111]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x[:, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<pre><code>tensor([-0.6125, -0.6522, -1.7568, -0.2183, -0.1998])
</code></pre><p><strong>Resizing:</strong> If you want to resize/reshape tensor, you can use <code>torch.view</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">y = x.view(<span class="number">16</span>)</span><br><span class="line">z = x.view(<span class="number">-1</span>, <span class="number">8</span>)  <span class="comment"># the size -1 is inferred from other dimensions</span></span><br><span class="line">print(x.size(), y.size(), z.size())</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([4, 4]) torch.Size([16]) torch.Size([2, 8])
</code></pre><p>If you have a one element tensor, use <code>.item()</code> to get the value as a Python number</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">1</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(x.item())</span><br></pre></td></tr></table></figure>
<pre><code>tensor([-0.5195])
-0.5194937586784363
</code></pre><h2 id="Converting-a-Torch-Tensor-to-a-NumPy-Array"><a href="#Converting-a-Torch-Tensor-to-a-NumPy-Array" class="headerlink" title="Converting a Torch Tensor to a NumPy Array"></a>Converting a Torch Tensor to a NumPy Array</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.ones(<span class="number">5</span>)</span><br><span class="line">print(a)</span><br><span class="line">b = a.numpy()</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([1., 1., 1., 1., 1.])
[1. 1. 1. 1. 1.]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.add_(<span class="number">1</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([2., 2., 2., 2., 2.])
[2. 2. 2. 2. 2.]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.ones(<span class="number">5</span>)</span><br><span class="line">b = torch.from_numpy(a)</span><br><span class="line">np.add(a, <span class="number">1</span>, out=a)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<pre><code>[2. 2. 2. 2. 2.]
tensor([2., 2., 2., 2., 2.], dtype=torch.float64)
</code></pre><h2 id="AUTOGRAD-AUTOMATIC-DIFFERENTIATION"><a href="#AUTOGRAD-AUTOMATIC-DIFFERENTIATION" class="headerlink" title="AUTOGRAD: AUTOMATIC DIFFERENTIATION"></a>AUTOGRAD: AUTOMATIC DIFFERENTIATION</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.ones(<span class="number">2</span>, <span class="number">2</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[1., 1.],
        [1., 1.]], requires_grad=True)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = x + <span class="number">2</span></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[3., 3.],
        [3., 3.]], grad_fn=&lt;AddBackward0&gt;)
</code></pre><p><code>y</code> was created as a result of an operation, so it has a <code>grad_fn</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(y.grad_fn)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;AddBackward0 object at 0x7f1f65224a58&gt;
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = y * y * <span class="number">3</span></span><br><span class="line">out = z.mean()</span><br><span class="line">print(z, out)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[27., 27.],
        [27., 27.]], grad_fn=&lt;MulBackward0&gt;) tensor(27., grad_fn=&lt;MeanBackward0&gt;)
</code></pre><p><code>.requires_grad_( ... )</code> changes an existing Tensor’s <code>requires_grad</code> flag in-place. The input flag defaults to <code>False</code> if not given.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">a = ((a * <span class="number">3</span>) / (a - <span class="number">1</span>))</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">a.requires_grad_(<span class="literal">True</span>)</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">b = (a * a).sum()</span><br><span class="line">print(b.grad_fn)</span><br></pre></td></tr></table></figure>
<pre><code>False
True
&lt;SumBackward0 object at 0x7f1f65a18ba8&gt;
</code></pre><p>Let’s backprop now. Because <code>out</code> contains a single scalar, <code>out.backward()</code> is equivalent to <code>out.backward(torch.tensor(1.))</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out.backward()</span><br></pre></td></tr></table></figure>
<p>Print gradients d(out)/dx</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[4.5000, 4.5000],
        [4.5000, 4.5000]])
</code></pre><p>You should have got a matrix of <code>4.5</code>. Let’s call the <code>out</code> Tensor “o”. We have that $o = \frac{1}{4}\sum<em>i z_i$, $z_i = 3(x_i+2)^2$ and $z_i\bigr\rvert</em>{x<em>i=1} = 27$. Therefore, $\frac{\partial o}{\partial x_i} = \frac{3}{2}(x_i+2)$, hence $\frac{\partial o}{\partial x_i}\bigr\rvert</em>{x_i=1} = \frac{9}{2} = 4.5$.</p>
<p>Mathematically, if you have a vector valued function $\vec{y}=f(\vec{x})$, then the gradient of $\vec{y}$  with respect to $\vec{x}$  is a Jacobian matrix:</p>
<script type="math/tex; mode=display">\begin{split}J=\left(\begin{array}{ccc}
 \frac{\partial y_{1}}{\partial x_{1}} & \cdots & \frac{\partial y_{1}}{\partial x_{n}}\\
 \vdots & \ddots & \vdots\\
 \frac{\partial y_{m}}{\partial x_{1}} & \cdots & \frac{\partial y_{m}}{\partial x_{n}}
 \end{array}\right)\end{split}</script><p>Generally speaking, <code>torch.autograd</code> is an engine for computing vector-Jacobian product. That is, given any vector $v=\left(\begin{array}{cccc} v<em>{1} &amp; v</em>{2} &amp; \cdots &amp; v<em>{m}\end{array}\right)^{T}$, compute the product $v^{T}\cdot J$. If $v$ happens to be the gradient of a scalar function $l=g\left(\vec{y}\right)$, that is, $v=\left(\begin{array}{ccc}\frac{\partial l}{\partial y</em>{1}} &amp; \cdots &amp; \frac{\partial l}{\partial y_{m}}\end{array}\right)^{T}$, then by the chain rule, the vector-Jacobian product would be the gradient of $l$ with respect to $\vec{x}$ :</p>
<script type="math/tex; mode=display">\begin{split}J^{T}\cdot v=\left(\begin{array}{ccc}
 \frac{\partial y_{1}}{\partial x_{1}} & \cdots & \frac{\partial y_{m}}{\partial x_{1}}\\
 \vdots & \ddots & \vdots\\
 \frac{\partial y_{1}}{\partial x_{n}} & \cdots & \frac{\partial y_{m}}{\partial x_{n}}
 \end{array}\right)\left(\begin{array}{c}
 \frac{\partial l}{\partial y_{1}}\\
 \vdots\\
 \frac{\partial l}{\partial y_{m}}
 \end{array}\right)=\left(\begin{array}{c}
 \frac{\partial l}{\partial x_{1}}\\
 \vdots\\
 \frac{\partial l}{\partial x_{n}}
 \end{array}\right)\end{split}</script><p> (Note that $v^T⋅J$ gives a row vector which can be treated as a column vector by taking $J^T⋅v$.)</p>
<p>This characteristic of vector-Jacobian product makes it very convenient to feed external gradients into a model that has non-scalar output.</p>
<p>Now let’s take a look at an example of vector-Jacobian product:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = x * <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> y.data.norm() &lt; <span class="number">1000</span>: <span class="comment"># y.data 的 2 范数</span></span><br><span class="line">    y = y * <span class="number">2</span></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([ 243.8343, 1859.5187,  433.1491], grad_fn=&lt;MulBackward0&gt;)
</code></pre><p>Now in this case <code>y</code> is no longer a scalar. <code>torch.autograd</code> could not compute the full Jacobian directly, but if we just want the vector-Jacobian product, simply pass the vector to <code>backward</code> as argument:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v = torch.tensor([<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">0.0001</span>], dtype=torch.float)</span><br><span class="line">y.backward(v)</span><br><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([1.0240e+02, 1.0240e+03, 1.0240e-01])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x.requires_grad)</span><br><span class="line">print((x ** <span class="number">2</span>).requires_grad)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    print((x ** <span class="number">2</span>).requires_grad)</span><br></pre></td></tr></table></figure>
<pre><code>True
True
False
</code></pre><h2 id="NEURAL-NETWORKS"><a href="#NEURAL-NETWORKS" class="headerlink" title="NEURAL NETWORKS"></a>NEURAL NETWORKS</h2><p>Neural networks can be constructed using the <code>torch.nn</code> package.</p>
<p>Now that you had a glimpse of <code>autograd</code>, <code>nn</code> depends on <code>autograd</code> to define models and differentiate them. An <code>nn.Module</code> contains layers, and a method <code>forward(input)</code>that returns the <code>output</code>.</p>
<p>For example, look at this network that classifies digit images:</p>
<p><img src="https://pytorch.org/tutorials/_images/mnist.png" alt="fsd"></p>
<h3 id="Define-the-network"><a href="#Define-the-network" class="headerlink" title="Define the network"></a>Define the network</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        <span class="comment"># 1 input image channel, 6 output channels, 3x3 square convolution</span></span><br><span class="line">        <span class="comment"># kernel</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># an affine operation: y = Wx + b</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">6</span> * <span class="number">6</span>, <span class="number">120</span>)  <span class="comment"># 6*6 from image dimension</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>) </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># Max pooling over a (2, 2) window</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), (<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="comment"># If the size is a square you can only specify a single number</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv2(x)), <span class="number">2</span>)</span><br><span class="line">        x = x.view(<span class="number">-1</span>, self.num_flat_features(x))</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_flat_features</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        size = x.size()[<span class="number">1</span>:]  <span class="comment"># all dimensions except the batch dimension</span></span><br><span class="line">        num_features = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> size:</span><br><span class="line">            num_features *= s</span><br><span class="line">        <span class="keyword">return</span> num_features</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line">print(net)</span><br></pre></td></tr></table></figure>
<pre><code>Net(
  (conv1): Conv2d(1, 6, kernel_size=(3, 3), stride=(1, 1))
  (conv2): Conv2d(6, 16, kernel_size=(3, 3), stride=(1, 1))
  (fc1): Linear(in_features=576, out_features=120, bias=True)
  (fc2): Linear(in_features=120, out_features=84, bias=True)
  (fc3): Linear(in_features=84, out_features=10, bias=True)
)
</code></pre><p>You just have to define the <code>forward</code> function, and the <code>backward</code> function (where gradients are computed) is automatically defined for you using <code>autograd</code>. You can use any of the Tensor operations in the <code>forward</code> function.</p>
<p>The learnable parameters of a model are returned by <code>net.parameters()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = list(net.parameters())</span><br><span class="line">print(len(params))</span><br><span class="line">print(params[<span class="number">0</span>].size())  <span class="comment"># conv1's .weight</span></span><br></pre></td></tr></table></figure>
<pre><code>10
torch.Size([6, 1, 3, 3])
</code></pre><p>Let try a random 32x32 input. Note: expected input size of this net (LeNet) is 32x32. To use this net on MNIST dataset, please resize the images from the dataset to 32x32.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input = torch.randn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line">out = net(input)</span><br><span class="line">print(out)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 0.0251,  0.0173,  0.0737, -0.0636,  0.0445, -0.0363,  0.0201,  0.0686,
         -0.1066,  0.0272]], grad_fn=&lt;AddmmBackward&gt;)
</code></pre><p>Zero the gradient buffers of all parameters and backprops with random gradients:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net.zero_grad()</span><br><span class="line">out.backward(torch.randn(<span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>For example, <code>nn.Conv2d</code> will take in a 4D Tensor of <code>nSamples x nChannels x Height x Width</code>.</p>
<p>If you have a single sample, just use <code>input.unsqueeze(0)</code> to add a fake batch dimension.</p>
<p>Recap:</p>
<ul>
<li><code>torch.Tensor</code> - A multi-dimensional array with support for autograd operations like <code>backward()</code>. Also holds the gradient w.r.t. the tensor.</li>
<li><code>nn.Module</code> - Neural network module. Convenient way of encapsulating parameters, with helpers for moving them to GPU, exporting, loading, etc.</li>
<li><code>nn.Parameter</code> - A kind of Tensor, that is automatically registered as a parameter when assigned as an attribute to a <code>Module</code>.</li>
<li><code>autograd.Function</code> - Implements forward and backward definitions of an <code>autograd</code> operation. Every <code>Tensor</code> operation creates at least a single <code>Function</code> node that connects to functions that created a <code>Tensor</code> and encodes its history.</li>
</ul>
<h3 id="Loss-Function"><a href="#Loss-Function" class="headerlink" title="Loss Function"></a>Loss Function</h3><p>A loss function takes the (output, target) pair of inputs, and computes a value that estimates how far away the output is from the target.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output = net(input)</span><br><span class="line">target = torch.randn(<span class="number">10</span>)  <span class="comment"># a dummy target, for example</span></span><br><span class="line">target = target.view(<span class="number">1</span>, <span class="number">-1</span>)  <span class="comment"># make it the same shape as output</span></span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">print(loss)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 0.0251,  0.0173,  0.0737, -0.0636,  0.0445, -0.0363,  0.0201,  0.0686,
         -0.1066,  0.0272]], grad_fn=&lt;AddmmBackward&gt;)
tensor([[ 0.9742,  0.1312, -0.3844, -0.8399, -0.9474, -0.1069,  0.2654, -0.1648,
          0.0786, -1.5961]])
tensor(0.5499, grad_fn=&lt;MseLossBackward&gt;)
</code></pre><p>Now, if you follow <code>loss</code> in the backward direction, using its <code>.grad_fn</code> attribute, you will see a graph of computations that looks like this:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; conv2d -&gt; relu -&gt; maxpool2d</span><br><span class="line">      -&gt; view -&gt; linear -&gt; relu -&gt; linear -&gt; relu -&gt; linear</span><br><span class="line">      -&gt; MSELoss</span><br><span class="line">      -&gt; loss</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(loss.grad_fn)  <span class="comment"># MSELoss</span></span><br><span class="line">print(loss.grad_fn.next_functions[<span class="number">0</span>][<span class="number">0</span>])  <span class="comment"># Linear</span></span><br><span class="line">print(loss.grad_fn.next_functions[<span class="number">0</span>][<span class="number">0</span>].next_functions[<span class="number">0</span>][<span class="number">0</span>])  <span class="comment"># ReLU</span></span><br></pre></td></tr></table></figure>
<pre><code>&lt;MseLossBackward object at 0x7f8589ab59b0&gt;
&lt;AddmmBackward object at 0x7f85894d5400&gt;
&lt;AccumulateGrad object at 0x7f8589ab59b0&gt;
</code></pre><h3 id="Backprop"><a href="#Backprop" class="headerlink" title="Backprop"></a>Backprop</h3><p>To backpropagate the error all we have to do is to <code>loss.backward()</code>. You need to clear the existing gradients though, else gradients will be accumulated to existing gradients.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net.zero_grad()     <span class="comment"># zeroes the gradient buffers of all parameters</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'conv1.bias.grad before backward'</span>)</span><br><span class="line">print(net.conv1.bias.grad)</span><br><span class="line"></span><br><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'conv1.bias.grad after backward'</span>)</span><br><span class="line">print(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure>
<pre><code>conv1.bias.grad before backward
tensor([0., 0., 0., 0., 0., 0.])
conv1.bias.grad after backward
tensor([-0.0092,  0.0072, -0.0021, -0.0014,  0.0019, -0.0038])
</code></pre><h3 id="Update-the-weights"><a href="#Update-the-weights" class="headerlink" title="Update the weights"></a>Update the weights</h3><p>The simplest update rule used in practice is the Stochastic Gradient Descent (SGD):</p>
<p><code>weight = weight - learning_rate * gradient</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> net.parameters():</span><br><span class="line">    f.data.sub_(f.grad.data * learning_rate)</span><br></pre></td></tr></table></figure>
<p>However, as you use neural networks, you want to use various different update rules such as SGD, Nesterov-SGD, Adam, RMSProp, etc. To enable this, we built a small package: <code>torch.optim</code> that implements all these methods. Using it is very simple:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># create your optimizer</span></span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in your training loop:</span></span><br><span class="line">optimizer.zero_grad()   <span class="comment"># zero the gradient buffers</span></span><br><span class="line">output = net(input)</span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()    <span class="comment"># Does the update</span></span><br></pre></td></tr></table></figure>
<h2 id="TRAINING-A-CLASSIFIER"><a href="#TRAINING-A-CLASSIFIER" class="headerlink" title="TRAINING A CLASSIFIER"></a>TRAINING A CLASSIFIER</h2><h3 id="What-about-data"><a href="#What-about-data" class="headerlink" title="What about data?"></a>What about data?</h3><p>Generally, when you have to deal with image, text, audio or video data, you can use standard python packages that load data into a numpy array. Then you can convert this array into a <code>torch.*Tensor</code>.</p>
<ul>
<li>For images, packages such as <code>Pillow</code>, <code>OpenCV</code> are useful</li>
<li>For audio, packages such as <code>scipy</code> and <code>librosa</code></li>
<li>For text, either raw Python or Cython based loading, or NLTK and SpaCy are useful</li>
</ul>
<p>Specifically for vision, we have created a package called <code>torchvision</code>, that has data loaders for common datasets such as Imagenet, CIFAR10, MNIST, etc. and data transformers for images, viz., <code>torchvision.datasets</code> and <code>torch.utils.data.DataLoader</code>.</p>
<p>For this tutorial, we will use the CIFAR10 dataset. It has the classes: ‘airplane’, ‘automobile’, ‘bird’, ‘cat’, ‘deer’, ‘dog’, ‘frog’, ‘horse’, ‘ship’, ‘truck’. The images in CIFAR-10 are of size 3x32x32, i.e. 3-channel color images of 32x32 pixels in size.</p>
<p><img src="https://pytorch.org/tutorials/_images/cifar10.png" alt></p>
<h3 id="Training-an-image-classifier"><a href="#Training-an-image-classifier" class="headerlink" title="Training an image classifier"></a>Training an image classifier</h3><p>We will do the following steps in order:</p>
<ol>
<li>Load and normalizing the CIFAR10 training and test datasets <code>using torchvision</code></li>
<li>Define a Convolutional Neural Network</li>
<li>Define a loss function</li>
<li>Train the network on the training data</li>
<li>Test the network on the test data</li>
</ol>
<h4 id="1-Loading-and-normalizing-CIFAR10"><a href="#1-Loading-and-normalizing-CIFAR10" class="headerlink" title="1. Loading and normalizing CIFAR10"></a>1. Loading and normalizing CIFAR10</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br></pre></td></tr></table></figure>
<p>The output of torchvision datasets are PILImage images of range [0, 1]. We transform them to Tensors of normalized range [-1, 1]. .. note:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If running on Windows and you get a BrokenPipeError, try setting</span><br><span class="line">the num_worker of torch.utils.data.DataLoader() to 0.</span><br></pre></td></tr></table></figure></p>
<p>Note: transforms.Normalize(mean,std)</p>
<p>z-score 规范化(零均值规范化)</p>
<script type="math/tex; mode=display">
input = \frac{input - mean}{std}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transform = transforms.Compose(</span><br><span class="line">    [transforms.ToTensor(),</span><br><span class="line">     transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))])</span><br><span class="line"></span><br><span class="line">trainset = torchvision.datasets.CIFAR10(root=<span class="string">'./data'</span>, train=<span class="literal">True</span>,</span><br><span class="line">                                        download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">trainloader = torch.utils.data.DataLoader(trainset, batch_size=<span class="number">4</span>,</span><br><span class="line">                                          shuffle=<span class="literal">True</span>, num_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">testset = torchvision.datasets.CIFAR10(root=<span class="string">'./data'</span>, train=<span class="literal">False</span>,</span><br><span class="line">                                       download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">testloader = torch.utils.data.DataLoader(testset, batch_size=<span class="number">4</span>,</span><br><span class="line">                                         shuffle=<span class="literal">False</span>, num_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">classes = (<span class="string">'plane'</span>, <span class="string">'car'</span>, <span class="string">'bird'</span>, <span class="string">'cat'</span>,</span><br><span class="line">           <span class="string">'deer'</span>, <span class="string">'dog'</span>, <span class="string">'frog'</span>, <span class="string">'horse'</span>, <span class="string">'ship'</span>, <span class="string">'truck'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Downloading https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz to ./data/cifar-10-python.tar.gz


100.0%

Files already downloaded and verified
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># functions to show an image</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imshow</span><span class="params">(img)</span>:</span></span><br><span class="line">    img = img / <span class="number">2</span> + <span class="number">0.5</span>     <span class="comment"># unnormalize</span></span><br><span class="line">    npimg = img.numpy()</span><br><span class="line">    plt.imshow(np.transpose(npimg, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)))</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># get some random training images</span></span><br><span class="line">dataiter = iter(trainloader)</span><br><span class="line">images, labels = dataiter.next() <span class="comment"># image size(4, 1, 32, 32) nSamples nChannels Height Width</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># show images</span></span><br><span class="line">imshow(torchvision.utils.make_grid(images))</span><br><span class="line"><span class="comment"># print labels</span></span><br><span class="line">print(<span class="string">' '</span>.join(<span class="string">'%5s'</span> % classes[labels[j]] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>
<p><img src="images/output_74_0.png" alt="png"></p>
<pre><code>  cat horse  deer truck
</code></pre><h4 id="2-Define-a-Convolutional-Neural-Network"><a href="#2-Define-a-Convolutional-Neural-Network" class="headerlink" title="2. Define a` Convolutional Neural Network"></a>2. Define a` Convolutional Neural Network</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.pool(F.relu(self.conv1(x)))</span><br><span class="line">        x = self.pool(F.relu(self.conv2(x)))</span><br><span class="line">        x = x.view(<span class="number">-1</span>, <span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">net = Net()</span><br></pre></td></tr></table></figure>
<h4 id="3-Define-a-Loss-function-and-optimizer"><a href="#3-Define-a-Loss-function-and-optimizer" class="headerlink" title="3. Define a Loss function and optimizer"></a>3. Define a Loss function and optimizer</h4><p>Let’s use a Classification Cross-Entropy loss and SGD with momentum.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>
<h4 id="4-Train-the-network"><a href="#4-Train-the-network" class="headerlink" title="4. Train the network"></a>4. Train the network</h4><p>This is when things start to get interesting. We simply have to loop over our data iterator, and feed the inputs to the network and optimize.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">2</span>):  <span class="comment"># loop over the dataset multiple times</span></span><br><span class="line"></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(trainloader, <span class="number">0</span>):</span><br><span class="line">        <span class="comment"># get the inputs; data is a list of [inputs, labels]</span></span><br><span class="line">        inputs, labels = data</span><br><span class="line"></span><br><span class="line">        <span class="comment"># zero the parameter gradients</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># forward + backward + optimize</span></span><br><span class="line">        outputs = net(inputs)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print statistics</span></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2000</span> == <span class="number">1999</span>:    <span class="comment"># print every 2000 mini-batches</span></span><br><span class="line">            print(<span class="string">'[%d, %5d] loss: %.3f'</span> %</span><br><span class="line">                  (epoch + <span class="number">1</span>, i + <span class="number">1</span>, running_loss / <span class="number">2000</span>))</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'Finished Training'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[1,  2000] loss: 2.242
[1,  4000] loss: 1.987
[1,  6000] loss: 1.758
[1,  8000] loss: 1.639
[1, 10000] loss: 1.543
[1, 12000] loss: 1.508
[2,  2000] loss: 1.426
[2,  4000] loss: 1.390
[2,  6000] loss: 1.363
[2,  8000] loss: 1.351
[2, 10000] loss: 1.335
[2, 12000] loss: 1.299
Finished Training
</code></pre><h4 id="5-Test-the-network-on-the-test-data"><a href="#5-Test-the-network-on-the-test-data" class="headerlink" title="5. Test the network on the test data"></a>5. Test the network on the test data</h4><p>We have trained the network for 2 passes over the training dataset. But we need to check if the network has learnt anything at all.</p>
<p>We will check this by predicting the class label that the neural network outputs, and checking it against the ground-truth. If the prediction is correct, we add the sample to the list of correct predictions.</p>
<p>Okay, first step. Let us display an image from the test set to get familiar.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataiter = iter(testloader)</span><br><span class="line">images, labels = dataiter.next()</span><br><span class="line"></span><br><span class="line"><span class="comment"># print images</span></span><br><span class="line">imshow(torchvision.utils.make_grid(images))</span><br><span class="line">print(<span class="string">'GroundTruth: '</span>, <span class="string">' '</span>.join(<span class="string">'%5s'</span> % classes[labels[j]] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>
<p><img src="images/output_82_0.png" alt="png"></p>
<pre><code>GroundTruth:    cat  ship  ship plane
</code></pre><p>Okay, now let us see what the neural network thinks these examples above are:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">outputs = net(images)</span><br></pre></td></tr></table></figure>
<p>The outputs are energies for the 10 classes. The higher the energy for a class, the more the network thinks that the image is of the particular class. So, let’s get the index of the highest energy:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, predicted = torch.max(outputs, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Predicted: '</span>, <span class="string">' '</span>.join(<span class="string">'%5s'</span> % classes[predicted[j]]</span><br><span class="line">                              <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>
<pre><code>Predicted:    cat  ship  ship  ship
</code></pre><p>Let us look at how the network performs on the whole dataset.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">correct = <span class="number">0</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> testloader:</span><br><span class="line">        images, labels = data</span><br><span class="line">        outputs = net(images)</span><br><span class="line">        _, predicted = torch.max(outputs.data, <span class="number">1</span>)</span><br><span class="line">        total += labels.size(<span class="number">0</span>)</span><br><span class="line">        correct += (predicted == labels).sum().item()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy of the network on the 10000 test images: %d %%'</span> % (</span><br><span class="line">    <span class="number">100</span> * correct / total))</span><br></pre></td></tr></table></figure>
<pre><code>Accuracy of the network on the 10000 test images: 53 %
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class_correct = list(<span class="number">0.</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">class_total = list(<span class="number">0.</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> testloader:</span><br><span class="line">        images, labels = data</span><br><span class="line">        outputs = net(images)</span><br><span class="line">        _, predicted = torch.max(outputs, <span class="number">1</span>)</span><br><span class="line">        c = (predicted == labels).squeeze()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            label = labels[i]</span><br><span class="line">            class_correct[label] += c[i].item()</span><br><span class="line">            class_total[label] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(<span class="string">'Accuracy of %5s : %2d %%'</span> % (</span><br><span class="line">        classes[i], <span class="number">100</span> * class_correct[i] / class_total[i]))</span><br></pre></td></tr></table></figure>
<pre><code>Accuracy of plane : 57 %
Accuracy of   car : 67 %
Accuracy of  bird : 22 %
Accuracy of   cat : 46 %
Accuracy of  deer : 61 %
Accuracy of   dog : 28 %
Accuracy of  frog : 53 %
Accuracy of horse : 65 %
Accuracy of  ship : 79 %
Accuracy of truck : 53 %
</code></pre><h3 id="Training-on-GPU"><a href="#Training-on-GPU" class="headerlink" title="Training on GPU"></a>Training on GPU</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assuming that we are on a CUDA machine, this should print a CUDA device:</span></span><br><span class="line"></span><br><span class="line">print(device)</span><br><span class="line"></span><br><span class="line">net.to(device)</span><br><span class="line"></span><br><span class="line">inputs, labels = data[<span class="number">0</span>].to(device), data[<span class="number">1</span>].to(device)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>numpy &amp; panda 基础教程</title>
    <url>/2019/06/30/numpy-and-pandas/</url>
    <content><![CDATA[<h1 id="Numpy-和-Pandas"><a href="#Numpy-和-Pandas" class="headerlink" title="Numpy 和 Pandas"></a>Numpy 和 Pandas</h1><h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><h3 id="基本数学"><a href="#基本数学" class="headerlink" title="基本数学"></a>基本数学</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">array = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">print(array)</span><br><span class="line">print(<span class="string">'number of dim:'</span>,array.ndim)</span><br><span class="line">print(<span class="string">'shape:'</span>,array.shape)</span><br><span class="line">print(<span class="string">'size:'</span>,array.size)</span><br></pre></td></tr></table></figure>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=np.int)</span><br><span class="line">print(a.dtype)</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=np.int32)</span><br><span class="line">print(a.dtype)</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=np.int16)</span><br><span class="line">print(a.dtype)</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=np.float)</span><br><span class="line">print(a.dtype)</span><br><span class="line">a = np.zeros((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">print(a)</span><br><span class="line">a = np.ones((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">print(a)</span><br><span class="line">a = np.empty((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">print(a)</span><br><span class="line">a = np.arange(<span class="number">10</span>,<span class="number">20</span>,<span class="number">2</span>)</span><br><span class="line">print(a)</span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 生成线段，1-10 分成20段</span></span><br><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<h3 id="Numpy-运算"><a href="#Numpy-运算" class="headerlink" title="Numpy 运算"></a>Numpy 运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">b= np.arange(<span class="number">4</span>)</span><br><span class="line">c = a-b</span><br><span class="line">print(a,b)</span><br><span class="line">print(c)</span><br><span class="line">print(b**<span class="number">2</span>)</span><br><span class="line">print(b&lt;<span class="number">3</span>)</span><br><span class="line">print(b==<span class="number">3</span>)</span><br><span class="line">print(a<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">b = np.arange(<span class="number">4</span>).reshape((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">c = a*b</span><br><span class="line">c_dot = np.dot(a,b) <span class="comment"># 矩阵乘法</span></span><br><span class="line">c_dot_2 = a.dot(b)</span><br><span class="line">print(c)</span><br><span class="line">print(c_dot)</span><br><span class="line">print(c_dot_2)</span><br><span class="line"></span><br><span class="line">a = np.random.random((<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">print(a)</span><br><span class="line">print(np.sum(a))</span><br><span class="line">print(np.min(a))</span><br><span class="line">print(np.max(a))</span><br><span class="line"></span><br><span class="line">print(np.sum(a,axis=<span class="number">1</span>)) <span class="comment"># 行里求和</span></span><br><span class="line">print(np.min(a,axis=<span class="number">0</span>)) <span class="comment"># 列里找最小值</span></span><br><span class="line">print(np.max(a,axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Numpy-的索引"><a href="#Numpy-的索引" class="headerlink" title="Numpy 的索引"></a>Numpy 的索引</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.arange(<span class="number">2</span>,<span class="number">14</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(A)</span><br><span class="line">print(np.argmin(A)) <span class="comment"># 最小值索引</span></span><br><span class="line">print(np.argmax(A))</span><br><span class="line">print(np.mean(A)) <span class="comment"># 平均值</span></span><br><span class="line">print(A.mean())</span><br><span class="line">print(np.average(A))</span><br><span class="line">print(np.median(A)) <span class="comment"># 矩阵的中位数</span></span><br><span class="line">print(np.cumsum(A)) <span class="comment"># 累加</span></span><br><span class="line">print(np.diff(A)) <span class="comment"># 累差 相邻元素的差 3*4 = &gt; 3*3</span></span><br><span class="line">print(np.nonzero(A)) <span class="comment"># 非零，两个Array，第一个行数，第二个列数</span></span><br><span class="line">B = np.arange(<span class="number">14</span>,<span class="number">2</span>,<span class="number">-1</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(np.sort(B))</span><br><span class="line">print(np.transpose(A)) <span class="comment"># 矩阵转置</span></span><br><span class="line">print((A.T).dot(A))</span><br><span class="line"></span><br><span class="line">print(np.clip(A,<span class="number">5</span>,<span class="number">9</span>)) <span class="comment"># 截取，小于5变成5，大于9变成9</span></span><br><span class="line"><span class="comment"># 以上都可以指定axis计算</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.arange(<span class="number">3</span>,<span class="number">15</span>)</span><br><span class="line">print(A)</span><br><span class="line">print(A[<span class="number">3</span>])</span><br><span class="line">A = np.reshape(A,(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(A)</span><br><span class="line">print(A[<span class="number">2</span>])</span><br><span class="line">print(A[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">print(A[<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">print(A[<span class="number">2</span>,:])</span><br><span class="line">print(A[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line">print(A[<span class="number">2</span>,<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line">print(A[:,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">print(A)</span><br><span class="line">print(<span class="string">'*'</span>*<span class="number">3</span>,<span class="string">'行迭代：'</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> A:</span><br><span class="line">    print(row)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'*'</span>*<span class="number">3</span>,<span class="string">'列迭代：'</span>)</span><br><span class="line">print(A.T)</span><br><span class="line"><span class="keyword">for</span> column <span class="keyword">in</span> A.T:</span><br><span class="line">    print(column)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'*'</span>*<span class="number">3</span>,<span class="string">'元素迭代：'</span>)</span><br><span class="line">print(A.flatten())</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> A.flat: <span class="comment"># A编程一行 A.flat 是迭代器</span></span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>
<h3 id="Numpy的array-合并"><a href="#Numpy的array-合并" class="headerlink" title="Numpy的array 合并"></a>Numpy的array 合并</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">B = np.array([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">C = np.vstack((A,B))<span class="comment"># vertical stack 垂直合并</span></span><br><span class="line">D = np.hstack((A,B)) <span class="comment"># horizontal stack 水平合并</span></span><br><span class="line">print(C)</span><br><span class="line">print(A.shape,C.shape)</span><br><span class="line"></span><br><span class="line">print(D)</span><br><span class="line">print(A.shape,D.shape)</span><br><span class="line"></span><br><span class="line">print(A[np.newaxis,:]) <span class="comment"># 在行上面加维度</span></span><br><span class="line">print(A[np.newaxis,:].shape) <span class="comment"># 在行上面加维度</span></span><br><span class="line"></span><br><span class="line">print(A[:,np.newaxis]) <span class="comment"># 在行上面加维度</span></span><br><span class="line">print(A[:,np.newaxis].shape) <span class="comment"># 在列上面加维度</span></span><br><span class="line"></span><br><span class="line">A = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])[:,np.newaxis]</span><br><span class="line">B = np.array([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])[:,np.newaxis]</span><br><span class="line">E = np.concatenate((A,B,B,A),axis=<span class="number">0</span>) <span class="comment"># 纵向合并</span></span><br><span class="line">F = np.concatenate((A,B,B,A),axis=<span class="number">1</span>) <span class="comment"># 横向合并</span></span><br><span class="line">print(E)</span><br><span class="line">print(F)</span><br></pre></td></tr></table></figure>
<h3 id="Numpy-的-array-分割"><a href="#Numpy-的-array-分割" class="headerlink" title="Numpy 的 array 分割"></a>Numpy 的 array 分割</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(A)</span><br><span class="line"></span><br><span class="line"><span class="comment"># split 只能均分</span></span><br><span class="line"></span><br><span class="line">print(np.split(A,<span class="number">3</span>,axis=<span class="number">0</span>)) <span class="comment"># 纵向分割</span></span><br><span class="line"></span><br><span class="line">print(np.split(A,<span class="number">2</span>,axis=<span class="number">1</span>)) <span class="comment"># 横向分割</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># array_split 可以不均分</span></span><br><span class="line"></span><br><span class="line">print(np.array_split(A,<span class="number">2</span>,axis=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">print(np.vsplit(A,<span class="number">3</span>)) <span class="comment"># vertical split</span></span><br><span class="line"></span><br><span class="line">print(np.hsplit(A,<span class="number">1</span>)) <span class="comment"># horizontal split</span></span><br></pre></td></tr></table></figure>
<h3 id="Numpy-的-copy-amp-deep-copy"><a href="#Numpy-的-copy-amp-deep-copy" class="headerlink" title="Numpy 的 copy &amp; deep copy"></a>Numpy 的 copy &amp; deep copy</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">4</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line">c = a</span><br><span class="line">d = b</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line">print(a,b,c,d)</span><br><span class="line"></span><br><span class="line">print(b <span class="keyword">is</span> a)</span><br><span class="line">print(d <span class="keyword">is</span> a)</span><br><span class="line"></span><br><span class="line">b = a.copy() <span class="comment"># deep copy 将a的值赋给b，两者之间没有关联。</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">22</span>,<span class="number">33</span>]</span><br><span class="line">b[<span class="number">3</span>] = <span class="number">44</span></span><br><span class="line">print(a,b)</span><br></pre></td></tr></table></figure>
<h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,np.nan,<span class="number">44</span>]) <span class="comment"># pandas 序列</span></span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line">dates = pd.date_range(start=<span class="string">'20190629'</span>,periods=<span class="number">6</span>) <span class="comment"># 日期 index</span></span><br><span class="line">print(dates)</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">4</span>),index=dates,columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">print(df1)</span><br><span class="line"></span><br><span class="line">df2 = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'A'</span>:<span class="number">1.0</span>,</span><br><span class="line">    <span class="string">'B'</span>:pd.Timestamp(<span class="string">'20181215'</span>),</span><br><span class="line">    <span class="string">'C'</span>:pd.Series(<span class="number">1</span>,index=list(range(<span class="number">4</span>)),dtype=<span class="string">'float64'</span>),</span><br><span class="line">    <span class="string">'D'</span>:np.array([<span class="number">3</span>]*<span class="number">4</span>,dtype=<span class="string">'int32'</span>),</span><br><span class="line">    <span class="string">'E'</span>:pd.Categorical([<span class="string">'test'</span>,<span class="string">'train'</span>,<span class="string">'test'</span>,<span class="string">'train'</span>]),</span><br><span class="line">    <span class="string">'F'</span>:<span class="string">'foo'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">print(df2)</span><br><span class="line">print(<span class="string">f'dtype:\n<span class="subst">&#123;df2.dtypes&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'index:\n<span class="subst">&#123;df2.index&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'columns:\n<span class="subst">&#123;df2.columns&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'values:\n<span class="subst">&#123;df2.values&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'Desc:\n<span class="subst">&#123;df2.describe()&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'T:\n<span class="subst">&#123;df2.T&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">print(df2.sort_index(axis=<span class="number">0</span>,ascending=<span class="literal">False</span>))</span><br><span class="line">print(df2.sort_index(axis=<span class="number">1</span>,ascending=<span class="literal">False</span>))</span><br><span class="line">print(df2.sort_values(by=<span class="string">'E'</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Pandas-选择数据"><a href="#Pandas-选择数据" class="headerlink" title="Pandas 选择数据"></a>Pandas 选择数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dates = pd.date_range(start=<span class="string">'20190629'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates,columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line"></span><br><span class="line">print(df,end=<span class="string">'\n\n'</span>)</span><br><span class="line"></span><br><span class="line">print(df[<span class="string">'A'</span>],df.A,end=<span class="string">'\n\n'</span>,sep=<span class="string">'\n\n'</span>) <span class="comment"># 列</span></span><br><span class="line">print(df[<span class="number">0</span>:<span class="number">3</span>],df[<span class="string">'20190629'</span>:<span class="string">'20190701'</span>],end=<span class="string">'\n\n'</span>,sep=<span class="string">'\n\n'</span>) <span class="comment"># 行</span></span><br><span class="line">print(df[<span class="number">0</span>:<span class="number">3</span>][<span class="string">'A'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># select by label: loc</span></span><br><span class="line">print(df.loc[<span class="string">'20190629'</span>],</span><br><span class="line">      df.loc[<span class="string">'20190629'</span>,[<span class="string">'A'</span>,<span class="string">'B'</span>]],sep=<span class="string">'\n\n'</span>,end=<span class="string">'\n\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># select by position: iloc</span></span><br><span class="line">print(df.iloc[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">      df.iloc[:,<span class="number">1</span>:<span class="number">3</span>],</span><br><span class="line">      df.iloc[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],<span class="number">1</span>:<span class="number">4</span>],sep=<span class="string">'\n\n'</span>,end=<span class="string">'\n\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mixed selection: ix :: this way is deprecated.</span></span><br><span class="line"><span class="comment"># print(df.ix[:3,['A','B']])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Boolean indexing</span></span><br><span class="line">print(df[df.A &gt; <span class="number">6</span>])</span><br></pre></td></tr></table></figure>
<h3 id="Pandas-设置值"><a href="#Pandas-设置值" class="headerlink" title="Pandas 设置值"></a>Pandas 设置值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dates = pd.date_range(start=<span class="string">'20190629'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates,columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line"></span><br><span class="line">df.iloc[<span class="number">1</span>,<span class="number">2</span>] = <span class="number">2222</span></span><br><span class="line">df.loc[<span class="string">'20190701'</span>,<span class="string">'C'</span>] = <span class="number">3333</span></span><br><span class="line">df.B[df.A &gt; <span class="number">8</span>] = <span class="number">0</span></span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line">df[<span class="string">'E'</span>] = np.nan</span><br><span class="line">df[<span class="string">'F'</span>] = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],index=pd.date_range(start=<span class="string">'20190629'</span>,periods=<span class="number">6</span>))</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>
<h3 id="Pandas-处理丢失数据"><a href="#Pandas-处理丢失数据" class="headerlink" title="Pandas 处理丢失数据"></a>Pandas 处理丢失数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dates = pd.date_range(start=<span class="string">'20190629'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates,columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line"></span><br><span class="line">df.iloc[<span class="number">0</span>,<span class="number">1</span>] = np.nan</span><br><span class="line">df.iloc[<span class="number">1</span>,<span class="number">2</span>] = <span class="literal">None</span></span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line">print(df.dropna(axis=<span class="number">0</span>,how=<span class="string">'any'</span>)) <span class="comment"># how = &#123;'any','all'&#125; 删除丢失数据</span></span><br><span class="line">print(df.dropna(axis=<span class="number">1</span>,how=<span class="string">'any'</span>)) <span class="comment"># how = &#123;'any','all'&#125;</span></span><br><span class="line"></span><br><span class="line">print(df.fillna(value=<span class="number">0</span>)) <span class="comment"># 使用value填充丢失数据</span></span><br><span class="line"></span><br><span class="line">print(df.isnull()) <span class="comment"># 判断是否丢失数据</span></span><br><span class="line"></span><br><span class="line">print(np.any(df.isnull()) == <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Pandas-导入-amp-导出-数据"><a href="#Pandas-导入-amp-导出-数据" class="headerlink" title="Pandas 导入 &amp; 导出 数据"></a>Pandas 导入 &amp; 导出 数据</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Format Type</th>
<th>Data Description</th>
<th>Reader</th>
<th>Writer</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">text</td>
<td>CSV</td>
<td>read_csv</td>
<td>to_csv</td>
</tr>
<tr>
<td style="text-align:left">text</td>
<td>JSON</td>
<td>read_json</td>
<td>to_json</td>
</tr>
<tr>
<td style="text-align:left">text</td>
<td>HTML</td>
<td>read_html</td>
<td>to_html</td>
</tr>
<tr>
<td style="text-align:left">text</td>
<td>Local clipboard</td>
<td>read_clipboard</td>
<td>to_clipboard</td>
</tr>
<tr>
<td style="text-align:left">binary</td>
<td>MS Excel</td>
<td>read_excel</td>
<td>to_excel</td>
</tr>
<tr>
<td style="text-align:left">binary</td>
<td>HDF5 Format</td>
<td>read_hdf</td>
<td>to_hdf</td>
</tr>
<tr>
<td style="text-align:left">binary</td>
<td>Feather Format</td>
<td>read_feather</td>
<td>to_feather</td>
</tr>
<tr>
<td style="text-align:left">binary</td>
<td>Parquet Format</td>
<td>read_parquet</td>
<td>to_parquet</td>
</tr>
<tr>
<td style="text-align:left">binary</td>
<td>Msgpack</td>
<td>read_msgpack</td>
<td>to_msgpack</td>
</tr>
<tr>
<td style="text-align:left">binary</td>
<td>Stata</td>
<td>read_stata</td>
<td>to_stata</td>
</tr>
<tr>
<td style="text-align:left">binary</td>
<td>SAS</td>
<td>read_sas</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">binary</td>
<td>Python Pickle Format</td>
<td>read_pickle</td>
<td>to_pickle</td>
</tr>
<tr>
<td style="text-align:left">SQL</td>
<td>SQL</td>
<td>read_sql</td>
<td>to_sql</td>
</tr>
<tr>
<td style="text-align:left">SQL</td>
<td>Google Big Query</td>
<td>read_gbq</td>
<td>to_gbq</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'Student.csv'</span>)</span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line">df.to_pickle(<span class="string">'student.pickle'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Pandas-合并-concat"><a href="#Pandas-合并-concat" class="headerlink" title="Pandas 合并  concat"></a>Pandas 合并  concat</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># concatenating</span></span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df3 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">2</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line"></span><br><span class="line">res = pd.concat([df1,df2,df3],axis=<span class="number">0</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">res = pd.concat([df1,df2,df3],axis=<span class="number">0</span>,ignore_index=<span class="literal">True</span>)<span class="comment"># ignore_index 重新对index排序</span></span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">res = pd.concat([df1,df2,df3],axis=<span class="number">1</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># join = ['inner','outer']  default:outer</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>],index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>,columns=[<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>],index=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = pd.concat([df1,df2],axis=0)</span></span><br><span class="line">res = pd.concat([df1,df2],axis=<span class="number">0</span>,join=<span class="string">'inner'</span>,ignore_index=<span class="literal">True</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># join axes</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>],index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>,columns=[<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>],index=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = pd.concat([df1,df2],axis=1,join_axes=[df1.index]) # 横向合并时，指定合并的index，</span></span><br><span class="line">res = pd.concat([df1,df2],axis=<span class="number">0</span>,join_axes=[df1.columns])</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># append</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df3 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>,columns=[<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>],index=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = df1.append(df2,ignore_index=True)</span></span><br><span class="line"><span class="comment"># res = df1.append([df2,df3])</span></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">res = df1.append(s,ignore_index=<span class="literal">True</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<h3 id="Pandas-合并-merge"><a href="#Pandas-合并-merge" class="headerlink" title="Pandas 合并  merge"></a>Pandas 合并  merge</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">merge two df by key/keys (may be used in database)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">left = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'key'</span>:[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K2'</span>,<span class="string">'K3'</span>],</span><br><span class="line">    <span class="string">'A'</span>:[<span class="string">'A0'</span>,<span class="string">'A1'</span>,<span class="string">'A2'</span>,<span class="string">'A3'</span>],</span><br><span class="line">    <span class="string">'B'</span>:[<span class="string">'B0'</span>,<span class="string">'B1'</span>,<span class="string">'B2'</span>,<span class="string">'B3'</span>],</span><br><span class="line">&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'key'</span>:[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K2'</span>,<span class="string">'K3'</span>],</span><br><span class="line">    <span class="string">'C'</span>:[<span class="string">'C0'</span>,<span class="string">'C1'</span>,<span class="string">'C2'</span>,<span class="string">'C3'</span>],</span><br><span class="line">    <span class="string">'D'</span>:[<span class="string">'D0'</span>,<span class="string">'D1'</span>,<span class="string">'D2'</span>,<span class="string">'D3'</span>],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">print(left)</span><br><span class="line">print(right)</span><br><span class="line"></span><br><span class="line">res = pd.merge(left,right,on=<span class="string">'key'</span>) <span class="comment"># merge by the column named 'key'</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">consider two keys</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">left = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'key1'</span>:[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K1'</span>,<span class="string">'K3'</span>],</span><br><span class="line">    <span class="string">'key2'</span>:[<span class="string">'K0'</span>,<span class="string">'K0'</span>,<span class="string">'K0'</span>,<span class="string">'K2'</span>],</span><br><span class="line">    <span class="string">'A'</span>:[<span class="string">'A0'</span>,<span class="string">'A1'</span>,<span class="string">'A2'</span>,<span class="string">'A3'</span>],</span><br><span class="line">    <span class="string">'B'</span>:[<span class="string">'B0'</span>,<span class="string">'B1'</span>,<span class="string">'B2'</span>,<span class="string">'B3'</span>],</span><br><span class="line">&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'key1'</span>:[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K2'</span>,<span class="string">'K3'</span>],</span><br><span class="line">    <span class="string">'key2'</span>:[<span class="string">'K0'</span>,<span class="string">'K0'</span>,<span class="string">'K2'</span>,<span class="string">'K3'</span>],</span><br><span class="line">    <span class="string">'C'</span>:[<span class="string">'C0'</span>,<span class="string">'C1'</span>,<span class="string">'C2'</span>,<span class="string">'C3'</span>],</span><br><span class="line">    <span class="string">'D'</span>:[<span class="string">'D0'</span>,<span class="string">'D1'</span>,<span class="string">'D2'</span>,<span class="string">'D3'</span>],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">print(left)</span><br><span class="line">print(right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = pd.merge(left,right,on=['key1','key2'])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># how = ['left', 'right', 'outer', 'inner'] default:inner 合并方式</span></span><br><span class="line">res = pd.merge(left,right,on=[<span class="string">'key1'</span>,<span class="string">'key2'</span>],how=<span class="string">'left'</span>)</span><br><span class="line"></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># indicator</span></span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">0</span>,<span class="number">1</span>],<span class="string">'col_left'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],<span class="string">'col_right'</span>:[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]&#125;)</span><br><span class="line"></span><br><span class="line">print(df1)</span><br><span class="line">print(df2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = pd.merge(df1,df2,on='col1',how='outer',indicator=True)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># give the indicator a custome name</span></span><br><span class="line">res = pd.merge(df1,df2,on=<span class="string">'col1'</span>,how=<span class="string">'outer'</span>,indicator=<span class="string">'indicator_name'</span>)</span><br><span class="line"></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># merge by index</span></span><br><span class="line"></span><br><span class="line">left = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'A'</span>:[<span class="string">'A0'</span>,<span class="string">'A1'</span>,<span class="string">'A2'</span>,<span class="string">'A3'</span>],</span><br><span class="line">    <span class="string">'B'</span>:[<span class="string">'B0'</span>,<span class="string">'B1'</span>,<span class="string">'B2'</span>,<span class="string">'B3'</span>],</span><br><span class="line">&#125;,index=[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K2'</span>,<span class="string">'K3'</span>])</span><br><span class="line"></span><br><span class="line">right = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'C'</span>:[<span class="string">'C0'</span>,<span class="string">'C1'</span>,<span class="string">'C2'</span>,<span class="string">'C3'</span>],</span><br><span class="line">    <span class="string">'D'</span>:[<span class="string">'D0'</span>,<span class="string">'D1'</span>,<span class="string">'D2'</span>,<span class="string">'D3'</span>],</span><br><span class="line">&#125;,index=[<span class="string">'K0'</span>,<span class="string">'K2'</span>,<span class="string">'K3'</span>,<span class="string">'K4'</span>])</span><br><span class="line"></span><br><span class="line">print(left)</span><br><span class="line">print(right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = pd.merge(left,right,left_index=True,right_index=True,how='outer')</span></span><br><span class="line">res = pd.merge(left,right,left_index=<span class="literal">True</span>,right_index=<span class="literal">True</span>,how=<span class="string">'inner'</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># handle overlapping</span></span><br><span class="line"></span><br><span class="line">boys = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'k'</span>:[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K2'</span>],</span><br><span class="line">    <span class="string">'age'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">girls = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'k'</span>:[<span class="string">'K0'</span>,<span class="string">'K0'</span>,<span class="string">'K1'</span>],</span><br><span class="line">    <span class="string">'age'</span>:[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">res = pd.merge(boys,girls,on=<span class="string">'k'</span>,suffixes=[<span class="string">'_boy'</span>,<span class="string">'_girl'</span>],how=<span class="string">'inner'</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># join</span></span><br></pre></td></tr></table></figure>
<h3 id="Pandas-plot-图表"><a href="#Pandas-plot-图表" class="headerlink" title="Pandas plot 图表"></a>Pandas plot 图表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Series</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data = pd.Series(np.random.randn(1000),index=np.arange(1000))</span></span><br><span class="line"></span><br><span class="line">data = pd.DataFrame(np.random.randn(<span class="number">1000</span>,<span class="number">4</span>),index=np.arange(<span class="number">1000</span>),columns=list(<span class="string">'ABCD'</span>))</span><br><span class="line">data = data.cumsum() <span class="comment"># 类是reduce，累加</span></span><br><span class="line">data.plot()</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot method:</span></span><br><span class="line"><span class="comment"># 'bar','hist','plot','scatter','kde','area','box','hexbin','pie'</span></span><br><span class="line"></span><br><span class="line">ax = data.plot.scatter(x=<span class="string">'A'</span>,y=<span class="string">'B'</span>,color=<span class="string">'DarkBlue'</span>,label=<span class="string">'Class 1'</span>)</span><br><span class="line">data.plot.scatter(x=<span class="string">'A'</span>,y=<span class="string">'C'</span>,color=<span class="string">'DarkGreen'</span>,label=<span class="string">'Class 2'</span>,ax=ax)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/my/images/numpy_and_pandas/output_40_0.png" alt="png"></p>
<p><img src="/my/images/numpy_and_pandas/output_40_1.png" alt="png"></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title>Python教程</title>
    <url>/2019/06/29/python-advanced-tutorial/</url>
    <content><![CDATA[<h1 id="Python-基础"><a href="#Python-基础" class="headerlink" title="Python 基础"></a>Python 基础</h1><h2 id="面向对象高级"><a href="#面向对象高级" class="headerlink" title="面向对象高级"></a>面向对象高级</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 约束当前类的属性</span></span><br><span class="line">    __slots__ = (<span class="string">'_name'</span>,<span class="string">'_age'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self,age)</span>:</span></span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._age &lt; <span class="number">16</span>:</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;self._name&#125;</span>正在玩飞行棋.'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;self._name&#125;</span>正在玩斗地主.'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_vaild</span><span class="params">(self,age)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> age &gt;= <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类方法：生成当前类对象，类方法第一个参数约定为cls。</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls(<span class="string">'Demo'</span>,<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,grade)</span>:</span></span><br><span class="line">        super().__init__(name,age)</span><br><span class="line">        self._grade = grade</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._grade</span><br><span class="line"></span><br><span class="line"><span class="meta">    @grade.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(self,grade)</span>:</span></span><br><span class="line">        self._grade = grade</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span><span class="params">(self,course)</span>:</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;self._grade&#125;</span>的<span class="subst">&#123;self._name&#125;</span>正在学习<span class="subst">&#123;course&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">p = Person.create()</span><br><span class="line">p.play()</span><br><span class="line">stu = Student(<span class="string">'WinterGu'</span>,<span class="number">24</span>,<span class="number">2015</span>)</span><br><span class="line">stu.study(<span class="string">'概率论'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta,abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,nickname)</span>:</span></span><br><span class="line">        self._nickname = nickname</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 抽象方法</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_voice</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""发出声音"""</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Pet)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_voice</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;self._nickname&#125;</span>: 汪汪汪...'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Pet)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_voice</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;self._nickname&#125;</span>: 喵喵喵...'</span>)</span><br><span class="line"></span><br><span class="line">pets = [Dog(<span class="string">'旺财'</span>),Dog(<span class="string">'小黑'</span>),Cat(<span class="string">'Kitty'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pet <span class="keyword">in</span> pets:</span><br><span class="line">    pet.make_voice()</span><br></pre></td></tr></table></figure>
<h2 id="GUI开发"><a href="#GUI开发" class="headerlink" title="GUI开发"></a>GUI开发</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change_label_text</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> flag</span><br><span class="line">        flag = <span class="keyword">not</span> flag</span><br><span class="line">        color,msg = (<span class="string">'red'</span>,<span class="string">'Hello,World!'</span>) <span class="keyword">if</span> flag <span class="keyword">else</span> (<span class="string">'blue'</span>,<span class="string">'Goodbye,World!'</span>)</span><br><span class="line">        label.config(text=msg,fg=color)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">confirm_to_quit</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> tkinter.messagebox.askokcancel(<span class="string">'温馨提示'</span>, <span class="string">'确定要退出吗?'</span>):</span><br><span class="line">            top.quit()</span><br><span class="line"></span><br><span class="line">    top = tkinter.Tk()</span><br><span class="line">    top.geometry(<span class="string">'240x160'</span>)</span><br><span class="line">    top.title(<span class="string">'小游戏'</span>)</span><br><span class="line">    label = tkinter.Label(top, text=<span class="string">'Hello, world!'</span>, font=<span class="string">'Arial -32'</span>, fg=<span class="string">'red'</span>)</span><br><span class="line">    label.pack(expand=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 创建一个装按钮的容器</span></span><br><span class="line">    panel = tkinter.Frame(top)</span><br><span class="line">    <span class="comment"># 创建按钮对象 指定添加到哪个容器中 通过command参数绑定事件回调函数</span></span><br><span class="line">    button1 = tkinter.Button(panel, text=<span class="string">'修改'</span>, command=change_label_text)</span><br><span class="line">    button1.pack(side=<span class="string">'left'</span>)</span><br><span class="line">    button2 = tkinter.Button(panel, text=<span class="string">'退出'</span>, command=confirm_to_quit)</span><br><span class="line">    button2.pack(side=<span class="string">'right'</span>)</span><br><span class="line">    panel.pack(side=<span class="string">'bottom'</span>)</span><br><span class="line">    <span class="comment"># 开启主事件循环</span></span><br><span class="line">    tkinter.mainloop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><ol>
<li>排序</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(origin_items,comp=lambda x,y: x&lt;y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    选择排序</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    items = origin_items[:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(items)<span class="number">-1</span>):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(items)):</span><br><span class="line">            <span class="keyword">if</span> comp(items[j],items[min_index]):</span><br><span class="line">                min_index = j</span><br><span class="line">        items[i],items[min_index] = items[min_index],items[i]</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(origin_items,comp=lambda x,y: x&lt;y)</span>:</span></span><br><span class="line">    items = origin_items[:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(items)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(items)-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> comp(items[j+<span class="number">1</span>],items[j]):</span><br><span class="line">                items[j],items[j+<span class="number">1</span>] = items[j+<span class="number">1</span>],items[j]</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(items,comp=lambda x,y:x&lt;y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    归并排序（分治法）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(items) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> items[:]</span><br><span class="line">    mid = len(items)//<span class="number">2</span></span><br><span class="line">    left = merge_sort(items[:mid],comp)</span><br><span class="line">    right = merge_sort(items[mid:],comp)</span><br><span class="line">    <span class="keyword">return</span> merge(left,right,comp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(item1,item2,comp)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    合并（将两个有序的列表合并成一个）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    items = []</span><br><span class="line">    index1,index2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index1 &lt; len(item1) <span class="keyword">and</span> index2 &lt; len(item2):</span><br><span class="line">        <span class="keyword">if</span> comp(item1[index1],item2[index2]):</span><br><span class="line">            items.append(item1[index1])</span><br><span class="line">            index1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            items.append(item2[index2])</span><br><span class="line">            index2 += <span class="number">1</span></span><br><span class="line">    items.extend(item1[index1:])</span><br><span class="line">    items.extend(item2[index2:])</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line">o_items = list(range(<span class="number">10</span>,<span class="number">1</span>,<span class="number">-1</span>))</span><br><span class="line">print(<span class="string">f'Origin list:<span class="subst">&#123;o_items&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'list after select_sort:<span class="subst">&#123;select_sort(o_items)&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'list after bubble_sort:<span class="subst">&#123;bubble_sort(o_items)&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'list after merge_sort:<span class="subst">&#123;merge_sort(o_items)&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>查找</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">seq_search</span><span class="params">(items,key)</span>:</span></span><br><span class="line">    <span class="string">"""顺序查找"""</span></span><br><span class="line">    <span class="keyword">for</span> index,item <span class="keyword">in</span> enumerate(items):</span><br><span class="line">        <span class="keyword">if</span> item == key:</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(items,key)</span>:</span></span><br><span class="line">    start,end = <span class="number">0</span>,len(items)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> key &gt; items[mid]:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> key &lt; items[mid]:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ol>
<li>生成式语法和嵌套列表</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prices = &#123;</span><br><span class="line">    <span class="string">'AAPL'</span>: <span class="number">191.88</span>,</span><br><span class="line">    <span class="string">'GOOG'</span>: <span class="number">1186.96</span>,</span><br><span class="line">    <span class="string">'IBM'</span>: <span class="number">149.24</span>,</span><br><span class="line">    <span class="string">'ORCL'</span>: <span class="number">48.44</span>,</span><br><span class="line">    <span class="string">'ACN'</span>: <span class="number">166.89</span>,</span><br><span class="line">    <span class="string">'FB'</span>: <span class="number">208.09</span>,</span><br><span class="line">    <span class="string">'SYMC'</span>: <span class="number">21.29</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 用股票价格大于100元的股票构造一个新的字典</span></span><br><span class="line">prices2 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> prices.items() <span class="keyword">if</span> value &gt; <span class="number">100</span>&#125;</span><br><span class="line">print(prices2)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">'关羽'</span>, <span class="string">'张飞'</span>, <span class="string">'赵云'</span>, <span class="string">'马超'</span>, <span class="string">'黄忠'</span>]</span><br><span class="line">courses = [<span class="string">'语文'</span>, <span class="string">'数学'</span>, <span class="string">'英语'</span>]</span><br><span class="line"><span class="comment"># 录入五个学生三门课程的成绩</span></span><br><span class="line"><span class="comment"># scores = [[None] * len(courses)] * len(names)</span></span><br><span class="line">scores = [[<span class="literal">None</span>] * len(courses) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(names))]</span><br><span class="line"><span class="keyword">for</span> row, name <span class="keyword">in</span> enumerate(names):</span><br><span class="line">    <span class="keyword">for</span> col, course <span class="keyword">in</span> enumerate(courses):</span><br><span class="line">        scores[row][col] = float(input(<span class="string">f'请输入<span class="subst">&#123;name&#125;</span>的<span class="subst">&#123;course&#125;</span>成绩: '</span>))</span><br><span class="line">        print(scores)</span><br></pre></td></tr></table></figure>
<ol>
<li>heapq,itertools的用法</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">从列表中找出最大的或最小的N个元素</span></span><br><span class="line"><span class="string">堆结构(大根堆/小根堆)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">99</span>, <span class="number">87</span>, <span class="number">63</span>, <span class="number">58</span>, <span class="number">78</span>, <span class="number">88</span>, <span class="number">92</span>]</span><br><span class="line">list2 = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'IBM'</span>, <span class="string">'shares'</span>: <span class="number">100</span>, <span class="string">'price'</span>: <span class="number">91.1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'AAPL'</span>, <span class="string">'shares'</span>: <span class="number">50</span>, <span class="string">'price'</span>: <span class="number">543.22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'FB'</span>, <span class="string">'shares'</span>: <span class="number">200</span>, <span class="string">'price'</span>: <span class="number">21.09</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'HPQ'</span>, <span class="string">'shares'</span>: <span class="number">35</span>, <span class="string">'price'</span>: <span class="number">31.75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'YHOO'</span>, <span class="string">'shares'</span>: <span class="number">45</span>, <span class="string">'price'</span>: <span class="number">16.35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'ACME'</span>, <span class="string">'shares'</span>: <span class="number">75</span>, <span class="string">'price'</span>: <span class="number">115.65</span>&#125;</span><br><span class="line">]</span><br><span class="line">print(heapq.nlargest(<span class="number">3</span>, list1))</span><br><span class="line">print(heapq.nsmallest(<span class="number">3</span>, list1))</span><br><span class="line">print(heapq.nlargest(<span class="number">2</span>, list2, key=<span class="keyword">lambda</span> x: x[<span class="string">'price'</span>]))</span><br><span class="line">print(heapq.nlargest(<span class="number">2</span>, list2, key=<span class="keyword">lambda</span> x: x[<span class="string">'shares'</span>]))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">迭代工具 - 排列 / 组合 / 笛卡尔积</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.permutations(<span class="string">'ABCD'</span>):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.combinations(<span class="string">'ABCDE'</span>, <span class="number">3</span>):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.product(<span class="string">'ABCD'</span>, <span class="string">'123'</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<ol>
<li>collections 模块 下的工具</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">words = [</span><br><span class="line">    <span class="string">'look'</span>, <span class="string">'into'</span>, <span class="string">'my'</span>, <span class="string">'eyes'</span>, <span class="string">'look'</span>, <span class="string">'into'</span>, <span class="string">'my'</span>, <span class="string">'eyes'</span>,</span><br><span class="line">    <span class="string">'the'</span>, <span class="string">'eyes'</span>, <span class="string">'the'</span>, <span class="string">'eyes'</span>, <span class="string">'the'</span>, <span class="string">'eyes'</span>, <span class="string">'not'</span>, <span class="string">'around'</span>,</span><br><span class="line">    <span class="string">'the'</span>, <span class="string">'eyes'</span>, <span class="string">"don't"</span>, <span class="string">'look'</span>, <span class="string">'around'</span>, <span class="string">'the'</span>, <span class="string">'eyes'</span>,</span><br><span class="line">    <span class="string">'look'</span>, <span class="string">'into'</span>, <span class="string">'my'</span>, <span class="string">'eyes'</span>, <span class="string">"you're"</span>, <span class="string">'under'</span></span><br><span class="line">]</span><br><span class="line">counter = Counter(words)</span><br><span class="line">print(counter.most_common(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<ol>
<li>常用算法<ul>
<li>穷举法 - 又称为暴力破解法，对所有的可能性进行验证，直到找到正确答案。</li>
<li>贪婪法 - 在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。</li>
<li>分治法 - 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解。</li>
<li>回溯法 - 回溯法又称为试探法，按选优条件向前搜索，当搜索到某一步发现原先选择并不优或达不到目标时，就退回一步重新选择。</li>
<li>动态规划 - 基本思想也是将待求解问题分解成若干个子问题，先求解并保存这些子问题的解，避免产生大量的重复运算。</li>
</ul>
</li>
</ol>
<ul>
<li>穷举法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 公鸡5元一只 母鸡3元一只 小鸡1元三只</span></span><br><span class="line"><span class="comment"># 用100元买100只鸡 问公鸡/母鸡/小鸡各多少只</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">33</span>):</span><br><span class="line">        z = <span class="number">100</span> - x - y</span><br><span class="line">        <span class="keyword">if</span> <span class="number">5</span>*x + <span class="number">3</span>*y + z // <span class="number">3</span> == <span class="number">100</span> <span class="keyword">and</span> z % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">            print(x,y,z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A、B、C、D、E五人在某天夜里合伙捕鱼 最后疲惫不堪各自睡觉</span></span><br><span class="line"><span class="comment"># 第二天A第一个醒来 他将鱼分为5份 扔掉多余的1条 拿走自己的一份</span></span><br><span class="line"><span class="comment"># B第二个醒来 也将鱼分为5份 扔掉多余的1条 拿走自己的一份</span></span><br><span class="line"><span class="comment"># 然后C、D、E依次醒来也按同样的方式分鱼 问他们至少捕了多少条鱼</span></span><br><span class="line"></span><br><span class="line">fish = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    total = fish</span><br><span class="line">    enough = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">if</span> (total - <span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            total = (total - <span class="number">1</span>) // <span class="number">5</span> * <span class="number">4</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            enough = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> enough :</span><br><span class="line">        print(fish)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    fish += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>贪婪法例子：假设小偷有一个背包，最多能装20公斤赃物，他闯入一户人家，发现如下表所示的物品。很显然，他不能把所有物品都装进背包，所以必须确定拿走哪些物品，留下哪些物品。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">价格（美元）</th>
<th style="text-align:center">重量（kg）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">电脑</td>
<td style="text-align:center">200</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">收音机</td>
<td style="text-align:center">20</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">钟</td>
<td style="text-align:center">175</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">花瓶</td>
<td style="text-align:center">50</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">书</td>
<td style="text-align:center">10</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">油画</td>
<td style="text-align:center">90</td>
<td style="text-align:center">9</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">贪婪法：在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。</span></span><br><span class="line"><span class="string">输入：</span></span><br><span class="line"><span class="string">20 6</span></span><br><span class="line"><span class="string">电脑 200 20</span></span><br><span class="line"><span class="string">收音机 20 4</span></span><br><span class="line"><span class="string">钟 175 10</span></span><br><span class="line"><span class="string">花瓶 50 2</span></span><br><span class="line"><span class="string">书 10 1</span></span><br><span class="line"><span class="string">油画 90 9</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,price,weight)</span></span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.price = price</span><br><span class="line">        self.weight= weight</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">value</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""价格重量比"""</span></span><br><span class="line">        <span class="keyword">return</span> self.weight / self.price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_thing</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""输入物品信息"""</span></span><br><span class="line">    name_str, price_str, weight_str = input().split()</span><br><span class="line">    <span class="keyword">return</span> name_str, int(price_str), int(weight_str)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    max_weight,num_of_thing = map(int,input().split())</span><br><span class="line">    all_things = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_of_thing)</span><br><span class="line">        all_things.append(Thing(*input_thing()))</span><br><span class="line"></span><br><span class="line">    all_things.sort(key=<span class="keyword">lambda</span> x: x.value,reverse=<span class="literal">True</span>)</span><br><span class="line">    total_weight = <span class="number">0</span></span><br><span class="line">    total_price = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> all_things:</span><br><span class="line">        <span class="keyword">if</span> item.weight + total_weight &lt;= max_weight:</span><br><span class="line">            print(<span class="string">f'小偷偷走了<span class="subst">&#123;item.name&#125;</span>'</span>)</span><br><span class="line">            total_weight += item.weight</span><br><span class="line">            total_price += item.price</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    print(<span class="string">f'总价值：<span class="subst">&#123;total_price&#125;</span>美元'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<ul>
<li>分治法例子：快速排序。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">快速排序 - 选择枢轴对元素进行划分，左边都比枢轴小右边都比枢轴大</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(origin_items,comp=lambda x,y : x&lt;=y)</span>:</span></span><br><span class="line">    items = origin_items[:]</span><br><span class="line">    _quick_sort(items,<span class="number">0</span>,len(items)<span class="number">-1</span>,comp)</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_quick_sort</span><span class="params">(items,start,end,comp)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start &lt; end:</span><br><span class="line">        pos = _partition(items, start, end, comp)</span><br><span class="line">        _quick_sort(items, start, pos - <span class="number">1</span>, comp)</span><br><span class="line">        _quick_sort(items, pos + <span class="number">1</span>, end, comp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_partition</span><span class="params">(items, start, end, comp)</span>:</span></span><br><span class="line">    <span class="string">"""划分"""</span></span><br><span class="line">    pivot = items[end]</span><br><span class="line">    i = start <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(start,end):</span><br><span class="line">        <span class="keyword">if</span> comp(items[j],pivot):</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            items[i], items[j] = items[j], items[i]</span><br><span class="line">    items[i + <span class="number">1</span>], items[end] = items[end], items[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>回溯法例子：骑士巡逻。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">递归回溯法：叫称为试探法，按选优条件向前搜索，当搜索到某一步，发现原先选择并不优或达不到目标时，就退回一步重新选择，比较经典的问题包括骑士巡逻、八皇后和迷宫寻路等。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">SIZE = <span class="number">5</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_board</span><span class="params">(board)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> board:</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> row:</span><br><span class="line">            print(str(col).center(<span class="number">4</span>), end=<span class="string">''</span>)</span><br><span class="line">        print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patrol</span><span class="params">(board, row, col, step=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> row &gt;= <span class="number">0</span> <span class="keyword">and</span> row &lt; SIZE <span class="keyword">and</span> \</span><br><span class="line">        col &gt;= <span class="number">0</span> <span class="keyword">and</span> col &lt; SIZE <span class="keyword">and</span> \</span><br><span class="line">        board[row][col] == <span class="number">0</span>:</span><br><span class="line">        board[row][col] = step</span><br><span class="line">        <span class="keyword">if</span> step == SIZE * SIZE:</span><br><span class="line">            <span class="keyword">global</span> total</span><br><span class="line">            total += <span class="number">1</span></span><br><span class="line">            print(<span class="string">f'第<span class="subst">&#123;total&#125;</span>种走法: '</span>)</span><br><span class="line">            print_board(board)</span><br><span class="line">        patrol(board, row - <span class="number">2</span>, col - <span class="number">1</span>, step + <span class="number">1</span>)</span><br><span class="line">        patrol(board, row - <span class="number">1</span>, col - <span class="number">2</span>, step + <span class="number">1</span>)</span><br><span class="line">        patrol(board, row + <span class="number">1</span>, col - <span class="number">2</span>, step + <span class="number">1</span>)</span><br><span class="line">        patrol(board, row + <span class="number">2</span>, col - <span class="number">1</span>, step + <span class="number">1</span>)</span><br><span class="line">        patrol(board, row + <span class="number">2</span>, col + <span class="number">1</span>, step + <span class="number">1</span>)</span><br><span class="line">        patrol(board, row + <span class="number">1</span>, col + <span class="number">2</span>, step + <span class="number">1</span>)</span><br><span class="line">        patrol(board, row - <span class="number">1</span>, col + <span class="number">2</span>, step + <span class="number">1</span>)</span><br><span class="line">        patrol(board, row - <span class="number">2</span>, col + <span class="number">1</span>, step + <span class="number">1</span>)</span><br><span class="line">        board[row][col] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    board = [[<span class="number">0</span>] * SIZE <span class="keyword">for</span> _ <span class="keyword">in</span> range(SIZE)]</span><br><span class="line">    patrol(board, SIZE - <span class="number">1</span>, SIZE - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<ul>
<li>动态规划例子1：斐波拉切数列。（不使用动态规划将会是几何级数复杂度）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">动态规划 - 适用于有重叠子问题和最优子结构性质的问题</span></span><br><span class="line"><span class="string">使用动态规划方法所耗时间往往远少于朴素解法(用空间换取时间)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(num, temp=&#123;&#125;)</span>:</span></span><br><span class="line">    <span class="string">"""用递归计算Fibonacci数"""</span></span><br><span class="line">    <span class="keyword">if</span> num <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> temp[num]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        temp[num] = fib(num - <span class="number">1</span>) + fib(num - <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> temp[num]</span><br></pre></td></tr></table></figure>
<p>动态规划例子2：子列表元素之和的最大值。（使用动态规划可以避免二重循环）</p>
<blockquote>
<p>说明：子列表指的是列表中索引（下标）连续的元素构成的列表；列表中的元素是int类型，可能包含正整数、0、负整数；程序输入列表中的元素，输出子列表元素求和的最大值，例如：</p>
<p>输入：1 -2 3 5 -3 2</p>
<p>输出：8</p>
<p>输入：0 -2 3 5 -1 2</p>
<p>输出：9</p>
<p>输入：-9 -2 -3 -5 -3</p>
<p>输出：-2</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    items = list(map(int, input().split()))</span><br><span class="line">    size = len(items)</span><br><span class="line">    overall, partial = &#123;&#125;, &#123;&#125;</span><br><span class="line">    overall[size - <span class="number">1</span>] = partial[size - <span class="number">1</span>] = items[size - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(size - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        partial[i] = max(items[i], partial[i + <span class="number">1</span>] + items[i])</span><br><span class="line">        overall[i] = max(partial[i], overall[i + <span class="number">1</span>])</span><br><span class="line">    print(overall[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h2><pre><code>- 函数
    - 函数可以赋值给变量
    - 函数可以作为函数的参数
    - 函数可以作为函数的返回值

- 高阶函数的用法（filter、map以及它们的替代品）
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">item = map(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,filter(<span class="keyword">lambda</span> x : x%<span class="number">2</span>,range(<span class="number">10</span>)))</span><br><span class="line">item2 = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>位置参数、可变参数、关键字参数、命名关键字参数</p>
</li>
<li><p>参数的元信息（代码可读性问题）</p>
</li>
<li><p>匿名函数和内联函数的用法（lambda函数）</p>
</li>
<li><p>闭包和作用域问题</p>
<ul>
<li><p>Python搜索变量的LEGB顺序（Local —&gt; Embedded —&gt; Global —&gt; Built-in）</p>
</li>
<li><p>global和nonlocal关键字的作用</p>
<p>  global：声明或定义全局变量（要么直接使用现有的全局作用域的变量，要么定义一个变量放到全局作用域）。</p>
<p>  nonlocal：声明使用嵌套作用域的变量（嵌套作用域必须存在该变量，否则报错）。</p>
</li>
</ul>
</li>
<li><p>装饰器函数（使用装饰器和取消装饰器）</p>
<p>  例子：输出函数执行时间的装饰器。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time,sleep</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""自定义装饰函数的装饰器"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;func.__name__&#125;</span>: <span class="subst">&#123;time() - start&#125;</span>秒'</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@record_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">()</span>:</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">download()</span><br></pre></td></tr></table></figure>
<p>如果装饰器不希望跟<code>print</code>函数耦合，可以编写带参数的装饰器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record</span><span class="params">(output)</span>:</span></span><br><span class="line">    <span class="string">"""自定义带参数的装饰器"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            start = time()</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            output(func.__name__, time() - start)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="meta">@record(print)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">()</span>:</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">download()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""自定义装饰器类(通过__call__魔术方法使得对象可以当成函数调用)"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, output)</span>:</span></span><br><span class="line">        self.output = output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            start = time()</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            self.output(func.__name__, time() - start)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@Record(print)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">()</span>:</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">download()</span><br></pre></td></tr></table></figure>
<p>例子：用装饰器来实现单例模式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="string">"""装饰类的修饰器"""</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="comment"># 确保线程安全</span></span><br><span class="line">    lock = Lock()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(cls)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            <span class="keyword">with</span> lock:</span><br><span class="line">                <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">                    instances[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">President</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""总统(单例类)"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = President()</span><br><span class="line">b = President()</span><br><span class="line"></span><br><span class="line">print(id(a))</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ol>
<li><p>三大特性：封装、继承、多态</p>
<p> 例子：工资结算系统</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">月薪结算系统 - 部门经理每月15000 程序员每小时200 销售员1800底薪加销售额5%提成</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta,abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emplyee</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line">    <span class="string">"""员工实体类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""工资结算方法(抽象方法)"""</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Emplyee)</span>:</span></span><br><span class="line">    <span class="string">"""部门经理"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">15000.00</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span><span class="params">(Emplyee)</span>:</span></span><br><span class="line">    <span class="string">"""程序员"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,working_hours)</span>:</span></span><br><span class="line">        self.working_hours = working_hours</span><br><span class="line">        super().__init__(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">200.00</span> * self.working_hours</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salesman</span><span class="params">(Emplyee)</span>:</span></span><br><span class="line">    <span class="string">"""销售员"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,sales = <span class="number">0.0</span>)</span>:</span></span><br><span class="line">        self.sales = sales</span><br><span class="line">        super().__init__(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1800</span> + self.sales * <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeFactory</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""创建员工的工厂（工厂模式 - 通过工厂实现对象使用者和对象之间的解耦合）"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(emp_type, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""创建员工"""</span></span><br><span class="line">        emp_type = emp_type.upper()</span><br><span class="line">        emp = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> emp_type == <span class="string">'M'</span>:</span><br><span class="line">            emp = Manager(*args, **kwargs)</span><br><span class="line">        <span class="keyword">elif</span> emp_type == <span class="string">'P'</span>:</span><br><span class="line">            emp = Programmer(*args, **kwargs)</span><br><span class="line">        <span class="keyword">elif</span> emp_type == <span class="string">'S'</span>:</span><br><span class="line">            emp = Salesman(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> emp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""主函数"""</span></span><br><span class="line">    emps = [</span><br><span class="line">        EmployeeFactory.create(<span class="string">'M'</span>, <span class="string">'曹操'</span>),</span><br><span class="line">        EmployeeFactory.create(<span class="string">'P'</span>, <span class="string">'荀彧'</span>, <span class="number">120</span>),</span><br><span class="line">        EmployeeFactory.create(<span class="string">'P'</span>, <span class="string">'郭嘉'</span>, <span class="number">85</span>),</span><br><span class="line">        EmployeeFactory.create(<span class="string">'S'</span>, <span class="string">'典韦'</span>, <span class="number">123000</span>),</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> emp <span class="keyword">in</span> emps:</span><br><span class="line">        print(<span class="string">'%s: %.2f元'</span> % (emp.name, emp.get_salary()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<ol>
<li>类与类之间的关系</li>
</ol>
<ul>
<li>is-a关系：继承</li>
<li>has-a关系：关联 / 聚合 / 合成</li>
<li>use-a关系：依赖</li>
</ul>
<p>例子：扑克游戏。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">经验：符号常量总是优于字面常量，枚举类型是定义符号常量的最佳选择</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Suite</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    <span class="string">"""花色"""</span></span><br><span class="line"></span><br><span class="line">    SPADE, HEART, CLUB, DIAMOND = range(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.value &lt; other.value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""牌"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, suite, face)</span>:</span></span><br><span class="line">        <span class="string">"""初始化方法"""</span></span><br><span class="line">        self.suite = suite</span><br><span class="line">        self.face = face</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""显示牌面"""</span></span><br><span class="line">        suites = [<span class="string">'♠️'</span>, <span class="string">'♥️'</span>, <span class="string">'♣️'</span>, <span class="string">'♦️'</span>]</span><br><span class="line">        faces = [<span class="string">''</span>, <span class="string">'A'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'10'</span>, <span class="string">'J'</span>, <span class="string">'Q'</span>, <span class="string">'K'</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'<span class="subst">&#123;suites[self.suite.value]&#125;</span> <span class="subst">&#123;faces[self.face]&#125;</span>'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poker</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""扑克"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line">        self.cards = [Card(suite, face) <span class="keyword">for</span> suite <span class="keyword">in</span> Suite <span class="keyword">for</span> face <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">14</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shuffle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""洗牌（随机乱序）"""</span></span><br><span class="line">        random.shuffle(self.cards)</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""发牌"""</span></span><br><span class="line">        card = self.cards[self.index]</span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> card</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_more</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.index &lt; len(self.cards)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""玩家"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.cards = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span><span class="params">(self, card)</span>:</span></span><br><span class="line">        <span class="string">"""摸一张牌"""</span></span><br><span class="line">        self.cards.append(card)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(self, comp=lambda card: <span class="params">(card.suite, card.face)</span>)</span>:</span></span><br><span class="line">        <span class="string">"""整理手上的牌"""</span></span><br><span class="line">        self.cards.sort(key=comp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""主函数"""</span></span><br><span class="line">    poker = Poker()</span><br><span class="line">    poker.shuffle()</span><br><span class="line">    players = [Player(<span class="string">'东邪'</span>), Player(<span class="string">'西毒'</span>), Player(<span class="string">'南帝'</span>), Player(<span class="string">'北丐'</span>)]</span><br><span class="line">    <span class="keyword">while</span> poker.has_more:</span><br><span class="line">        <span class="keyword">for</span> player <span class="keyword">in</span> players:</span><br><span class="line">            player.get_one(poker.deal())</span><br><span class="line">        <span class="keyword">for</span> player <span class="keyword">in</span> players:</span><br><span class="line">            player.sort()</span><br><span class="line">            print(player.name, end=<span class="string">': '</span>)</span><br><span class="line">            print(player.cards)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>extra</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trangles</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用生成式生成杨辉三角形</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    p = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> p</span><br><span class="line">        p = [<span class="number">1</span>] + [p[x] + p[x+<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> range(len(p)<span class="number">-1</span>)] + [<span class="number">1</span>]</span><br><span class="line">f = trangles()</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br></pre></td></tr></table></figure>
<ol>
<li><p>对象的复制（深复制/深拷贝/深度克隆和浅复制/浅拷贝/影子克隆）</p>
</li>
<li><p>垃圾回收、循环引用和弱引用</p>
</li>
</ol>
<p>Python使用了自动化内存管理，这种管理机制以引用计数为基础，同时也引入了标记-清除和分代收集两种机制为辅的策略。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_object &#123;</span><br><span class="line">    <span class="comment">/* 引用计数 */</span></span><br><span class="line">    <span class="keyword">int</span> ob_refcnt;</span><br><span class="line">    <span class="comment">/* 对象指针 */</span></span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br><span class="line">``                                         `</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 增加引用计数的宏定义 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_INCREF(op)   ((op)-&gt;ob_refcnt++)</span></span><br><span class="line"><span class="comment">/* 减少引用计数的宏定义 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_DECREF(op) \ <span class="comment">//减少计数</span></span></span><br><span class="line">    <span class="keyword">if</span> (--(op)-&gt;ob_refcnt != <span class="number">0</span>) \</span><br><span class="line">        ; \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        __Py_Dealloc((PyObject *)(op))</span><br></pre></td></tr></table></figure></p>
<p>导致引用计数+1的情况：</p>
<pre><code>- 对象被创建，例如a = 23
- 对象被引用，例如b = a
- 对象被作为参数，传入到一个函数中，例如f(a)
- 对象作为一个元素，存储在容器中，例如list1 = [a, a]
</code></pre><p>导致引用计数-1的情况：</p>
<pre><code>- 对象的别名被显式销毁，例如del a
- 对象的别名被赋予新的对象，例如a = 24
- 一个对象离开它的作用域，例如f函数执行完毕时，f函数中的局部变量（全局变量不会）
- 对象所在的容器被销毁，或从容器中删除对象
</code></pre><p>引用计数可能会导致循环引用问题，而循环引用会导致内存泄露，如下面的代码所示。为了解决这个问题，Python中引入了“标记-清除”和“分代收集”。在创建一个对象的时候，对象被放在第一代中，如果在第一代的垃圾检查中对象存活了下来，该对象就会被放到第二代中，同理在第二代的垃圾检查中对象存活下来，该对象就会被放到第三代中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收</span></span><br><span class="line"><span class="comment"># 在Python 3.6以前如果重写__del__魔术方法会导致循环引用处理失效</span></span><br><span class="line"><span class="comment"># 如果不想造成循环引用可以使用弱引用</span></span><br><span class="line">list1 = []</span><br><span class="line">list2 = []</span><br><span class="line">list1.append(list2)</span><br><span class="line">list2.append(list1)</span><br></pre></td></tr></table></figure>
<p>以下情况会导致垃圾回收：</p>
<ul>
<li>调用gc.collect()</li>
<li>gc模块的计数器达到阀值</li>
<li>程序退出</li>
</ul>
<p>如果循环引用中两个对象都定义了<code>__del__</code>方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的<code>__del__</code>方法，这个问题在Python 3.6中得到了解决。</p>
<p>也可以通过<code>weakref</code>模块构造弱引用的方式来解决循环引用的问题。</p>
<p>魔法属性和方法（请参考《Python魔法方法指南》）</p>
<p>有几个小问题请大家思考：</p>
<ul>
<li>自定义的对象能不能使用运算符做运算？</li>
<li>自定义的对象能不能放到set中？能去重吗？</li>
<li>自定义的对象能不能作为dict的键？</li>
<li>自定义的对象能不能使用上下文语法？</li>
</ul>
<ol>
<li>混入（Mixin）</li>
</ol>
<p>例子：自定义字典限制只有在指定的key不存在时才能在字典中设置键值对。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetOnceMappingMinxin</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""自定义混入类"""</span></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self,key,value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(str(key)+<span class="string">' already set'</span>)</span><br><span class="line">        <span class="keyword">return</span> super().__setitem__(key,value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetOnceDict</span><span class="params">(SetOnceMappingMinxin,dict)</span>:</span></span><br><span class="line">    <span class="string">"""自定义词典"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_dict = SetOnceDict()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    my_dict[<span class="string">'username'</span>] = <span class="string">'jackfrued'</span></span><br><span class="line">    my_dict[<span class="string">'username'</span>] = <span class="string">'hellokitty'</span></span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(my_dict)</span><br></pre></td></tr></table></figure>
<h2 id="元编程和元类"><a href="#元编程和元类" class="headerlink" title="元编程和元类"></a>元编程和元类</h2><p>例子：用元类实现单例模式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""自定义元类"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        cls.__instance = <span class="literal">None</span></span><br><span class="line">        cls.__lock = threading.Lock()</span><br><span class="line">        super().__init__(*args,**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">with</span> cls.__lock:</span><br><span class="line">                <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    cls.__instance = super().__call__(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Persident</span><span class="params">(metaclass=SingletonMeta)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = Persident()</span><br><span class="line">b = Persident()</span><br><span class="line">print(id(a))</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure>
<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><p>单一职责原则 （<strong>S</strong>RP）- 一个类只做该做的事情（类的设计要高内聚）<br>开闭原则 （<strong>O</strong>CP）- 软件实体应该对扩展开发对修改关闭<br>依赖倒转原则（DIP）- 面向抽象编程（在弱类型语言中已经被弱化）<br>里氏替换原则（<strong>L</strong>SP） - 任何时候可以用子类对象替换掉父类对象<br>接口隔离原则（<strong>I</strong>SP）- 接口要小而专不要大而全（Python中没有接口的概念）<br>合成聚合复用原则（CARP） - 优先使用强关联关系而不是继承关系复用代码<br>最少知识原则（迪米特法则，Lo<strong>D</strong>）- 不要给没有必然联系的对象发消息</p>
<blockquote>
<p>说明：上面加粗的字母放在一起称为面向对象的<strong>SOLID</strong>原则。</p>
</blockquote>
<h2 id="GoF设计模式"><a href="#GoF设计模式" class="headerlink" title="GoF设计模式"></a>GoF设计模式</h2><p>创建型模式：单例、工厂、建造者、原型<br>结构型模式：适配器、门面（外观）、代理<br>行为型模式：迭代器、观察者、状态、策略</p>
<p>例子：可插拔的哈希算法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamHasher</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""哈希摘要生成器(策略模式)"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,alg=<span class="string">'md5'</span>,size=<span class="number">4096</span>)</span>:</span></span><br><span class="line">        self.size = size</span><br><span class="line">        self.alg = alg.lower()</span><br><span class="line">        self.hasher = getattr(__import__(<span class="string">'hashlib'</span>),alg.lower())()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,stream)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.to_digest(stream)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_digest</span><span class="params">(self,stream)</span>:</span></span><br><span class="line">        <span class="string">"""生成十六进制摘要"""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> buf <span class="keyword">in</span> iter(<span class="keyword">lambda</span>: stream.read(self.size),<span class="string">b''</span>):</span><br><span class="line">            self.hasher.update(buf)</span><br><span class="line">        <span class="keyword">return</span> self.hasher.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""主函数"""</span></span><br><span class="line">    hasher1 = StreamHasher()</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'oo.py'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> stream:</span><br><span class="line">        print(hasher1.to_digest(stream))</span><br><span class="line"></span><br><span class="line">    hasher2 = StreamHasher(<span class="string">'sha1'</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'oo.py'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> stream:</span><br><span class="line">        print(hasher2(stream))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><ul>
<li>和迭代器相关的魔术方法（<code>__iter__</code>和<code>__next__</code>）</li>
<li>两种创建生成器的方式（生成器表达式和<code>yield</code>关键字）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="string">"""生成器"""</span></span><br><span class="line">    a,b = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(num):</span><br><span class="line">        a,b = b, a+b</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""迭代器"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,num)</span>:</span></span><br><span class="line">        self.num = num</span><br><span class="line">        self.a,self,b = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        self.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.idx &lt; self.num:</span><br><span class="line">            self.a,self.b = self.b,self.a + self.b</span><br><span class="line">            self.idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.a</span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br></pre></td></tr></table></figure>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><pre><code>Python中实现并发编程的三种方案：多线程、多进程和异步I/O。并发编程的好处在于可以提升程序的执行效率以及改善用户体验；坏处在于并发的程序不容易开发和调试，同时对其他程序来说它并不友好。

- 多线程：Python中提供了Thread类并辅以Lock、Condition、Event、Semaphore和Barrier。Python中有GIL来防止多个线程同时执行本地字节码，这个锁对于CPython是必须的，因为CPython的内存管理并不是线程安全的，因为GIL的存在多线程并不能发挥CPU的多核特性。
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">面试题：进程和线程的区别和联系？</span></span><br><span class="line"><span class="string">进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程</span></span><br><span class="line"><span class="string">线程 - 操作系统分配CPU的基本单位</span></span><br><span class="line"><span class="string">并发编程（concurrent programming）</span></span><br><span class="line"><span class="string">1. 提升执行性能 - 让程序中没有因果关系的部分可以并发的执行</span></span><br><span class="line"><span class="string">2. 改善用户体验 - 让耗时间的操作不会造成程序的假死</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">PREFIX = <span class="string">'thumbnails'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_thumbnail</span><span class="params">(infile, size, format=<span class="string">'PNG'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""生成指定图片文件的缩略图"""</span></span><br><span class="line">    file, ext = os.path.splitext(infile)</span><br><span class="line">    file = file[file.rfind(<span class="string">'/'</span>) + <span class="number">1</span>:]</span><br><span class="line">    outfile = <span class="string">f'<span class="subst">&#123;PREFIX&#125;</span>/<span class="subst">&#123;file&#125;</span>_<span class="subst">&#123;size[<span class="number">0</span>]&#125;</span>_<span class="subst">&#123;size[<span class="number">1</span>]&#125;</span>.<span class="subst">&#123;ext&#125;</span>'</span></span><br><span class="line">    img = Image.open(infile)</span><br><span class="line">    img.thumbnail(size, Image.ANTIALIAS)</span><br><span class="line">    img.save(outfile, format)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""主函数"""</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(PREFIX):</span><br><span class="line">        os.mkdir(PREFIX)</span><br><span class="line">        <span class="keyword">for</span> infile <span class="keyword">in</span> glob.glob(<span class="string">'images/*.png'</span>):</span><br><span class="line">            <span class="keyword">for</span> size <span class="keyword">in</span> (<span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>):</span><br><span class="line">                <span class="comment"># 创建并启动线程</span></span><br><span class="line">                threading.Thread(</span><br><span class="line">                    target=generate_thumbnail,</span><br><span class="line">                    args=(infile, (size, size))</span><br><span class="line">                ).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>多个线程竞争资源</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">多线程程序如果没有竞争资源处理起来通常也比较简单</span></span><br><span class="line"><span class="string">当多个线程竞争临界资源的时候如果缺乏必要的保护措施就会导致数据错乱</span></span><br><span class="line"><span class="string">说明：临界资源就是被多个线程竞争的资源</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""银行账户"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.balance = <span class="number">0.0</span></span><br><span class="line">        self.lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(self,money)</span>:</span></span><br><span class="line">        <span class="comment"># 使用锁保护临界资源</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            new_balance = self.balance + money</span><br><span class="line">            time.sleep(<span class="number">0.01</span>)</span><br><span class="line">            self.balance = new_balance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMoneyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="string">"""自定义线程"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,account,money)</span>:</span></span><br><span class="line">        self.account = account</span><br><span class="line">        self.money = money</span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.account.deposit(self.money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    account = Account()</span><br><span class="line"></span><br><span class="line">    <span class="string">"""创建线程池"""</span></span><br><span class="line">    futures = []</span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=<span class="number">10</span>)</span><br><span class="line">    futures = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="comment"># 创建线程的第1种方式</span></span><br><span class="line">        <span class="comment"># threading.Thread(</span></span><br><span class="line">        <span class="comment">#     target=account.deposit, args=(1, )</span></span><br><span class="line">        <span class="comment"># ).start()</span></span><br><span class="line">        <span class="comment"># 创建线程的第2种方式</span></span><br><span class="line">        <span class="comment"># AddMoneyThread(account, 1).start()</span></span><br><span class="line">        <span class="comment"># 创建线程的第3种方式</span></span><br><span class="line">        <span class="comment"># 调用线程池中的线程来执行特定的任务</span></span><br><span class="line">        future = pool.submit(account.deposit, <span class="number">1</span>)</span><br><span class="line">        futures.append(future)</span><br><span class="line">    <span class="comment"># 关闭线程池</span></span><br><span class="line">    pool.shutdown()</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">        future.result()</span><br><span class="line">    print(account.balance)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>修改上面的程序，启动5个线程向账户中存钱，5个线程从账户中取钱，取钱时如果余额不足就暂停线程进行等待。为了达到上述目标，需要对存钱和取钱的线程进行调度，在余额不足时取钱的线程暂停并释放锁，而存钱的线程将钱存入后要通知取钱的线程，使其从暂停状态被唤醒。可以使用<code>threading</code>模块的Condition来实现线程调度，该对象也是基于锁来创建的，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">多个线程竞争一个资源 - 保护临界资源 - 锁（Lock/RLock）</span></span><br><span class="line"><span class="string">多个线程竞争多个资源（线程数&gt;资源数） - 信号量（Semaphore）</span></span><br><span class="line"><span class="string">多个线程的调度 - 暂停线程执行/唤醒等待中的线程 - Condition</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""银行账户"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,balance=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.balance = balance</span><br><span class="line">        self.lock = threading.Lock()</span><br><span class="line">        self.condition = threading.Condition(self.lock)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">(self,money)</span>:</span></span><br><span class="line">        <span class="string">"""取钱"""</span></span><br><span class="line">        <span class="keyword">with</span> self.condition:</span><br><span class="line">            <span class="keyword">while</span> self.balance &lt; money:</span><br><span class="line">                self.condition.wait()</span><br><span class="line">            new_balance = self.balance - money</span><br><span class="line">            sleep(<span class="number">0.01</span>)</span><br><span class="line">            self.balance = new_balance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(self,money)</span>:</span></span><br><span class="line">        <span class="string">"""存钱"""</span></span><br><span class="line">        <span class="keyword">with</span> self.condition:</span><br><span class="line">            new_balance = self.balance + money</span><br><span class="line">            time.sleep(<span class="number">0.01</span>)</span><br><span class="line">            self.balance = new_balance</span><br><span class="line">            self.condition.notify_all()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_money</span><span class="params">(account)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        money = randint(<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">        account.deposit(money)</span><br><span class="line">        print(threading.current_thread().name,<span class="string">':'</span>,money,<span class="string">'===&gt;'</span>,account.balance)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub_money</span><span class="params">(account)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        money = randint(<span class="number">10</span>,<span class="number">30</span>)</span><br><span class="line">        account.withdraw(money)</span><br><span class="line">        print(threading.current_thread().name,<span class="string">':'</span>,money,<span class="string">'&lt;==='</span>,account.balance)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    account = Account()</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            pool.submit(add_money,account)</span><br><span class="line">            pool.submit(sub_money,account)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<ul>
<li>多进程：多进程可以有效的解决GIL的问题，实现多进程主要的类是Process，其他辅助的类跟threading模块中的类似，进程间共享数据可以使用管道、套接字等，在multiprocessing模块中有一个Queue类，它基于管道和锁机制提供了多个进程共享的队列。下面是官方文档上关于多进程和进程池的一个示例。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">多进程和进程池的使用</span></span><br><span class="line"><span class="string">多线程因为GIL的存在不能够发挥CPU的多核特性</span></span><br><span class="line"><span class="string">对于计算密集型任务应该考虑使用多进程</span></span><br><span class="line"><span class="string">time python3 example22.py</span></span><br><span class="line"><span class="string">real    0m11.512s</span></span><br><span class="line"><span class="string">user    0m39.319s</span></span><br><span class="line"><span class="string">sys     0m0.169s</span></span><br><span class="line"><span class="string">使用多进程后实际执行时间为11.512秒，而用户时间39.319秒约为实际执行时间的4倍</span></span><br><span class="line"><span class="string">这就证明我们的程序通过多进程使用了CPU的多核特性，而且这台计算机配置了4核的CPU</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">PRIMES = [</span><br><span class="line">    <span class="number">1116281</span>,</span><br><span class="line">    <span class="number">1297337</span>,</span><br><span class="line">    <span class="number">104395303</span>,</span><br><span class="line">    <span class="number">472882027</span>,</span><br><span class="line">    <span class="number">533000389</span>,</span><br><span class="line">    <span class="number">817504243</span>,</span><br><span class="line">    <span class="number">982451653</span>,</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">112582705942171</span>,</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">115280095190773</span>,</span><br><span class="line">    <span class="number">115797848077099</span>,</span><br><span class="line">    <span class="number">1099726899285419</span></span><br><span class="line">] * <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""判断素数"""</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    sqrt_n = int(math.floor(math.sqrt(n)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, sqrt_n + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""主函数"""</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="keyword">for</span> number, prime <span class="keyword">in</span> zip(PRIMES, executor.map(is_prime, PRIMES)):</span><br><span class="line">            print(<span class="string">'%d is prime: %s'</span> % (number, prime))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：<strong>多线程和多进程的比较</strong>。</p>
<p>以下情况需要使用多线程：</p>
<ol>
<li>程序需要维护许多共享的状态（尤其是可变状态），Python中的列表、字典、集合都是线程安全的，所以使用线程而不是进程维护共享状态的代价相对较小。</li>
<li>程序会花费大量时间在I/O操作上，没有太多并行计算的需求且不需占用太多的内存。</li>
</ol>
<p>以下情况需要使用多进程：</p>
<ol>
<li>程序执行计算密集型任务（如：字节码操作、数据处理、科学计算）。</li>
<li>程序的输入可以并行的分成块，并且可以将运算结果合并。</li>
<li>程序在内存使用方面没有任何限制且不强依赖于I/O操作（如：读写文件、套接字等）。</li>
</ol>
</blockquote>
<ul>
<li>异步处理：从调度程序的任务队列中挑选任务，该调度程序以交叉的形式执行这些任务，我们并不能保证任务将以某种顺序去执行，因为执行顺序取决于队列中的一项任务是否愿意将CPU处理时间让位给另一项任务。异步任务通常通过多任务协作处理的方式来实现，由于执行时间和顺序的不确定，因此需要通过回调式编程或者<code>future</code>对象来获取任务执行的结果。Python 3通过<code>asyncio</code>模块和<code>await</code>和<code>async</code>关键字（在Python 3.7中正式被列为关键字）来支持异步处理。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">异步I/O - async / await</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num_generator</span><span class="params">(m,n)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> range(m,n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">prime_filter</span><span class="params">(m,n)</span>:</span></span><br><span class="line">    <span class="string">"""素数过滤器"""</span></span><br><span class="line">    primes = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_generator(m,n):</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>,int(i**<span class="number">0.5</span> + <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            print(<span class="string">"Prime =&gt;"</span>,i)</span><br><span class="line">            primes.append(i)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.001</span>)</span><br><span class="line">    <span class="keyword">return</span> tuple(primes)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">square_mapper</span><span class="params">(m,n)</span>:</span></span><br><span class="line">    <span class="string">"""平方映射器"""</span></span><br><span class="line">    squares = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_generator(m,n):</span><br><span class="line">        print(<span class="string">'Square =&gt;'</span>,i ** <span class="number">2</span>)</span><br><span class="line">        squares.append(i ** <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.001</span>)</span><br><span class="line">    <span class="keyword">return</span> tuple(squares)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""主函数"""</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    future = asyncio.gather(prime_filter(<span class="number">2</span>,<span class="number">100</span>),square_mapper(<span class="number">1</span>,<span class="number">100</span>))</span><br><span class="line">    future.add_done_callback(<span class="keyword">lambda</span> x: print(x.result()))</span><br><span class="line">    loop.run_until_complete(future)</span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：上面的代码使用<code>get_event_loop</code>函数获得系统默认的事件循环，通过<code>gather</code>函数可以获得一个<code>future</code>对象，<code>future</code>对象的<code>add_done_callback</code>可以添加执行完成时的回调函数，<code>loop</code>对象的<code>run_until_complete</code>方法可以等待通过<code>future</code>对象获得协程执行结果。</p>
</blockquote>
<p>Python中有一个名为<code>aiohttp</code>的三方库，它提供了异步的HTTP客户端和服务器，这个三方库可以跟<code>asyncio</code>模块一起工作，并提供了对<code>Future</code>对象的支持。Python 3.6中引入了async和await来定义异步执行的函数以及创建异步上下文，在Python 3.7中它们正式成为了关键字。下面的代码异步的从5个URL中获取页面并通过正则表达式的命名捕获组提取了网站的标题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line">PATTERN = re.compile(<span class="string">r'\&lt;title\&gt;(?P&lt;title&gt;.*)\&lt;\/title\&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_page</span><span class="params">(session,url)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url,ssl=<span class="literal">False</span>) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> resp.text()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">show_title</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        html = <span class="keyword">await</span> fetch_page(session,url)</span><br><span class="line">        print(PATTERN.search(html).group(<span class="string">'title'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    urls = (<span class="string">'https://www.python.org/'</span>,</span><br><span class="line">                 <span class="string">'https://git-scm.com/'</span>,</span><br><span class="line">                 <span class="string">'https://www.jd.com/'</span>,</span><br><span class="line">                 <span class="string">'https://www.taobao.com/'</span>,</span><br><span class="line">                 <span class="string">'https://www.douban.com/'</span>)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [show_title(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：<strong>异步I/O与多进程的比较</strong>。</p>
<p>当程序不需要真正的并发性或并行性，而是更多的依赖于异步处理和回调时，asyncio就是一种很好的选择。如果程序中有大量的等待与休眠时，也应该考虑asyncio，它很适合编写没有实时数据处理需求的Web应用服务器。</p>
</blockquote>
<p>Python还有很多用于处理并行任务的三方库，例如：joblib、PyMP等。实际开发中，要提升系统的可扩展性和并发性通常有垂直扩展（增加单个节点的处理能力）和水平扩展（将单个节点变成多个节点）两种做法。可以通过消息队列来实现应用程序的解耦合，消息队列相当于是多线程同步队列的扩展版本，不同机器上的应用程序相当于就是线程，而共享的分布式消息队列就是原来程序中的Queue。消息队列（面向消息的中间件）的最流行和最标准化的实现是AMQP（高级消息队列协议），AMQP源于金融行业，提供了排队、路由、可靠传输、安全等功能，最著名的实现包括：Apache的ActiveMQ、RabbitMQ等。</p>
<p>要实现任务的异步化，可以使用名为Celery的三方库。Celery是Python编写的分布式任务队列，它使用分布式消息进行工作，可以基于RabbitMQ或Redis来作为后端的消息代理。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
  </entry>
  <entry>
    <title>Linux系统常用命令</title>
    <url>/2019/06/28/command_of_Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><blockquote>
<p>Linux 系统下的命令</p>
</blockquote>
<h2 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h2><ul>
<li>fdisk -l  查看当前分区挂载信息</li>
<li>mkfs  mke2fs 格式化一个未格式化的分区</li>
<li>mount /dev/**  data/   挂载这个设备到 data目录上</li>
<li>umount /dev/** 卸载设备</li>
<li>ls -s -S -a -l -t -F filename  查看文件和文件夹信息</li>
<li>cd</li>
<li>pwd 显示当前所在目录</li>
<li>mkdir 创建一个文件夹</li>
<li>rmdir 删除一个文件</li>
<li>touch 创建一个文件</li>
<li>cat -a -n -b -s 显示文件内容</li>
<li>cat file.txt | ls 分页显示</li>
<li>cat &gt; 文件名 在命令行里输入文件内容 Cirl+D 退出</li>
<li>cat file1 file2 &gt; file3 把file1和file2 输入到file3</li>
<li>cat file2 &gt;&gt; file1 给文件file1 追加内容</li>
<li>cp  f1 f2 文件复制 -i 安全访问的复制</li>
<li>rm 文件/目录  删除文件 -i -r 递归处理 -f 强制删除 -v 显示执行过程 -d 直接吧目录的硬链接数据删成0</li>
<li>mv 文件移动</li>
<li><p>chmod +/-/= 权限类型 文件1  文件2 。。。</p>
<pre><code>  1. + 增加权限 -去除权限 =给予指定权限 删除其他权限
  2. r读w写x可执行
  3. u/g/o/a 所有者/所在组/其他用户/所有用户  a+rw 所有用户读写权限  ug+r 所有者和组增加读权限
</code></pre></li>
<li><p>grep 查找指定文件字符串 -i 不区分大小写</p>
</li>
<li>head -2 file 显示文件前两行内容</li>
<li>tail -1 file 显示文件最后一行内容</li>
<li>wc -l 显示行数 -w显示单词书 -m显示字符数 统计文件的行数单词数和字符数</li>
<li>sort 对文件内容进行排序</li>
<li>sort -t”:” -k2 file 指定每列的分隔符为：，根据文件的第二列排序输出</li>
<li>find file/dir  查看当前目录下的文件和目录</li>
<li>which 命令 查看命令所在的目录</li>
<li>whereis 文件名 查找可执行的命令和包含该文件名的字符串</li>
<li>locate 文件名 查找文件</li>
<li>bzip2 file1 file2 ..压缩命令</li>
<li>bunzip2 文件名 解压命令</li>
<li>gzip 文件压缩解压命令 -d 解压</li>
<li>unzip 解压.zip文件 -d 解压到指定目录 -n 不覆盖原来存在的文件 -v查看文件目录不解压 -o以默认方式覆盖已经存在的文件</li>
<li>zcat 和 bzcat 查看压缩文件内容 不解压</li>
<li>zcat 文件名  查看.gz 文件</li>
<li>bzcat 文件名 查看.bz2 文件</li>
<li>tar 命令 对文件和目录进行打包</li>
<li>tar [-选项] [备份的文件名] [要打包的目录或文件]</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>创建新的打包文件</td>
</tr>
<tr>
<td>-x</td>
<td>抽取.tar 文件的内容</td>
</tr>
<tr>
<td>-z</td>
<td>打包后用gzip压缩或者解压</td>
</tr>
<tr>
<td>-j</td>
<td>就打包后用bzip2进行压缩或者解压操作</td>
</tr>
<tr>
<td>-t</td>
<td>查看一个打包文件的目录</td>
</tr>
<tr>
<td>-f</td>
<td>使用文件或设备</td>
</tr>
<tr>
<td>-v</td>
<td>在压缩或解压后显示详细的文件清单</td>
</tr>
</tbody>
</table>
</div>
<h2 id="磁盘内容"><a href="#磁盘内容" class="headerlink" title="　磁盘内容"></a>　磁盘内容</h2><ul>
<li><p>mount</p>
<p>  mount -t 文件类型 -o 挂接方式 device path</p>
</li>
</ul>
<blockquote>
<p>-t iso9660/ntfs/msdos/smbfs/vfat/nfs -o loop(将文件当作硬盘分区挂接到系统)/iocharset(指定访问的文件<br>系统的字符集)/ro 采用只读的方式挂接/device 要挂接的设备 /rw 采用读写挂接 /dir 设备在系统的挂接点</p>
</blockquote>
<p>光盘文件的挂接</p>
<pre><code>mount -o loop -t iso9660 /ss.iso /mnt/ss
</code></pre><ul>
<li>fdisk -l 查看系统的硬盘和硬盘分区情况</li>
<li>umount 挂载点或设备 卸载一个设备</li>
<li>df 查看当前硬盘的分区信息</li>
<li>df -a 显示所有文件分区和硬盘</li>
<li>df -i 列出i-nodes的使用量</li>
<li>df -k 大小以KB为单位</li>
<li>df -h MB</li>
<li>df -t 列出某个文件系统的分区磁盘使用情况</li>
<li>df -x 列出不是某个文件系统分区磁盘的使用情况</li>
<li><p>df -t 列出每个分区所属文件系统的名称</p>
</li>
<li><p>du 命令 查看当前目录下所有文件和目录的信息</p>
</li>
</ul>
<blockquote>
<p>-a -h -b -c最后加上总计 -s列出各文件大小的总和 -x值计算属于同一个文件系统的文件</p>
</blockquote>
<ul>
<li><p>fsck 分区名 硬盘检测 只能由root使用</p>
</li>
<li><p>shutdown [选项] [时间] [警告信息]</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-h</td>
<td>关闭系统服务安全关机</td>
</tr>
<tr>
<td>-k</td>
<td>不关机只发出警告信息</td>
</tr>
<tr>
<td>-r</td>
<td>通知服务后重启</td>
</tr>
<tr>
<td>-t</td>
<td>在规定的时间关机</td>
</tr>
</tbody>
</table>
</div>
<pre><code>shutdown -h +2 两分钟后关机
</code></pre><ul>
<li>half 关机 ==shutdown -h</li>
<li><p>half -f 强制关机</p>
</li>
<li><p>poweroff 关机</p>
</li>
<li><p>reboot 重启</p>
</li>
<li><p>init 命令 切换ubuntu的运行级别</p>
</li>
<li>init [0-7] 0代表关机 6代表重新启动</li>
</ul>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><ul>
<li>echo [选项] [字符串] 显示命令行中的字符串 用于输出提示信息</li>
</ul>
<blockquote>
<p>-n 输出字符串 光标不换行</p>
</blockquote>
<h3 id="more命令和less命令"><a href="#more命令和less命令" class="headerlink" title="more命令和less命令"></a>more命令和less命令</h3><blockquote>
<p>对文件内容或查询结果进行分屏显示</p>
</blockquote>
<ul>
<li>more [选项] file</li>
<li>less [选项] file</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>不滚动，清屏</td>
</tr>
<tr>
<td>+n</td>
<td>从第n行开始</td>
</tr>
<tr>
<td>-s</td>
<td>将连续的空行压缩成一个空格</td>
</tr>
</tbody>
</table>
</div>
<h3 id="help命令和man命令"><a href="#help命令和man命令" class="headerlink" title="help命令和man命令"></a>help命令和man命令</h3><blockquote>
<p>显示某个命令的格式用法</p>
</blockquote>
<ul>
<li><p>help/man 命令</p>
</li>
<li><p>cal 显示日历</p>
</li>
<li>cal [选项]  -m 以星期一为每周的第一天显示 -y 显示今年年历 -就以凯撒历显示</li>
<li>cal 当前月</li>
<li>cal 2000 2000年年历</li>
<li><p>cal 5 2000 2000年5月</p>
</li>
<li><p>date命令 显示和设定系统的时间日期</p>
</li>
<li><p>ps [选项]查看进程信息</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-e</td>
<td>显示所有进程</td>
</tr>
<tr>
<td>a</td>
<td>显示所有终端下的进程</td>
</tr>
<tr>
<td>-f</td>
<td>以全格式显示</td>
</tr>
<tr>
<td>u</td>
<td>面向用户的格式显示</td>
</tr>
<tr>
<td>-r</td>
<td>显示正在运行的进程</td>
</tr>
<tr>
<td>x</td>
<td>显示所有不控制终端的进程</td>
</tr>
<tr>
<td>-o</td>
<td>以用户定义的格式显示</td>
</tr>
<tr>
<td>-l</td>
<td>查看当前用户进程的优先级</td>
</tr>
</tbody>
</table>
</div>
<p>nice 命令</p>
<blockquote>
<p>改变进程优先级</p>
</blockquote>
<ul>
<li><p>nice [选项] -n为-20-19的值 值越小优先级越高</p>
<p>  nice -10</p>
</li>
<li><p>renice [+/-n] [-g 命令名] [-p 进程标识码] [-u 进程所有者]</p>
</li>
<li><p>fg 命令 使挂起的进程返回前台执行 fg n 代表进程序号</p>
</li>
<li><p>bg 命令 激活被挂起的进程，使之在后台运行</p>
</li>
<li><p>kill [-信号] PID 终止进程</p>
</li>
<li><p>top 命令 监视系统进程</p>
</li>
<li>top [选项]</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>显示整个命令行</td>
</tr>
<tr>
<td>d</td>
<td>指定屏幕刷新秒数，默认3s刷新一次</td>
</tr>
<tr>
<td>i</td>
<td>不显示任何闲置或僵死的进程</td>
</tr>
<tr>
<td>n</td>
<td>指定每秒内监控信息的更新次数</td>
</tr>
<tr>
<td>p</td>
<td>进程标识码列表</td>
</tr>
<tr>
<td>s</td>
<td>是top在安全模式下运行</td>
</tr>
<tr>
<td>S</td>
<td>使用累计模式</td>
</tr>
</tbody>
</table>
</div>
<p>last 命令 列出目前与过去登陆系统用户的信息</p>
<ul>
<li>last [-adRx] [-f] [-n] [账号名称] [终端机标号]</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>把从何处登入系统的主机名称或IP地址显示在最后一行</td>
</tr>
<tr>
<td>-d</td>
<td>把地址转换成主机名称</td>
</tr>
<tr>
<td>-f</td>
<td>指定记录文件</td>
</tr>
<tr>
<td>-n</td>
<td>设置列出名单的显示列数</td>
</tr>
<tr>
<td>-R</td>
<td>不显示登入系统的主机名称或IP</td>
</tr>
<tr>
<td>-x</td>
<td>显示系统关机，重新开机以及执行等级改变等信息</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>free 查看系统内存情况 -m 以MB显示</li>
</ul>
<p>增加用户</p>
<pre><code>useradd [-u uid] [-g group] [-d home_dir] [-s shell] [-c comment] [-m
[-k skeldir]] [-N] [-f incavtive] [-e expire] login`
</code></pre><blockquote>
<p>例子：增加一个jack用户，指定宿主目录为/home/jack shell为/bin/bash</p>
</blockquote>
<pre><code>sudo useradd -u 1001 -d /home/jack -m -s /bin/bash jack
</code></pre><p>增加成功，但是还不能登入系统，因为没有密码</p>
<pre><code>sudo passwd jack 设置jack密码
</code></pre><ul>
<li>userdel 删除用户信息</li>
<li>userdel [-r] login</li>
</ul>
<p><code>userdel -r jack 删除jack用户</code></p>
<p>groupadd 组增加 groupdel 组删除</p>
<ul>
<li>sudo passwd root 给root重设密码 激活root</li>
<li>su root 切换到root</li>
<li><p>sudo passwd -l root 锁定root</p>
</li>
<li><p>sudo 命令既super do 指以超级管理员的身份执行</p>
</li>
<li>passwd  用户  修改用户密码</li>
<li>su 用户 切换用户 su root 当前root激活可以切换</li>
</ul>
<h3 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h3><ul>
<li>apt-get 命令</li>
<li>aptitude 命令</li>
</ul>
<p><code>sudo apt-get dist-upgrade 更新所有软件</code></p>
<h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><ul>
<li>ifconfig 不带参数的显示当前网卡信息</li>
</ul>
<blockquote>
<p>修改网卡地址: ifconfig 设备名称 IP地址  netmask 子网掩码</p>
</blockquote>
<pre><code>sudo ifconfig eth12 192.168.157.141 netmask 255.255.255.0
</code></pre><ul>
<li>DNS 配置 cat /etc/resolv.conf</li>
<li><p>HOST cat /etc/hosts</p>
</li>
<li><p>hostname 命令修改和显示主机名 -i 显示IP</p>
</li>
</ul>
<h3 id="网路命令"><a href="#网路命令" class="headerlink" title="网路命令"></a>网路命令</h3><ul>
<li>ifconfig -interface [options] address</li>
</ul>
<blockquote>
<p>-interface 指定网络接口名如 eth0、eth1</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>up</td>
<td>激活指定的网络接口</td>
</tr>
<tr>
<td>down</td>
<td>关闭指定网络接口</td>
</tr>
<tr>
<td>broadcast address</td>
<td>设置接口广播地址</td>
</tr>
<tr>
<td>pointopoint</td>
<td>启用点对点方式</td>
</tr>
<tr>
<td>address</td>
<td>设置指定接口设备IP地址</td>
</tr>
<tr>
<td>netmask address</td>
<td>设置接口子网掩码</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>ping命令 测试主机网络是否畅通</li>
</ul>
<p><code>ping [选项] 主机名或IP</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>设置响应次数</td>
</tr>
<tr>
<td>-d</td>
<td>使用Socket的SO_DEBUG功能</td>
</tr>
<tr>
<td>-f</td>
<td>极限检查</td>
</tr>
<tr>
<td>-i</td>
<td>指定收发时间间隔单位为s</td>
</tr>
<tr>
<td>-s</td>
<td>byte 设置数据包大小</td>
</tr>
<tr>
<td>-R</td>
<td>记录路由过程</td>
</tr>
<tr>
<td>-r</td>
<td>忽略普通的路由表直接发送到远程主机</td>
</tr>
<tr>
<td>-p</td>
<td>设置填满数据包的范本样式</td>
</tr>
<tr>
<td>-q</td>
<td>不显示命令的执行过程只显示结果</td>
</tr>
<tr>
<td>-t</td>
<td>设置存活数值TTL</td>
</tr>
<tr>
<td>-v</td>
<td>详细显示命令的执行过程</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>netstat 命令 检查网络端口的连接情况</li>
</ul>
<p>netstat [选项]</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>显示所有有效的连接信息</td>
</tr>
<tr>
<td>-r</td>
<td>显示路由的信息</td>
</tr>
<tr>
<td>-i</td>
<td>显示interface网络界面信息的内容</td>
</tr>
<tr>
<td>-n</td>
<td>使用IP代替名称，显示网络情况</td>
</tr>
<tr>
<td>-o</td>
<td>显示计时器</td>
</tr>
<tr>
<td>-h</td>
<td>在线帮助</td>
</tr>
<tr>
<td>-c</td>
<td>持续列出网络状态</td>
</tr>
<tr>
<td>-t</td>
<td>显示TCP连接情况</td>
</tr>
<tr>
<td>-u</td>
<td>显示UDP连接情况</td>
</tr>
<tr>
<td>-v</td>
<td>显示命令执行过程</td>
</tr>
<tr>
<td>-w</td>
<td>显示RAW传输协议连接情况</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>ftp命令和bye命令</li>
</ul>
<blockquote>
<p>ftp 登录FTP服务器，该命令允许用户使用FTP协议进行文件的传输，文件的上传和下载</p>
</blockquote>
<pre><code>ftp 主机名/IP
</code></pre><blockquote>
<p>bye 退出ftp服务器</p>
</blockquote>
<p>ftp 内部命令<br>|||<br>|—-|—-|<br>|ls|列出远程机的当前目录|<br>|cd|改变远程机的工作目录|<br>|lcd|改变本地的工作目录|<br>|close|终止当前的ftp命令|<br>|hash|每次传输完数据缓冲区的数据就显示一个#号|<br>|get|从远程机传送指定文件到本机|<br>|put|从本地传送指定文件到远程机|<br>|quit|断开与远程机的连接，退出ftp|</p>
<ul>
<li>telnet 命令logout命令</li>
</ul>
<p><code>telnet [选项] 主机名/IP地址</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>尝试自动登录远端系统</td>
</tr>
<tr>
<td>-c</td>
<td>不读取用户专属目录里的.telentrc文件</td>
</tr>
<tr>
<td>-8</td>
<td>允许使用8位字符资料，包括输入输出</td>
</tr>
<tr>
<td>-l</td>
<td>指定要登录远端计算机的用户名称</td>
</tr>
<tr>
<td>-b</td>
<td>使用别名指定远端主机的名称</td>
</tr>
<tr>
<td>-n</td>
<td>指定文件记录相关信息</td>
</tr>
</tbody>
</table>
</div>
<p>logout 下线命令</p>
<ul>
<li>rlogin 命令 远程登录</li>
</ul>
<p><code>rlogin 主机名/IP地址</code></p>
<ul>
<li>route命令 表示手工修改产生和查看路由表</li>
</ul>
<p><code>route [选项] targetaddress [选项]</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-add</td>
<td>增加路由</td>
</tr>
<tr>
<td>-delete</td>
<td>删除路由</td>
</tr>
<tr>
<td>-net</td>
<td>路由到达的是一个网络，而不是一台主机</td>
</tr>
<tr>
<td>-host</td>
<td>路由到达的是一台主机</td>
</tr>
<tr>
<td>-netmask Nm</td>
<td>指定路由的子网掩码</td>
</tr>
<tr>
<td>gw</td>
<td>指定路由的网关</td>
</tr>
<tr>
<td>[dev]If</td>
<td>强迫路由连接指定接口</td>
</tr>
</tbody>
</table>
</div>
<p>例子：为了访问网络，必须把计算机的IP地址设置成Linux的默认路由，增加一个路由<br>route add 0.0.0.0 1 Array 192.168.1.1</p>
<ul>
<li>finger 命令 用来查询一台主机上的登录帐号的信息，通常会显示用户名名，主目录，停滞时间，登录时间，登录Shell等</li>
</ul>
<p><code>finger [选项] [使用者] [用户名@主机名]</code><br>-s -l -p</p>
<ul>
<li>mail 命令 发送邮件</li>
</ul>
<p>Mail [-s subject] [-c address] [-b address] mail -f [mailbox]mail [-u user]</p>
<h3 id="Curl"><a href="#Curl" class="headerlink" title="Curl"></a>Curl</h3><pre><code>curl -I 网址   //返回响应头
curl -A testagent 网址 //代理访问
curl -e 网址1 网址2 //伪装网址的来源
curl -i 网址 //在返回的数据中显示响应头
curl --cacert CA证书 网址
curl -v 网址 //显示一次请求的过程
curl -X POST 网址 //指定访问网址的方式
</code></pre><h3 id="Tool-Command"><a href="#Tool-Command" class="headerlink" title="Tool Command"></a>Tool Command</h3><p>清除卸载后的配置文件</p>
<pre><code>dpkg -l |grep ^rc|awk &#39;{print $2}&#39; |sudo xargs dpkg -P
</code></pre><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>使用权限 : 所有使用者</p>
<p>使用方式 :<code>chmod [-cfvR] [--help] [--version] mode file...</code></p>
<p>说明 :</p>
<blockquote>
<p>Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以藉以控制档案如何被他人所调用。</p>
</blockquote>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>mode : 权限设定字串</p>
<p>格式如下 : <code>[ugoa...][[+-=][rwxX]...][,...]</code>，其中</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>表示该档案的拥有者</td>
</tr>
<tr>
<td>g</td>
<td>表示与该档案的拥有者属于同一个群体(group)者</td>
</tr>
<tr>
<td>o</td>
<td>表示其他以外的人</td>
</tr>
<tr>
<td>a</td>
<td>表示这三者皆是。</td>
</tr>
<tr>
<td>+</td>
<td>表示增加权限</td>
</tr>
<tr>
<td>-</td>
<td>表示取消权限</td>
</tr>
<tr>
<td>-</td>
<td>= 表示唯一设定权限。</td>
</tr>
<tr>
<td>r</td>
<td>表示可读取</td>
</tr>
<tr>
<td>w</td>
<td>表示可写入</td>
</tr>
<tr>
<td>x</td>
<td>表示可执行</td>
</tr>
<tr>
<td>X</td>
<td>表示只有当该档案是个子目录或者该档案已经被设定过为可执行。</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>若该档案权限确实已经更改，才显示其更改动作</td>
</tr>
<tr>
<td>-f</td>
<td>若该档案权限无法被更改也不要显示错误讯息</td>
</tr>
<tr>
<td>-v</td>
<td>显示权限变更的详细资料</td>
</tr>
<tr>
<td>-R</td>
<td>对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)</td>
</tr>
<tr>
<td>—help</td>
<td>显示辅助说明</td>
</tr>
<tr>
<td>—version</td>
<td>显示版本</td>
</tr>
</tbody>
</table>
</div>
<p>范例 :将档案 file1.txt 设为所有人皆可读取 :<br><code>chmod ugo+r file1.txt</code></p>
<p>将档案 file1.txt 设为所有人皆可读取:<br><code>chmod a+r file1.txt</code></p>
<p>将档案 file1.txt 与 file2.txt 设为该档案拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入:<br><code>chmod ug+w,o-w file1.txt file2.txt</code></p>
<p>将 ex1.py 设定为只有该档案拥有者可以执行:<br><code>chmod u+x ex1.py</code></p>
<p>将目前目录下的所有档案与子目录皆设为任何人可读取<br><code>chmod -R a+r *</code></p>
<p>此外chmod也可以用数字来表示权限如 chmod 777 file<br>语法为：<code>chmod abc file</code></p>
<p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p>
<p>r=4，w=2，x=1<br>若要rwx属性则4+2+1=7；<br>若要rw-属性则4+2=6；<br>若要r-x属性则4+1=5。</p>
<p>范例：<br><code>chmod a=rwx file</code>和<code>chmod 777 file</code>效果相同</p>
<p><code>chmod ug=rwx,o=x file</code>和<code>chmod 771 file</code>效果相同</p>
<p>若用chmod 4755 filename可使此程序具有root的权限.</p>
<h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>使用权限 : root</p>
<p>使用方式 : <code>chmod [-cfhvR] [--help] [--version] user[] file...</code></p>
<blockquote>
<p>Linux/Unix 是多人多工作业系统，所有的档案皆有拥有者。利用 chown 可以将档案的拥有者加以改变。一般来说，这个指令只有是由 系统管理者(root)所使用，<br>一般使用者没有权限可以改变别人的档案拥有者，也没有权限可以自己的档案拥有者改设为别人。只有系统管理者(root)才 有这样的权限。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>user</td>
<td>新的档案拥有者的使用者</td>
</tr>
<tr>
<td>IDgroup</td>
<td>新的档案拥有者的使用者群体(group)</td>
</tr>
<tr>
<td>-c</td>
<td>若该档案拥有者确实已经更改，才显示其更改动作</td>
</tr>
<tr>
<td>-f</td>
<td>若该档案拥有者无法被更改也不要显示错误讯息</td>
</tr>
<tr>
<td>-h</td>
<td>只对于连结 (link)进行变更，而非该 link 真正指向的档案</td>
</tr>
<tr>
<td>-v</td>
<td>显示拥有者变更的详细资料</td>
</tr>
<tr>
<td>-R</td>
<td>对目前目录下的所有档案与子目录进行相同的拥有者 变更(即以递回的方式逐个变更)</td>
</tr>
<tr>
<td>—help</td>
<td>显示辅助说明</td>
</tr>
<tr>
<td>—version</td>
<td>显示版本</td>
</tr>
</tbody>
</table>
</div>
<p>范例 :<br>将档案 file1.txt 的拥有者设为 users 群体的使用者 jessie :</p>
<p><code>chown jessie:users file1.txt</code></p>
<p>将目前目录下的所有档案与子目录的拥有者皆设为 users 群体的使用者 lamport :</p>
<p><code>chmod -R lamport:users *</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-rw———- (600)</td>
<td>只有属主有读写权限。</td>
</tr>
<tr>
<td>-rw-r—r— (644)</td>
<td>只有属主有读写权限；而属组用户和其他用户只有读权限。</td>
</tr>
<tr>
<td>-rwx——— (700)</td>
<td>只有属主有读、写、执行权限。</td>
</tr>
<tr>
<td>-rwxr-xr-x (755)</td>
<td>属主有读、写、执行权限；而属组用户和其他用户只有读、执行权限。</td>
</tr>
</tbody>
</table>
</div>
<p>-rwx—x—x (711)|属主有读、写、执行权限；而属组用户和其他用户只有执行权限。<br>|-rw-rw-rw- (666)|所有用户都有文件读、写权限。这种做法不可取。|<br>|-rwxrwxrwx (777)|所有用户都有读、写、执行权限。更不可取的做法。|</p>
<p>以下是对目录的两个普通设定:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>drwx——— (700)</td>
<td>只有属主可在目录中读、写。</td>
</tr>
<tr>
<td>drwxr-xr-x (755)</td>
<td>所有用户可读该目录，但只有属主才能改变目录中的内容。</td>
</tr>
</tbody>
</table>
</div>
<p>运行 .sh 文件类型的文件：</p>
<p>用file命令测试一下看是什么类型的</p>
<pre><code>file xxxx.sh
</code></pre><p>如果是Bourne-Again shell script 可以<code>sh xxxx.sh</code> 或者<code>chmod +x xxxx.sh</code>再<code>./xxx.sh</code></p>
<p>一般 .sh 的直接添加x(可执行属性)<code>chmod +x xxx.sh</code> 然后<code>./xxx.sh</code>就可以了</p>
<h2 id="特殊命令"><a href="#特殊命令" class="headerlink" title="特殊命令"></a>特殊命令</h2><p>查看当前静态文件系统信息</p>
<pre><code>cat /etc/fstab
</code></pre><p>查看当前系统磁盘的UUID</p>
<pre><code>ls /dev/disk/by-uuid
</code></pre><p>重新获取IP</p>
<pre><code>dhclient -r 释放IP
dhclient 获取IP
</code></pre>]]></content>
      <categories>
        <category>技能</category>
      </categories>
  </entry>
  <entry>
    <title>Ement</title>
    <url>/2019/06/28/Ement/</url>
    <content><![CDATA[<h2 id="Ement-语法"><a href="#Ement-语法" class="headerlink" title="Ement 语法"></a>Ement 语法</h2><ol>
<li><p>生成 html 框架</p>
<ul>
<li>使用<code>!</code> 或者 <code>html:5</code> 生成 html5基本代码</li>
<li>使用 <code>html:xt</code> 和 <code>html:4s</code> 生成html4过渡型和严格型</li>
</ul>
</li>
<li><p>生成帯<code>class</code> 和 <code>id</code>的标签</p>
<ul>
<li>生成<code>class</code>的标签 标签名<code>.class</code>名。例：<code>div.aaa</code></li>
<li>生成<code>id</code>的标签 标签名<code>#id</code>名。<code>div#aaa</code></li>
</ul>
</li>
<li><p>生成后代：<code>&gt;</code></p>
<ul>
<li><code>div.aaa&gt;ul&gt;li</code></li>
</ul>
</li>
<li><p>生成兄弟：<code>+</code></p>
<blockquote>
<p>同级的标签</p>
</blockquote>
<ul>
<li><code>div.aaa+div.bbb</code></li>
</ul>
</li>
<li><p>生成上级: <code>^</code></p>
<ul>
<li><code>div&gt;ul&gt;li^span</code></li>
</ul>
</li>
<li><p>生成多个元素：<code>*</code></p>
<ul>
<li><code>div&gt;ul&gt;li*5</code></li>
</ul>
</li>
<li><p>生成分组：<code>()</code></p>
<blockquote>
<p>用括号进行分组，这样可以更加明确要生成的结构，特别是层次关系，例如：</p>
<ul>
<li><code>div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p</code></li>
</ul>
</blockquote>
</li>
<li><p>生成自定义属性：<code>[attr]</code></p>
<ul>
<li><code>a[href=&quot;www.taobao.com&quot; title=&quot;淘宝&quot;]</code></li>
</ul>
</li>
<li><p>对生成内容编号：<code>$</code></p>
<ul>
<li><code>ul&gt;li.item$*5</code></li>
<li><code>ul&gt;li.item$$$*5</code></li>
<li>指定倒序排序，加<code>@-</code>: <code>ul&gt;li.item$@-*5</code></li>
<li>制定开始的编号，加<code>@N</code>: <code>ul&gt;li.item$@2*5</code></li>
<li>倒序和制定编号合体：<code>ul&gt;li.item$@-3*5</code></li>
</ul>
</li>
<li><p>生成文本内容：<code>{}</code></p>
<ul>
<li><code>a{click}+span{text}</code></li>
</ul>
</li>
<li><p><strong>注： 不要有空格</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
  </entry>
</search>
